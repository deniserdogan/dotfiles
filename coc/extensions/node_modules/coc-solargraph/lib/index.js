var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// node_modules/solargraph-utils/out/Configuration.js
var require_Configuration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Configuration2 = class {
    constructor(workspace4 = null, useBundler = false, bundlerPath = "bundle", commandPath = "solargraph", withSnippets = false, viewsPath = null) {
      this._workspace = workspace4;
      this._useBundler = useBundler;
      this._bundlerPath = bundlerPath;
      this._commandPath = commandPath;
      this._withSnippets = withSnippets;
      this._viewsPath = viewsPath;
    }
    get workspace() {
      return this._workspace;
    }
    set workspace(path) {
      this._workspace = path;
    }
    get useBundler() {
      return this._useBundler;
    }
    set useBundler(bool) {
      this._useBundler = bool;
    }
    get bundlerPath() {
      return this._bundlerPath;
    }
    set bundlerPath(path) {
      this._bundlerPath = path;
    }
    get commandPath() {
      return this._commandPath;
    }
    set commandPath(path) {
      this._commandPath = path;
    }
    get withSnippets() {
      return this._withSnippets;
    }
    set withSnippets(bool) {
      this._withSnippets = bool;
    }
    get viewsPath() {
      return this._viewsPath;
    }
    set viewsPath(path) {
      this._viewsPath = path;
    }
  };
  exports2.Configuration = Configuration2;
});

// node_modules/nice-try/src/index.js
var require_src = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(fn) {
    try {
      return fn();
    } catch (e) {
    }
  };
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs = require("fs");
  function checkPathExt(path, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path, options);
  }
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs = require("fs");
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path, options || {}, function(er, is2) {
          if (er) {
            reject(er);
          } else {
            resolve(is2);
          }
        });
      });
    }
    core(path, options || {}, function(er, is2) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is2 = false;
        }
      }
      cb(er, is2);
    });
  }
  function sync(path, options) {
    try {
      return core.sync(path, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/cross-spawn/node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  module2.exports = which;
  which.sync = whichSync;
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  function getNotFoundError(cmd) {
    var er = new Error("not found: " + cmd);
    er.code = "ENOENT";
    return er;
  }
  function getPathInfo(cmd, opt) {
    var colon = opt.colon || COLON;
    var pathEnv = opt.path || process.env.PATH || "";
    var pathExt = [""];
    pathEnv = pathEnv.split(colon);
    var pathExtExe = "";
    if (isWindows) {
      pathEnv.unshift(process.cwd());
      pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
      pathExt = pathExtExe.split(colon);
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
      pathEnv = [""];
    return {
      env: pathEnv,
      ext: pathExt,
      extExe: pathExtExe
    };
  }
  function which(cmd, opt, cb) {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    (function F(i, l) {
      if (i === l) {
        if (opt.all && found.length)
          return cb(null, found);
        else
          return cb(getNotFoundError(cmd));
      }
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      ;
      (function E(ii, ll) {
        if (ii === ll)
          return F(i + 1, l);
        var ext = pathExt[ii];
        isexe(p + ext, {pathExt: pathExtExe}, function(er, is2) {
          if (!er && is2) {
            if (opt.all)
              found.push(p + ext);
            else
              return cb(null, p + ext);
          }
          return E(ii + 1, ll);
        });
      })(0, pathExt.length);
    })(0, pathEnv.length);
  }
  function whichSync(cmd, opt) {
    opt = opt || {};
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    for (var i = 0, l = pathEnv.length; i < l; i++) {
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      for (var j = 0, ll = pathExt.length; j < ll; j++) {
        var cur = p + pathExt[j];
        var is2;
        try {
          is2 = isexe.sync(cur, {pathExt: pathExtExe});
          if (is2) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  }
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (opts) => {
    opts = opts || {};
    const env = opts.env || process.env;
    const platform = opts.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
  };
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var which = require_which();
  var pathKey = require_path_key()();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    if (hasCustomCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: (parsed.options.env || process.env)[pathKey],
        pathExt: withoutPathExt ? path.delimiter : void 0
      });
    } catch (e) {
    } finally {
      process.chdir(cwd);
    }
    if (resolved) {
      resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module2.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports2, module2) => {
  "use strict";
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    arg = arg.replace(/(\\*)$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  module2.exports.command = escapeCommand;
  module2.exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = /^#!.*/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports2, module2) => {
  "use strict";
  var shebangRegex = require_shebang_regex();
  module2.exports = function(str) {
    var match = str.match(shebangRegex);
    if (!match) {
      return null;
    }
    var arr = match[0].replace(/#! ?/, "").split(" ");
    var bin = arr[0].split("/").pop();
    var arg = arr[1];
    return bin === "env" ? arg : bin + (arg ? " " + arg : "");
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    let buffer;
    if (Buffer.alloc) {
      buffer = Buffer.alloc(size);
    } else {
      buffer = new Buffer(size);
      buffer.fill(0);
    }
    let fd;
    try {
      fd = fs.openSync(command, "r");
      fs.readSync(fd, buffer, 0, size, 0);
      fs.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  module2.exports = readShebang;
});

// node_modules/cross-spawn/node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var niceTry = require_src();
  var resolveCommand = require_resolveCommand();
  var escape = require_escape();
  var readShebang = require_readShebang();
  var semver = require_semver();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  var supportsShellOption = niceTry(() => semver.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parseShell(parsed) {
    if (supportsShellOption) {
      return parsed;
    }
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    if (isWin) {
      parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.options.windowsVerbatimArguments = true;
    } else {
      if (typeof parsed.options.shell === "string") {
        parsed.command = parsed.options.shell;
      } else if (process.platform === "android") {
        parsed.command = "/system/bin/sh";
      } else {
        parsed.command = "/bin/sh";
      }
      parsed.args = ["-c", shellCommand];
    }
    return parsed;
  }
  function parse(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: void 0,
      original: {
        command,
        args
      }
    };
    return options.shell ? parseShell(parsed) : parseNonShell(parsed);
  }
  module2.exports = parse;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports2, module2) => {
  "use strict";
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module2.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports2, module2) => {
  "use strict";
  var cp = require("child_process");
  var parse = require_parse();
  var enoent = require_enoent();
  function spawn(command, args, options) {
    const parsed = parse(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module2.exports = spawn;
  module2.exports.spawn = spawn;
  module2.exports.sync = spawnSync;
  module2.exports._parse = parse;
  module2.exports._enoent = enoent;
});

// node_modules/shell-escape/shell-escape.js
var require_shell_escape = __commonJS((exports2, module2) => {
  module2.exports = shellescape;
  function shellescape(a) {
    var ret = [];
    a.forEach(function(s) {
      if (!/^[A-Za-z0-9_\/-]+$/.test(s)) {
        s = "'" + s.replace(/'/g, "'\\''") + "'";
        s = s.replace(/^(?:'')+/g, "").replace(/\\'''/g, "\\'");
      }
      ret.push(s);
    });
    return ret.join(" ");
  }
});

// node_modules/ruby-spawn/out/index.js
var require_out = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var os_1 = require("os");
  var child_process = require("child_process");
  var crossSpawn = require_cross_spawn();
  var shellEscape = require_shell_escape();
  var kill = function(child, command) {
    let ps = child_process.spawn("ps", ["-o", "pid,ppid,tty", "-C", command]);
    let out = "";
    ps.stdout.on("data", (buffer) => {
      out += buffer.toString();
    });
    ps.on("exit", () => {
      let lines = out.split("\n");
      lines.shift();
      lines.pop();
      let nums = lines.filter((l) => {
        return l.match(/1[\s]+\?$/);
      }).map((l) => {
        return l.trim().split(" ")[0];
      });
      if (lines.length > 0) {
        child_process.spawn("kill", ["-9"].concat(nums));
      }
    });
  };
  function rubySpawn(command, args, opts = {}, forceKill = false) {
    let cmd = [command].concat(args);
    if (os_1.platform().match(/darwin|linux/)) {
      let shell = process.env.SHELL;
      if (!shell) {
        shell = "/bin/bash";
      }
      if (shell.endsWith("bash") || shell.endsWith("zsh")) {
        let shellCmd = shellEscape(cmd);
        let finalCmd = shellCmd;
        if (opts["cwd"]) {
          finalCmd = `${shellEscape(["cd", opts["cwd"]])} && ${shellCmd}`;
        }
        let shellArgs = [finalCmd];
        shellArgs.unshift("-c");
        shellArgs.unshift("-l");
        let child = child_process.spawn(shell, shellArgs, opts);
        if (forceKill) {
          child.on("exit", (code, signal) => {
            kill(child, ["ruby", command].concat(args).join(" "));
          });
        }
        return child;
      } else {
        return crossSpawn(cmd.shift(), cmd, opts);
      }
    } else {
      return crossSpawn(cmd.shift(), cmd, opts);
    }
  }
  exports2.rubySpawn = rubySpawn;
});

// node_modules/solargraph-utils/out/commands.js
var require_commands = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var ruby_spawn_1 = require_out();
  var commonOptions = function(workspace4) {
    var opts = {};
    if (workspace4) {
      opts["cwd"] = workspace4;
    }
    return opts;
  };
  function solargraphCommand(args, configuration) {
    let cmd = [];
    if (configuration.useBundler && configuration.workspace) {
      cmd.push(configuration.bundlerPath, "exec", "solargraph");
    } else {
      cmd.push(configuration.commandPath);
    }
    var env = commonOptions(configuration.workspace);
    return ruby_spawn_1.rubySpawn(cmd.shift(), cmd.concat(args), env, true);
  }
  exports2.solargraphCommand = solargraphCommand;
  function gemCommand(args, configuration) {
    let cmd = [];
    if (configuration.useBundler && configuration.workspace) {
      cmd.push(configuration.bundlerPath, "exec");
    }
    cmd.push("gem");
    var env = commonOptions(configuration.workspace);
    return ruby_spawn_1.rubySpawn(cmd.shift(), cmd.concat(args), env, true);
  }
  exports2.gemCommand = gemCommand;
  function yardCommand(args, configuration) {
    let cmd = [];
    if (configuration.useBundler && configuration.workspace) {
      cmd.push(configuration.bundlerPath, "exec");
    }
    cmd.push("yard");
    var env = commonOptions(configuration.workspace);
    return ruby_spawn_1.rubySpawn(cmd.shift(), cmd.concat(args), env, true);
  }
  exports2.yardCommand = yardCommand;
});

// node_modules/extend/index.js
var require_extend = __commonJS((exports2, module2) => {
  "use strict";
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray2(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject = function isPlainObject2(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {
    }
    return typeof key === "undefined" || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty2(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj, name)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  module2.exports = function extend2() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (; i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              setProperty(target, {name, newValue: extend2(deep, clone, copy)});
            } else if (typeof copy !== "undefined") {
              setProperty(target, {name, newValue: copy});
            }
          }
        }
      }
    }
    return target;
  };
});

// node_modules/psl/data/rules.json
var require_rules = __commonJS((exports2, module2) => {
  module2.exports = [
    "ac",
    "com.ac",
    "edu.ac",
    "gov.ac",
    "net.ac",
    "mil.ac",
    "org.ac",
    "ad",
    "nom.ad",
    "ae",
    "co.ae",
    "net.ae",
    "org.ae",
    "sch.ae",
    "ac.ae",
    "gov.ae",
    "mil.ae",
    "aero",
    "accident-investigation.aero",
    "accident-prevention.aero",
    "aerobatic.aero",
    "aeroclub.aero",
    "aerodrome.aero",
    "agents.aero",
    "aircraft.aero",
    "airline.aero",
    "airport.aero",
    "air-surveillance.aero",
    "airtraffic.aero",
    "air-traffic-control.aero",
    "ambulance.aero",
    "amusement.aero",
    "association.aero",
    "author.aero",
    "ballooning.aero",
    "broker.aero",
    "caa.aero",
    "cargo.aero",
    "catering.aero",
    "certification.aero",
    "championship.aero",
    "charter.aero",
    "civilaviation.aero",
    "club.aero",
    "conference.aero",
    "consultant.aero",
    "consulting.aero",
    "control.aero",
    "council.aero",
    "crew.aero",
    "design.aero",
    "dgca.aero",
    "educator.aero",
    "emergency.aero",
    "engine.aero",
    "engineer.aero",
    "entertainment.aero",
    "equipment.aero",
    "exchange.aero",
    "express.aero",
    "federation.aero",
    "flight.aero",
    "freight.aero",
    "fuel.aero",
    "gliding.aero",
    "government.aero",
    "groundhandling.aero",
    "group.aero",
    "hanggliding.aero",
    "homebuilt.aero",
    "insurance.aero",
    "journal.aero",
    "journalist.aero",
    "leasing.aero",
    "logistics.aero",
    "magazine.aero",
    "maintenance.aero",
    "media.aero",
    "microlight.aero",
    "modelling.aero",
    "navigation.aero",
    "parachuting.aero",
    "paragliding.aero",
    "passenger-association.aero",
    "pilot.aero",
    "press.aero",
    "production.aero",
    "recreation.aero",
    "repbody.aero",
    "res.aero",
    "research.aero",
    "rotorcraft.aero",
    "safety.aero",
    "scientist.aero",
    "services.aero",
    "show.aero",
    "skydiving.aero",
    "software.aero",
    "student.aero",
    "trader.aero",
    "trading.aero",
    "trainer.aero",
    "union.aero",
    "workinggroup.aero",
    "works.aero",
    "af",
    "gov.af",
    "com.af",
    "org.af",
    "net.af",
    "edu.af",
    "ag",
    "com.ag",
    "org.ag",
    "net.ag",
    "co.ag",
    "nom.ag",
    "ai",
    "off.ai",
    "com.ai",
    "net.ai",
    "org.ai",
    "al",
    "com.al",
    "edu.al",
    "gov.al",
    "mil.al",
    "net.al",
    "org.al",
    "am",
    "co.am",
    "com.am",
    "commune.am",
    "net.am",
    "org.am",
    "ao",
    "ed.ao",
    "gv.ao",
    "og.ao",
    "co.ao",
    "pb.ao",
    "it.ao",
    "aq",
    "ar",
    "com.ar",
    "edu.ar",
    "gob.ar",
    "gov.ar",
    "int.ar",
    "mil.ar",
    "musica.ar",
    "net.ar",
    "org.ar",
    "tur.ar",
    "arpa",
    "e164.arpa",
    "in-addr.arpa",
    "ip6.arpa",
    "iris.arpa",
    "uri.arpa",
    "urn.arpa",
    "as",
    "gov.as",
    "asia",
    "at",
    "ac.at",
    "co.at",
    "gv.at",
    "or.at",
    "au",
    "com.au",
    "net.au",
    "org.au",
    "edu.au",
    "gov.au",
    "asn.au",
    "id.au",
    "info.au",
    "conf.au",
    "oz.au",
    "act.au",
    "nsw.au",
    "nt.au",
    "qld.au",
    "sa.au",
    "tas.au",
    "vic.au",
    "wa.au",
    "act.edu.au",
    "catholic.edu.au",
    "eq.edu.au",
    "nsw.edu.au",
    "nt.edu.au",
    "qld.edu.au",
    "sa.edu.au",
    "tas.edu.au",
    "vic.edu.au",
    "wa.edu.au",
    "qld.gov.au",
    "sa.gov.au",
    "tas.gov.au",
    "vic.gov.au",
    "wa.gov.au",
    "education.tas.edu.au",
    "schools.nsw.edu.au",
    "aw",
    "com.aw",
    "ax",
    "az",
    "com.az",
    "net.az",
    "int.az",
    "gov.az",
    "org.az",
    "edu.az",
    "info.az",
    "pp.az",
    "mil.az",
    "name.az",
    "pro.az",
    "biz.az",
    "ba",
    "com.ba",
    "edu.ba",
    "gov.ba",
    "mil.ba",
    "net.ba",
    "org.ba",
    "bb",
    "biz.bb",
    "co.bb",
    "com.bb",
    "edu.bb",
    "gov.bb",
    "info.bb",
    "net.bb",
    "org.bb",
    "store.bb",
    "tv.bb",
    "*.bd",
    "be",
    "ac.be",
    "bf",
    "gov.bf",
    "bg",
    "a.bg",
    "b.bg",
    "c.bg",
    "d.bg",
    "e.bg",
    "f.bg",
    "g.bg",
    "h.bg",
    "i.bg",
    "j.bg",
    "k.bg",
    "l.bg",
    "m.bg",
    "n.bg",
    "o.bg",
    "p.bg",
    "q.bg",
    "r.bg",
    "s.bg",
    "t.bg",
    "u.bg",
    "v.bg",
    "w.bg",
    "x.bg",
    "y.bg",
    "z.bg",
    "0.bg",
    "1.bg",
    "2.bg",
    "3.bg",
    "4.bg",
    "5.bg",
    "6.bg",
    "7.bg",
    "8.bg",
    "9.bg",
    "bh",
    "com.bh",
    "edu.bh",
    "net.bh",
    "org.bh",
    "gov.bh",
    "bi",
    "co.bi",
    "com.bi",
    "edu.bi",
    "or.bi",
    "org.bi",
    "biz",
    "bj",
    "asso.bj",
    "barreau.bj",
    "gouv.bj",
    "bm",
    "com.bm",
    "edu.bm",
    "gov.bm",
    "net.bm",
    "org.bm",
    "bn",
    "com.bn",
    "edu.bn",
    "gov.bn",
    "net.bn",
    "org.bn",
    "bo",
    "com.bo",
    "edu.bo",
    "gob.bo",
    "int.bo",
    "org.bo",
    "net.bo",
    "mil.bo",
    "tv.bo",
    "web.bo",
    "academia.bo",
    "agro.bo",
    "arte.bo",
    "blog.bo",
    "bolivia.bo",
    "ciencia.bo",
    "cooperativa.bo",
    "democracia.bo",
    "deporte.bo",
    "ecologia.bo",
    "economia.bo",
    "empresa.bo",
    "indigena.bo",
    "industria.bo",
    "info.bo",
    "medicina.bo",
    "movimiento.bo",
    "musica.bo",
    "natural.bo",
    "nombre.bo",
    "noticias.bo",
    "patria.bo",
    "politica.bo",
    "profesional.bo",
    "plurinacional.bo",
    "pueblo.bo",
    "revista.bo",
    "salud.bo",
    "tecnologia.bo",
    "tksat.bo",
    "transporte.bo",
    "wiki.bo",
    "br",
    "9guacu.br",
    "abc.br",
    "adm.br",
    "adv.br",
    "agr.br",
    "aju.br",
    "am.br",
    "anani.br",
    "aparecida.br",
    "arq.br",
    "art.br",
    "ato.br",
    "b.br",
    "barueri.br",
    "belem.br",
    "bhz.br",
    "bio.br",
    "blog.br",
    "bmd.br",
    "boavista.br",
    "bsb.br",
    "campinagrande.br",
    "campinas.br",
    "caxias.br",
    "cim.br",
    "cng.br",
    "cnt.br",
    "com.br",
    "contagem.br",
    "coop.br",
    "cri.br",
    "cuiaba.br",
    "curitiba.br",
    "def.br",
    "ecn.br",
    "eco.br",
    "edu.br",
    "emp.br",
    "eng.br",
    "esp.br",
    "etc.br",
    "eti.br",
    "far.br",
    "feira.br",
    "flog.br",
    "floripa.br",
    "fm.br",
    "fnd.br",
    "fortal.br",
    "fot.br",
    "foz.br",
    "fst.br",
    "g12.br",
    "ggf.br",
    "goiania.br",
    "gov.br",
    "ac.gov.br",
    "al.gov.br",
    "am.gov.br",
    "ap.gov.br",
    "ba.gov.br",
    "ce.gov.br",
    "df.gov.br",
    "es.gov.br",
    "go.gov.br",
    "ma.gov.br",
    "mg.gov.br",
    "ms.gov.br",
    "mt.gov.br",
    "pa.gov.br",
    "pb.gov.br",
    "pe.gov.br",
    "pi.gov.br",
    "pr.gov.br",
    "rj.gov.br",
    "rn.gov.br",
    "ro.gov.br",
    "rr.gov.br",
    "rs.gov.br",
    "sc.gov.br",
    "se.gov.br",
    "sp.gov.br",
    "to.gov.br",
    "gru.br",
    "imb.br",
    "ind.br",
    "inf.br",
    "jab.br",
    "jampa.br",
    "jdf.br",
    "joinville.br",
    "jor.br",
    "jus.br",
    "leg.br",
    "lel.br",
    "londrina.br",
    "macapa.br",
    "maceio.br",
    "manaus.br",
    "maringa.br",
    "mat.br",
    "med.br",
    "mil.br",
    "morena.br",
    "mp.br",
    "mus.br",
    "natal.br",
    "net.br",
    "niteroi.br",
    "*.nom.br",
    "not.br",
    "ntr.br",
    "odo.br",
    "ong.br",
    "org.br",
    "osasco.br",
    "palmas.br",
    "poa.br",
    "ppg.br",
    "pro.br",
    "psc.br",
    "psi.br",
    "pvh.br",
    "qsl.br",
    "radio.br",
    "rec.br",
    "recife.br",
    "ribeirao.br",
    "rio.br",
    "riobranco.br",
    "riopreto.br",
    "salvador.br",
    "sampa.br",
    "santamaria.br",
    "santoandre.br",
    "saobernardo.br",
    "saogonca.br",
    "sjc.br",
    "slg.br",
    "slz.br",
    "sorocaba.br",
    "srv.br",
    "taxi.br",
    "tc.br",
    "teo.br",
    "the.br",
    "tmp.br",
    "trd.br",
    "tur.br",
    "tv.br",
    "udi.br",
    "vet.br",
    "vix.br",
    "vlog.br",
    "wiki.br",
    "zlg.br",
    "bs",
    "com.bs",
    "net.bs",
    "org.bs",
    "edu.bs",
    "gov.bs",
    "bt",
    "com.bt",
    "edu.bt",
    "gov.bt",
    "net.bt",
    "org.bt",
    "bv",
    "bw",
    "co.bw",
    "org.bw",
    "by",
    "gov.by",
    "mil.by",
    "com.by",
    "of.by",
    "bz",
    "com.bz",
    "net.bz",
    "org.bz",
    "edu.bz",
    "gov.bz",
    "ca",
    "ab.ca",
    "bc.ca",
    "mb.ca",
    "nb.ca",
    "nf.ca",
    "nl.ca",
    "ns.ca",
    "nt.ca",
    "nu.ca",
    "on.ca",
    "pe.ca",
    "qc.ca",
    "sk.ca",
    "yk.ca",
    "gc.ca",
    "cat",
    "cc",
    "cd",
    "gov.cd",
    "cf",
    "cg",
    "ch",
    "ci",
    "org.ci",
    "or.ci",
    "com.ci",
    "co.ci",
    "edu.ci",
    "ed.ci",
    "ac.ci",
    "net.ci",
    "go.ci",
    "asso.ci",
    "a\xE9roport.ci",
    "int.ci",
    "presse.ci",
    "md.ci",
    "gouv.ci",
    "*.ck",
    "!www.ck",
    "cl",
    "gov.cl",
    "gob.cl",
    "co.cl",
    "mil.cl",
    "cm",
    "co.cm",
    "com.cm",
    "gov.cm",
    "net.cm",
    "cn",
    "ac.cn",
    "com.cn",
    "edu.cn",
    "gov.cn",
    "net.cn",
    "org.cn",
    "mil.cn",
    "\u516C\u53F8.cn",
    "\u7F51\u7EDC.cn",
    "\u7DB2\u7D61.cn",
    "ah.cn",
    "bj.cn",
    "cq.cn",
    "fj.cn",
    "gd.cn",
    "gs.cn",
    "gz.cn",
    "gx.cn",
    "ha.cn",
    "hb.cn",
    "he.cn",
    "hi.cn",
    "hl.cn",
    "hn.cn",
    "jl.cn",
    "js.cn",
    "jx.cn",
    "ln.cn",
    "nm.cn",
    "nx.cn",
    "qh.cn",
    "sc.cn",
    "sd.cn",
    "sh.cn",
    "sn.cn",
    "sx.cn",
    "tj.cn",
    "xj.cn",
    "xz.cn",
    "yn.cn",
    "zj.cn",
    "hk.cn",
    "mo.cn",
    "tw.cn",
    "co",
    "arts.co",
    "com.co",
    "edu.co",
    "firm.co",
    "gov.co",
    "info.co",
    "int.co",
    "mil.co",
    "net.co",
    "nom.co",
    "org.co",
    "rec.co",
    "web.co",
    "com",
    "coop",
    "cr",
    "ac.cr",
    "co.cr",
    "ed.cr",
    "fi.cr",
    "go.cr",
    "or.cr",
    "sa.cr",
    "cu",
    "com.cu",
    "edu.cu",
    "org.cu",
    "net.cu",
    "gov.cu",
    "inf.cu",
    "cv",
    "cw",
    "com.cw",
    "edu.cw",
    "net.cw",
    "org.cw",
    "cx",
    "gov.cx",
    "cy",
    "ac.cy",
    "biz.cy",
    "com.cy",
    "ekloges.cy",
    "gov.cy",
    "ltd.cy",
    "name.cy",
    "net.cy",
    "org.cy",
    "parliament.cy",
    "press.cy",
    "pro.cy",
    "tm.cy",
    "cz",
    "de",
    "dj",
    "dk",
    "dm",
    "com.dm",
    "net.dm",
    "org.dm",
    "edu.dm",
    "gov.dm",
    "do",
    "art.do",
    "com.do",
    "edu.do",
    "gob.do",
    "gov.do",
    "mil.do",
    "net.do",
    "org.do",
    "sld.do",
    "web.do",
    "dz",
    "com.dz",
    "org.dz",
    "net.dz",
    "gov.dz",
    "edu.dz",
    "asso.dz",
    "pol.dz",
    "art.dz",
    "ec",
    "com.ec",
    "info.ec",
    "net.ec",
    "fin.ec",
    "k12.ec",
    "med.ec",
    "pro.ec",
    "org.ec",
    "edu.ec",
    "gov.ec",
    "gob.ec",
    "mil.ec",
    "edu",
    "ee",
    "edu.ee",
    "gov.ee",
    "riik.ee",
    "lib.ee",
    "med.ee",
    "com.ee",
    "pri.ee",
    "aip.ee",
    "org.ee",
    "fie.ee",
    "eg",
    "com.eg",
    "edu.eg",
    "eun.eg",
    "gov.eg",
    "mil.eg",
    "name.eg",
    "net.eg",
    "org.eg",
    "sci.eg",
    "*.er",
    "es",
    "com.es",
    "nom.es",
    "org.es",
    "gob.es",
    "edu.es",
    "et",
    "com.et",
    "gov.et",
    "org.et",
    "edu.et",
    "biz.et",
    "name.et",
    "info.et",
    "net.et",
    "eu",
    "fi",
    "aland.fi",
    "*.fj",
    "*.fk",
    "fm",
    "fo",
    "fr",
    "asso.fr",
    "com.fr",
    "gouv.fr",
    "nom.fr",
    "prd.fr",
    "tm.fr",
    "aeroport.fr",
    "avocat.fr",
    "avoues.fr",
    "cci.fr",
    "chambagri.fr",
    "chirurgiens-dentistes.fr",
    "experts-comptables.fr",
    "geometre-expert.fr",
    "greta.fr",
    "huissier-justice.fr",
    "medecin.fr",
    "notaires.fr",
    "pharmacien.fr",
    "port.fr",
    "veterinaire.fr",
    "ga",
    "gb",
    "gd",
    "ge",
    "com.ge",
    "edu.ge",
    "gov.ge",
    "org.ge",
    "mil.ge",
    "net.ge",
    "pvt.ge",
    "gf",
    "gg",
    "co.gg",
    "net.gg",
    "org.gg",
    "gh",
    "com.gh",
    "edu.gh",
    "gov.gh",
    "org.gh",
    "mil.gh",
    "gi",
    "com.gi",
    "ltd.gi",
    "gov.gi",
    "mod.gi",
    "edu.gi",
    "org.gi",
    "gl",
    "co.gl",
    "com.gl",
    "edu.gl",
    "net.gl",
    "org.gl",
    "gm",
    "gn",
    "ac.gn",
    "com.gn",
    "edu.gn",
    "gov.gn",
    "org.gn",
    "net.gn",
    "gov",
    "gp",
    "com.gp",
    "net.gp",
    "mobi.gp",
    "edu.gp",
    "org.gp",
    "asso.gp",
    "gq",
    "gr",
    "com.gr",
    "edu.gr",
    "net.gr",
    "org.gr",
    "gov.gr",
    "gs",
    "gt",
    "com.gt",
    "edu.gt",
    "gob.gt",
    "ind.gt",
    "mil.gt",
    "net.gt",
    "org.gt",
    "gu",
    "com.gu",
    "edu.gu",
    "gov.gu",
    "guam.gu",
    "info.gu",
    "net.gu",
    "org.gu",
    "web.gu",
    "gw",
    "gy",
    "co.gy",
    "com.gy",
    "edu.gy",
    "gov.gy",
    "net.gy",
    "org.gy",
    "hk",
    "com.hk",
    "edu.hk",
    "gov.hk",
    "idv.hk",
    "net.hk",
    "org.hk",
    "\u516C\u53F8.hk",
    "\u6559\u80B2.hk",
    "\u654E\u80B2.hk",
    "\u653F\u5E9C.hk",
    "\u500B\u4EBA.hk",
    "\u4E2A\u4EBA.hk",
    "\u7B87\u4EBA.hk",
    "\u7DB2\u7EDC.hk",
    "\u7F51\u7EDC.hk",
    "\u7EC4\u7E54.hk",
    "\u7DB2\u7D61.hk",
    "\u7F51\u7D61.hk",
    "\u7EC4\u7EC7.hk",
    "\u7D44\u7E54.hk",
    "\u7D44\u7EC7.hk",
    "hm",
    "hn",
    "com.hn",
    "edu.hn",
    "org.hn",
    "net.hn",
    "mil.hn",
    "gob.hn",
    "hr",
    "iz.hr",
    "from.hr",
    "name.hr",
    "com.hr",
    "ht",
    "com.ht",
    "shop.ht",
    "firm.ht",
    "info.ht",
    "adult.ht",
    "net.ht",
    "pro.ht",
    "org.ht",
    "med.ht",
    "art.ht",
    "coop.ht",
    "pol.ht",
    "asso.ht",
    "edu.ht",
    "rel.ht",
    "gouv.ht",
    "perso.ht",
    "hu",
    "co.hu",
    "info.hu",
    "org.hu",
    "priv.hu",
    "sport.hu",
    "tm.hu",
    "2000.hu",
    "agrar.hu",
    "bolt.hu",
    "casino.hu",
    "city.hu",
    "erotica.hu",
    "erotika.hu",
    "film.hu",
    "forum.hu",
    "games.hu",
    "hotel.hu",
    "ingatlan.hu",
    "jogasz.hu",
    "konyvelo.hu",
    "lakas.hu",
    "media.hu",
    "news.hu",
    "reklam.hu",
    "sex.hu",
    "shop.hu",
    "suli.hu",
    "szex.hu",
    "tozsde.hu",
    "utazas.hu",
    "video.hu",
    "id",
    "ac.id",
    "biz.id",
    "co.id",
    "desa.id",
    "go.id",
    "mil.id",
    "my.id",
    "net.id",
    "or.id",
    "ponpes.id",
    "sch.id",
    "web.id",
    "ie",
    "gov.ie",
    "il",
    "ac.il",
    "co.il",
    "gov.il",
    "idf.il",
    "k12.il",
    "muni.il",
    "net.il",
    "org.il",
    "im",
    "ac.im",
    "co.im",
    "com.im",
    "ltd.co.im",
    "net.im",
    "org.im",
    "plc.co.im",
    "tt.im",
    "tv.im",
    "in",
    "co.in",
    "firm.in",
    "net.in",
    "org.in",
    "gen.in",
    "ind.in",
    "nic.in",
    "ac.in",
    "edu.in",
    "res.in",
    "gov.in",
    "mil.in",
    "info",
    "int",
    "eu.int",
    "io",
    "com.io",
    "iq",
    "gov.iq",
    "edu.iq",
    "mil.iq",
    "com.iq",
    "org.iq",
    "net.iq",
    "ir",
    "ac.ir",
    "co.ir",
    "gov.ir",
    "id.ir",
    "net.ir",
    "org.ir",
    "sch.ir",
    "\u0627\u06CC\u0631\u0627\u0646.ir",
    "\u0627\u064A\u0631\u0627\u0646.ir",
    "is",
    "net.is",
    "com.is",
    "edu.is",
    "gov.is",
    "org.is",
    "int.is",
    "it",
    "gov.it",
    "edu.it",
    "abr.it",
    "abruzzo.it",
    "aosta-valley.it",
    "aostavalley.it",
    "bas.it",
    "basilicata.it",
    "cal.it",
    "calabria.it",
    "cam.it",
    "campania.it",
    "emilia-romagna.it",
    "emiliaromagna.it",
    "emr.it",
    "friuli-v-giulia.it",
    "friuli-ve-giulia.it",
    "friuli-vegiulia.it",
    "friuli-venezia-giulia.it",
    "friuli-veneziagiulia.it",
    "friuli-vgiulia.it",
    "friuliv-giulia.it",
    "friulive-giulia.it",
    "friulivegiulia.it",
    "friulivenezia-giulia.it",
    "friuliveneziagiulia.it",
    "friulivgiulia.it",
    "fvg.it",
    "laz.it",
    "lazio.it",
    "lig.it",
    "liguria.it",
    "lom.it",
    "lombardia.it",
    "lombardy.it",
    "lucania.it",
    "mar.it",
    "marche.it",
    "mol.it",
    "molise.it",
    "piedmont.it",
    "piemonte.it",
    "pmn.it",
    "pug.it",
    "puglia.it",
    "sar.it",
    "sardegna.it",
    "sardinia.it",
    "sic.it",
    "sicilia.it",
    "sicily.it",
    "taa.it",
    "tos.it",
    "toscana.it",
    "trentin-sud-tirol.it",
    "trentin-s\xFCd-tirol.it",
    "trentin-sudtirol.it",
    "trentin-s\xFCdtirol.it",
    "trentin-sued-tirol.it",
    "trentin-suedtirol.it",
    "trentino-a-adige.it",
    "trentino-aadige.it",
    "trentino-alto-adige.it",
    "trentino-altoadige.it",
    "trentino-s-tirol.it",
    "trentino-stirol.it",
    "trentino-sud-tirol.it",
    "trentino-s\xFCd-tirol.it",
    "trentino-sudtirol.it",
    "trentino-s\xFCdtirol.it",
    "trentino-sued-tirol.it",
    "trentino-suedtirol.it",
    "trentino.it",
    "trentinoa-adige.it",
    "trentinoaadige.it",
    "trentinoalto-adige.it",
    "trentinoaltoadige.it",
    "trentinos-tirol.it",
    "trentinostirol.it",
    "trentinosud-tirol.it",
    "trentinos\xFCd-tirol.it",
    "trentinosudtirol.it",
    "trentinos\xFCdtirol.it",
    "trentinosued-tirol.it",
    "trentinosuedtirol.it",
    "trentinsud-tirol.it",
    "trentins\xFCd-tirol.it",
    "trentinsudtirol.it",
    "trentins\xFCdtirol.it",
    "trentinsued-tirol.it",
    "trentinsuedtirol.it",
    "tuscany.it",
    "umb.it",
    "umbria.it",
    "val-d-aosta.it",
    "val-daosta.it",
    "vald-aosta.it",
    "valdaosta.it",
    "valle-aosta.it",
    "valle-d-aosta.it",
    "valle-daosta.it",
    "valleaosta.it",
    "valled-aosta.it",
    "valledaosta.it",
    "vallee-aoste.it",
    "vall\xE9e-aoste.it",
    "vallee-d-aoste.it",
    "vall\xE9e-d-aoste.it",
    "valleeaoste.it",
    "vall\xE9eaoste.it",
    "valleedaoste.it",
    "vall\xE9edaoste.it",
    "vao.it",
    "vda.it",
    "ven.it",
    "veneto.it",
    "ag.it",
    "agrigento.it",
    "al.it",
    "alessandria.it",
    "alto-adige.it",
    "altoadige.it",
    "an.it",
    "ancona.it",
    "andria-barletta-trani.it",
    "andria-trani-barletta.it",
    "andriabarlettatrani.it",
    "andriatranibarletta.it",
    "ao.it",
    "aosta.it",
    "aoste.it",
    "ap.it",
    "aq.it",
    "aquila.it",
    "ar.it",
    "arezzo.it",
    "ascoli-piceno.it",
    "ascolipiceno.it",
    "asti.it",
    "at.it",
    "av.it",
    "avellino.it",
    "ba.it",
    "balsan-sudtirol.it",
    "balsan-s\xFCdtirol.it",
    "balsan-suedtirol.it",
    "balsan.it",
    "bari.it",
    "barletta-trani-andria.it",
    "barlettatraniandria.it",
    "belluno.it",
    "benevento.it",
    "bergamo.it",
    "bg.it",
    "bi.it",
    "biella.it",
    "bl.it",
    "bn.it",
    "bo.it",
    "bologna.it",
    "bolzano-altoadige.it",
    "bolzano.it",
    "bozen-sudtirol.it",
    "bozen-s\xFCdtirol.it",
    "bozen-suedtirol.it",
    "bozen.it",
    "br.it",
    "brescia.it",
    "brindisi.it",
    "bs.it",
    "bt.it",
    "bulsan-sudtirol.it",
    "bulsan-s\xFCdtirol.it",
    "bulsan-suedtirol.it",
    "bulsan.it",
    "bz.it",
    "ca.it",
    "cagliari.it",
    "caltanissetta.it",
    "campidano-medio.it",
    "campidanomedio.it",
    "campobasso.it",
    "carbonia-iglesias.it",
    "carboniaiglesias.it",
    "carrara-massa.it",
    "carraramassa.it",
    "caserta.it",
    "catania.it",
    "catanzaro.it",
    "cb.it",
    "ce.it",
    "cesena-forli.it",
    "cesena-forl\xEC.it",
    "cesenaforli.it",
    "cesenaforl\xEC.it",
    "ch.it",
    "chieti.it",
    "ci.it",
    "cl.it",
    "cn.it",
    "co.it",
    "como.it",
    "cosenza.it",
    "cr.it",
    "cremona.it",
    "crotone.it",
    "cs.it",
    "ct.it",
    "cuneo.it",
    "cz.it",
    "dell-ogliastra.it",
    "dellogliastra.it",
    "en.it",
    "enna.it",
    "fc.it",
    "fe.it",
    "fermo.it",
    "ferrara.it",
    "fg.it",
    "fi.it",
    "firenze.it",
    "florence.it",
    "fm.it",
    "foggia.it",
    "forli-cesena.it",
    "forl\xEC-cesena.it",
    "forlicesena.it",
    "forl\xECcesena.it",
    "fr.it",
    "frosinone.it",
    "ge.it",
    "genoa.it",
    "genova.it",
    "go.it",
    "gorizia.it",
    "gr.it",
    "grosseto.it",
    "iglesias-carbonia.it",
    "iglesiascarbonia.it",
    "im.it",
    "imperia.it",
    "is.it",
    "isernia.it",
    "kr.it",
    "la-spezia.it",
    "laquila.it",
    "laspezia.it",
    "latina.it",
    "lc.it",
    "le.it",
    "lecce.it",
    "lecco.it",
    "li.it",
    "livorno.it",
    "lo.it",
    "lodi.it",
    "lt.it",
    "lu.it",
    "lucca.it",
    "macerata.it",
    "mantova.it",
    "massa-carrara.it",
    "massacarrara.it",
    "matera.it",
    "mb.it",
    "mc.it",
    "me.it",
    "medio-campidano.it",
    "mediocampidano.it",
    "messina.it",
    "mi.it",
    "milan.it",
    "milano.it",
    "mn.it",
    "mo.it",
    "modena.it",
    "monza-brianza.it",
    "monza-e-della-brianza.it",
    "monza.it",
    "monzabrianza.it",
    "monzaebrianza.it",
    "monzaedellabrianza.it",
    "ms.it",
    "mt.it",
    "na.it",
    "naples.it",
    "napoli.it",
    "no.it",
    "novara.it",
    "nu.it",
    "nuoro.it",
    "og.it",
    "ogliastra.it",
    "olbia-tempio.it",
    "olbiatempio.it",
    "or.it",
    "oristano.it",
    "ot.it",
    "pa.it",
    "padova.it",
    "padua.it",
    "palermo.it",
    "parma.it",
    "pavia.it",
    "pc.it",
    "pd.it",
    "pe.it",
    "perugia.it",
    "pesaro-urbino.it",
    "pesarourbino.it",
    "pescara.it",
    "pg.it",
    "pi.it",
    "piacenza.it",
    "pisa.it",
    "pistoia.it",
    "pn.it",
    "po.it",
    "pordenone.it",
    "potenza.it",
    "pr.it",
    "prato.it",
    "pt.it",
    "pu.it",
    "pv.it",
    "pz.it",
    "ra.it",
    "ragusa.it",
    "ravenna.it",
    "rc.it",
    "re.it",
    "reggio-calabria.it",
    "reggio-emilia.it",
    "reggiocalabria.it",
    "reggioemilia.it",
    "rg.it",
    "ri.it",
    "rieti.it",
    "rimini.it",
    "rm.it",
    "rn.it",
    "ro.it",
    "roma.it",
    "rome.it",
    "rovigo.it",
    "sa.it",
    "salerno.it",
    "sassari.it",
    "savona.it",
    "si.it",
    "siena.it",
    "siracusa.it",
    "so.it",
    "sondrio.it",
    "sp.it",
    "sr.it",
    "ss.it",
    "suedtirol.it",
    "s\xFCdtirol.it",
    "sv.it",
    "ta.it",
    "taranto.it",
    "te.it",
    "tempio-olbia.it",
    "tempioolbia.it",
    "teramo.it",
    "terni.it",
    "tn.it",
    "to.it",
    "torino.it",
    "tp.it",
    "tr.it",
    "trani-andria-barletta.it",
    "trani-barletta-andria.it",
    "traniandriabarletta.it",
    "tranibarlettaandria.it",
    "trapani.it",
    "trento.it",
    "treviso.it",
    "trieste.it",
    "ts.it",
    "turin.it",
    "tv.it",
    "ud.it",
    "udine.it",
    "urbino-pesaro.it",
    "urbinopesaro.it",
    "va.it",
    "varese.it",
    "vb.it",
    "vc.it",
    "ve.it",
    "venezia.it",
    "venice.it",
    "verbania.it",
    "vercelli.it",
    "verona.it",
    "vi.it",
    "vibo-valentia.it",
    "vibovalentia.it",
    "vicenza.it",
    "viterbo.it",
    "vr.it",
    "vs.it",
    "vt.it",
    "vv.it",
    "je",
    "co.je",
    "net.je",
    "org.je",
    "*.jm",
    "jo",
    "com.jo",
    "org.jo",
    "net.jo",
    "edu.jo",
    "sch.jo",
    "gov.jo",
    "mil.jo",
    "name.jo",
    "jobs",
    "jp",
    "ac.jp",
    "ad.jp",
    "co.jp",
    "ed.jp",
    "go.jp",
    "gr.jp",
    "lg.jp",
    "ne.jp",
    "or.jp",
    "aichi.jp",
    "akita.jp",
    "aomori.jp",
    "chiba.jp",
    "ehime.jp",
    "fukui.jp",
    "fukuoka.jp",
    "fukushima.jp",
    "gifu.jp",
    "gunma.jp",
    "hiroshima.jp",
    "hokkaido.jp",
    "hyogo.jp",
    "ibaraki.jp",
    "ishikawa.jp",
    "iwate.jp",
    "kagawa.jp",
    "kagoshima.jp",
    "kanagawa.jp",
    "kochi.jp",
    "kumamoto.jp",
    "kyoto.jp",
    "mie.jp",
    "miyagi.jp",
    "miyazaki.jp",
    "nagano.jp",
    "nagasaki.jp",
    "nara.jp",
    "niigata.jp",
    "oita.jp",
    "okayama.jp",
    "okinawa.jp",
    "osaka.jp",
    "saga.jp",
    "saitama.jp",
    "shiga.jp",
    "shimane.jp",
    "shizuoka.jp",
    "tochigi.jp",
    "tokushima.jp",
    "tokyo.jp",
    "tottori.jp",
    "toyama.jp",
    "wakayama.jp",
    "yamagata.jp",
    "yamaguchi.jp",
    "yamanashi.jp",
    "\u6803\u6728.jp",
    "\u611B\u77E5.jp",
    "\u611B\u5A9B.jp",
    "\u5175\u5EAB.jp",
    "\u718A\u672C.jp",
    "\u8328\u57CE.jp",
    "\u5317\u6D77\u9053.jp",
    "\u5343\u8449.jp",
    "\u548C\u6B4C\u5C71.jp",
    "\u9577\u5D0E.jp",
    "\u9577\u91CE.jp",
    "\u65B0\u6F5F.jp",
    "\u9752\u68EE.jp",
    "\u9759\u5CA1.jp",
    "\u6771\u4EAC.jp",
    "\u77F3\u5DDD.jp",
    "\u57FC\u7389.jp",
    "\u4E09\u91CD.jp",
    "\u4EAC\u90FD.jp",
    "\u4F50\u8CC0.jp",
    "\u5927\u5206.jp",
    "\u5927\u962A.jp",
    "\u5948\u826F.jp",
    "\u5BAE\u57CE.jp",
    "\u5BAE\u5D0E.jp",
    "\u5BCC\u5C71.jp",
    "\u5C71\u53E3.jp",
    "\u5C71\u5F62.jp",
    "\u5C71\u68A8.jp",
    "\u5CA9\u624B.jp",
    "\u5C90\u961C.jp",
    "\u5CA1\u5C71.jp",
    "\u5CF6\u6839.jp",
    "\u5E83\u5CF6.jp",
    "\u5FB3\u5CF6.jp",
    "\u6C96\u7E04.jp",
    "\u6ECB\u8CC0.jp",
    "\u795E\u5948\u5DDD.jp",
    "\u798F\u4E95.jp",
    "\u798F\u5CA1.jp",
    "\u798F\u5CF6.jp",
    "\u79CB\u7530.jp",
    "\u7FA4\u99AC.jp",
    "\u9999\u5DDD.jp",
    "\u9AD8\u77E5.jp",
    "\u9CE5\u53D6.jp",
    "\u9E7F\u5150\u5CF6.jp",
    "*.kawasaki.jp",
    "*.kitakyushu.jp",
    "*.kobe.jp",
    "*.nagoya.jp",
    "*.sapporo.jp",
    "*.sendai.jp",
    "*.yokohama.jp",
    "!city.kawasaki.jp",
    "!city.kitakyushu.jp",
    "!city.kobe.jp",
    "!city.nagoya.jp",
    "!city.sapporo.jp",
    "!city.sendai.jp",
    "!city.yokohama.jp",
    "aisai.aichi.jp",
    "ama.aichi.jp",
    "anjo.aichi.jp",
    "asuke.aichi.jp",
    "chiryu.aichi.jp",
    "chita.aichi.jp",
    "fuso.aichi.jp",
    "gamagori.aichi.jp",
    "handa.aichi.jp",
    "hazu.aichi.jp",
    "hekinan.aichi.jp",
    "higashiura.aichi.jp",
    "ichinomiya.aichi.jp",
    "inazawa.aichi.jp",
    "inuyama.aichi.jp",
    "isshiki.aichi.jp",
    "iwakura.aichi.jp",
    "kanie.aichi.jp",
    "kariya.aichi.jp",
    "kasugai.aichi.jp",
    "kira.aichi.jp",
    "kiyosu.aichi.jp",
    "komaki.aichi.jp",
    "konan.aichi.jp",
    "kota.aichi.jp",
    "mihama.aichi.jp",
    "miyoshi.aichi.jp",
    "nishio.aichi.jp",
    "nisshin.aichi.jp",
    "obu.aichi.jp",
    "oguchi.aichi.jp",
    "oharu.aichi.jp",
    "okazaki.aichi.jp",
    "owariasahi.aichi.jp",
    "seto.aichi.jp",
    "shikatsu.aichi.jp",
    "shinshiro.aichi.jp",
    "shitara.aichi.jp",
    "tahara.aichi.jp",
    "takahama.aichi.jp",
    "tobishima.aichi.jp",
    "toei.aichi.jp",
    "togo.aichi.jp",
    "tokai.aichi.jp",
    "tokoname.aichi.jp",
    "toyoake.aichi.jp",
    "toyohashi.aichi.jp",
    "toyokawa.aichi.jp",
    "toyone.aichi.jp",
    "toyota.aichi.jp",
    "tsushima.aichi.jp",
    "yatomi.aichi.jp",
    "akita.akita.jp",
    "daisen.akita.jp",
    "fujisato.akita.jp",
    "gojome.akita.jp",
    "hachirogata.akita.jp",
    "happou.akita.jp",
    "higashinaruse.akita.jp",
    "honjo.akita.jp",
    "honjyo.akita.jp",
    "ikawa.akita.jp",
    "kamikoani.akita.jp",
    "kamioka.akita.jp",
    "katagami.akita.jp",
    "kazuno.akita.jp",
    "kitaakita.akita.jp",
    "kosaka.akita.jp",
    "kyowa.akita.jp",
    "misato.akita.jp",
    "mitane.akita.jp",
    "moriyoshi.akita.jp",
    "nikaho.akita.jp",
    "noshiro.akita.jp",
    "odate.akita.jp",
    "oga.akita.jp",
    "ogata.akita.jp",
    "semboku.akita.jp",
    "yokote.akita.jp",
    "yurihonjo.akita.jp",
    "aomori.aomori.jp",
    "gonohe.aomori.jp",
    "hachinohe.aomori.jp",
    "hashikami.aomori.jp",
    "hiranai.aomori.jp",
    "hirosaki.aomori.jp",
    "itayanagi.aomori.jp",
    "kuroishi.aomori.jp",
    "misawa.aomori.jp",
    "mutsu.aomori.jp",
    "nakadomari.aomori.jp",
    "noheji.aomori.jp",
    "oirase.aomori.jp",
    "owani.aomori.jp",
    "rokunohe.aomori.jp",
    "sannohe.aomori.jp",
    "shichinohe.aomori.jp",
    "shingo.aomori.jp",
    "takko.aomori.jp",
    "towada.aomori.jp",
    "tsugaru.aomori.jp",
    "tsuruta.aomori.jp",
    "abiko.chiba.jp",
    "asahi.chiba.jp",
    "chonan.chiba.jp",
    "chosei.chiba.jp",
    "choshi.chiba.jp",
    "chuo.chiba.jp",
    "funabashi.chiba.jp",
    "futtsu.chiba.jp",
    "hanamigawa.chiba.jp",
    "ichihara.chiba.jp",
    "ichikawa.chiba.jp",
    "ichinomiya.chiba.jp",
    "inzai.chiba.jp",
    "isumi.chiba.jp",
    "kamagaya.chiba.jp",
    "kamogawa.chiba.jp",
    "kashiwa.chiba.jp",
    "katori.chiba.jp",
    "katsuura.chiba.jp",
    "kimitsu.chiba.jp",
    "kisarazu.chiba.jp",
    "kozaki.chiba.jp",
    "kujukuri.chiba.jp",
    "kyonan.chiba.jp",
    "matsudo.chiba.jp",
    "midori.chiba.jp",
    "mihama.chiba.jp",
    "minamiboso.chiba.jp",
    "mobara.chiba.jp",
    "mutsuzawa.chiba.jp",
    "nagara.chiba.jp",
    "nagareyama.chiba.jp",
    "narashino.chiba.jp",
    "narita.chiba.jp",
    "noda.chiba.jp",
    "oamishirasato.chiba.jp",
    "omigawa.chiba.jp",
    "onjuku.chiba.jp",
    "otaki.chiba.jp",
    "sakae.chiba.jp",
    "sakura.chiba.jp",
    "shimofusa.chiba.jp",
    "shirako.chiba.jp",
    "shiroi.chiba.jp",
    "shisui.chiba.jp",
    "sodegaura.chiba.jp",
    "sosa.chiba.jp",
    "tako.chiba.jp",
    "tateyama.chiba.jp",
    "togane.chiba.jp",
    "tohnosho.chiba.jp",
    "tomisato.chiba.jp",
    "urayasu.chiba.jp",
    "yachimata.chiba.jp",
    "yachiyo.chiba.jp",
    "yokaichiba.chiba.jp",
    "yokoshibahikari.chiba.jp",
    "yotsukaido.chiba.jp",
    "ainan.ehime.jp",
    "honai.ehime.jp",
    "ikata.ehime.jp",
    "imabari.ehime.jp",
    "iyo.ehime.jp",
    "kamijima.ehime.jp",
    "kihoku.ehime.jp",
    "kumakogen.ehime.jp",
    "masaki.ehime.jp",
    "matsuno.ehime.jp",
    "matsuyama.ehime.jp",
    "namikata.ehime.jp",
    "niihama.ehime.jp",
    "ozu.ehime.jp",
    "saijo.ehime.jp",
    "seiyo.ehime.jp",
    "shikokuchuo.ehime.jp",
    "tobe.ehime.jp",
    "toon.ehime.jp",
    "uchiko.ehime.jp",
    "uwajima.ehime.jp",
    "yawatahama.ehime.jp",
    "echizen.fukui.jp",
    "eiheiji.fukui.jp",
    "fukui.fukui.jp",
    "ikeda.fukui.jp",
    "katsuyama.fukui.jp",
    "mihama.fukui.jp",
    "minamiechizen.fukui.jp",
    "obama.fukui.jp",
    "ohi.fukui.jp",
    "ono.fukui.jp",
    "sabae.fukui.jp",
    "sakai.fukui.jp",
    "takahama.fukui.jp",
    "tsuruga.fukui.jp",
    "wakasa.fukui.jp",
    "ashiya.fukuoka.jp",
    "buzen.fukuoka.jp",
    "chikugo.fukuoka.jp",
    "chikuho.fukuoka.jp",
    "chikujo.fukuoka.jp",
    "chikushino.fukuoka.jp",
    "chikuzen.fukuoka.jp",
    "chuo.fukuoka.jp",
    "dazaifu.fukuoka.jp",
    "fukuchi.fukuoka.jp",
    "hakata.fukuoka.jp",
    "higashi.fukuoka.jp",
    "hirokawa.fukuoka.jp",
    "hisayama.fukuoka.jp",
    "iizuka.fukuoka.jp",
    "inatsuki.fukuoka.jp",
    "kaho.fukuoka.jp",
    "kasuga.fukuoka.jp",
    "kasuya.fukuoka.jp",
    "kawara.fukuoka.jp",
    "keisen.fukuoka.jp",
    "koga.fukuoka.jp",
    "kurate.fukuoka.jp",
    "kurogi.fukuoka.jp",
    "kurume.fukuoka.jp",
    "minami.fukuoka.jp",
    "miyako.fukuoka.jp",
    "miyama.fukuoka.jp",
    "miyawaka.fukuoka.jp",
    "mizumaki.fukuoka.jp",
    "munakata.fukuoka.jp",
    "nakagawa.fukuoka.jp",
    "nakama.fukuoka.jp",
    "nishi.fukuoka.jp",
    "nogata.fukuoka.jp",
    "ogori.fukuoka.jp",
    "okagaki.fukuoka.jp",
    "okawa.fukuoka.jp",
    "oki.fukuoka.jp",
    "omuta.fukuoka.jp",
    "onga.fukuoka.jp",
    "onojo.fukuoka.jp",
    "oto.fukuoka.jp",
    "saigawa.fukuoka.jp",
    "sasaguri.fukuoka.jp",
    "shingu.fukuoka.jp",
    "shinyoshitomi.fukuoka.jp",
    "shonai.fukuoka.jp",
    "soeda.fukuoka.jp",
    "sue.fukuoka.jp",
    "tachiarai.fukuoka.jp",
    "tagawa.fukuoka.jp",
    "takata.fukuoka.jp",
    "toho.fukuoka.jp",
    "toyotsu.fukuoka.jp",
    "tsuiki.fukuoka.jp",
    "ukiha.fukuoka.jp",
    "umi.fukuoka.jp",
    "usui.fukuoka.jp",
    "yamada.fukuoka.jp",
    "yame.fukuoka.jp",
    "yanagawa.fukuoka.jp",
    "yukuhashi.fukuoka.jp",
    "aizubange.fukushima.jp",
    "aizumisato.fukushima.jp",
    "aizuwakamatsu.fukushima.jp",
    "asakawa.fukushima.jp",
    "bandai.fukushima.jp",
    "date.fukushima.jp",
    "fukushima.fukushima.jp",
    "furudono.fukushima.jp",
    "futaba.fukushima.jp",
    "hanawa.fukushima.jp",
    "higashi.fukushima.jp",
    "hirata.fukushima.jp",
    "hirono.fukushima.jp",
    "iitate.fukushima.jp",
    "inawashiro.fukushima.jp",
    "ishikawa.fukushima.jp",
    "iwaki.fukushima.jp",
    "izumizaki.fukushima.jp",
    "kagamiishi.fukushima.jp",
    "kaneyama.fukushima.jp",
    "kawamata.fukushima.jp",
    "kitakata.fukushima.jp",
    "kitashiobara.fukushima.jp",
    "koori.fukushima.jp",
    "koriyama.fukushima.jp",
    "kunimi.fukushima.jp",
    "miharu.fukushima.jp",
    "mishima.fukushima.jp",
    "namie.fukushima.jp",
    "nango.fukushima.jp",
    "nishiaizu.fukushima.jp",
    "nishigo.fukushima.jp",
    "okuma.fukushima.jp",
    "omotego.fukushima.jp",
    "ono.fukushima.jp",
    "otama.fukushima.jp",
    "samegawa.fukushima.jp",
    "shimogo.fukushima.jp",
    "shirakawa.fukushima.jp",
    "showa.fukushima.jp",
    "soma.fukushima.jp",
    "sukagawa.fukushima.jp",
    "taishin.fukushima.jp",
    "tamakawa.fukushima.jp",
    "tanagura.fukushima.jp",
    "tenei.fukushima.jp",
    "yabuki.fukushima.jp",
    "yamato.fukushima.jp",
    "yamatsuri.fukushima.jp",
    "yanaizu.fukushima.jp",
    "yugawa.fukushima.jp",
    "anpachi.gifu.jp",
    "ena.gifu.jp",
    "gifu.gifu.jp",
    "ginan.gifu.jp",
    "godo.gifu.jp",
    "gujo.gifu.jp",
    "hashima.gifu.jp",
    "hichiso.gifu.jp",
    "hida.gifu.jp",
    "higashishirakawa.gifu.jp",
    "ibigawa.gifu.jp",
    "ikeda.gifu.jp",
    "kakamigahara.gifu.jp",
    "kani.gifu.jp",
    "kasahara.gifu.jp",
    "kasamatsu.gifu.jp",
    "kawaue.gifu.jp",
    "kitagata.gifu.jp",
    "mino.gifu.jp",
    "minokamo.gifu.jp",
    "mitake.gifu.jp",
    "mizunami.gifu.jp",
    "motosu.gifu.jp",
    "nakatsugawa.gifu.jp",
    "ogaki.gifu.jp",
    "sakahogi.gifu.jp",
    "seki.gifu.jp",
    "sekigahara.gifu.jp",
    "shirakawa.gifu.jp",
    "tajimi.gifu.jp",
    "takayama.gifu.jp",
    "tarui.gifu.jp",
    "toki.gifu.jp",
    "tomika.gifu.jp",
    "wanouchi.gifu.jp",
    "yamagata.gifu.jp",
    "yaotsu.gifu.jp",
    "yoro.gifu.jp",
    "annaka.gunma.jp",
    "chiyoda.gunma.jp",
    "fujioka.gunma.jp",
    "higashiagatsuma.gunma.jp",
    "isesaki.gunma.jp",
    "itakura.gunma.jp",
    "kanna.gunma.jp",
    "kanra.gunma.jp",
    "katashina.gunma.jp",
    "kawaba.gunma.jp",
    "kiryu.gunma.jp",
    "kusatsu.gunma.jp",
    "maebashi.gunma.jp",
    "meiwa.gunma.jp",
    "midori.gunma.jp",
    "minakami.gunma.jp",
    "naganohara.gunma.jp",
    "nakanojo.gunma.jp",
    "nanmoku.gunma.jp",
    "numata.gunma.jp",
    "oizumi.gunma.jp",
    "ora.gunma.jp",
    "ota.gunma.jp",
    "shibukawa.gunma.jp",
    "shimonita.gunma.jp",
    "shinto.gunma.jp",
    "showa.gunma.jp",
    "takasaki.gunma.jp",
    "takayama.gunma.jp",
    "tamamura.gunma.jp",
    "tatebayashi.gunma.jp",
    "tomioka.gunma.jp",
    "tsukiyono.gunma.jp",
    "tsumagoi.gunma.jp",
    "ueno.gunma.jp",
    "yoshioka.gunma.jp",
    "asaminami.hiroshima.jp",
    "daiwa.hiroshima.jp",
    "etajima.hiroshima.jp",
    "fuchu.hiroshima.jp",
    "fukuyama.hiroshima.jp",
    "hatsukaichi.hiroshima.jp",
    "higashihiroshima.hiroshima.jp",
    "hongo.hiroshima.jp",
    "jinsekikogen.hiroshima.jp",
    "kaita.hiroshima.jp",
    "kui.hiroshima.jp",
    "kumano.hiroshima.jp",
    "kure.hiroshima.jp",
    "mihara.hiroshima.jp",
    "miyoshi.hiroshima.jp",
    "naka.hiroshima.jp",
    "onomichi.hiroshima.jp",
    "osakikamijima.hiroshima.jp",
    "otake.hiroshima.jp",
    "saka.hiroshima.jp",
    "sera.hiroshima.jp",
    "seranishi.hiroshima.jp",
    "shinichi.hiroshima.jp",
    "shobara.hiroshima.jp",
    "takehara.hiroshima.jp",
    "abashiri.hokkaido.jp",
    "abira.hokkaido.jp",
    "aibetsu.hokkaido.jp",
    "akabira.hokkaido.jp",
    "akkeshi.hokkaido.jp",
    "asahikawa.hokkaido.jp",
    "ashibetsu.hokkaido.jp",
    "ashoro.hokkaido.jp",
    "assabu.hokkaido.jp",
    "atsuma.hokkaido.jp",
    "bibai.hokkaido.jp",
    "biei.hokkaido.jp",
    "bifuka.hokkaido.jp",
    "bihoro.hokkaido.jp",
    "biratori.hokkaido.jp",
    "chippubetsu.hokkaido.jp",
    "chitose.hokkaido.jp",
    "date.hokkaido.jp",
    "ebetsu.hokkaido.jp",
    "embetsu.hokkaido.jp",
    "eniwa.hokkaido.jp",
    "erimo.hokkaido.jp",
    "esan.hokkaido.jp",
    "esashi.hokkaido.jp",
    "fukagawa.hokkaido.jp",
    "fukushima.hokkaido.jp",
    "furano.hokkaido.jp",
    "furubira.hokkaido.jp",
    "haboro.hokkaido.jp",
    "hakodate.hokkaido.jp",
    "hamatonbetsu.hokkaido.jp",
    "hidaka.hokkaido.jp",
    "higashikagura.hokkaido.jp",
    "higashikawa.hokkaido.jp",
    "hiroo.hokkaido.jp",
    "hokuryu.hokkaido.jp",
    "hokuto.hokkaido.jp",
    "honbetsu.hokkaido.jp",
    "horokanai.hokkaido.jp",
    "horonobe.hokkaido.jp",
    "ikeda.hokkaido.jp",
    "imakane.hokkaido.jp",
    "ishikari.hokkaido.jp",
    "iwamizawa.hokkaido.jp",
    "iwanai.hokkaido.jp",
    "kamifurano.hokkaido.jp",
    "kamikawa.hokkaido.jp",
    "kamishihoro.hokkaido.jp",
    "kamisunagawa.hokkaido.jp",
    "kamoenai.hokkaido.jp",
    "kayabe.hokkaido.jp",
    "kembuchi.hokkaido.jp",
    "kikonai.hokkaido.jp",
    "kimobetsu.hokkaido.jp",
    "kitahiroshima.hokkaido.jp",
    "kitami.hokkaido.jp",
    "kiyosato.hokkaido.jp",
    "koshimizu.hokkaido.jp",
    "kunneppu.hokkaido.jp",
    "kuriyama.hokkaido.jp",
    "kuromatsunai.hokkaido.jp",
    "kushiro.hokkaido.jp",
    "kutchan.hokkaido.jp",
    "kyowa.hokkaido.jp",
    "mashike.hokkaido.jp",
    "matsumae.hokkaido.jp",
    "mikasa.hokkaido.jp",
    "minamifurano.hokkaido.jp",
    "mombetsu.hokkaido.jp",
    "moseushi.hokkaido.jp",
    "mukawa.hokkaido.jp",
    "muroran.hokkaido.jp",
    "naie.hokkaido.jp",
    "nakagawa.hokkaido.jp",
    "nakasatsunai.hokkaido.jp",
    "nakatombetsu.hokkaido.jp",
    "nanae.hokkaido.jp",
    "nanporo.hokkaido.jp",
    "nayoro.hokkaido.jp",
    "nemuro.hokkaido.jp",
    "niikappu.hokkaido.jp",
    "niki.hokkaido.jp",
    "nishiokoppe.hokkaido.jp",
    "noboribetsu.hokkaido.jp",
    "numata.hokkaido.jp",
    "obihiro.hokkaido.jp",
    "obira.hokkaido.jp",
    "oketo.hokkaido.jp",
    "okoppe.hokkaido.jp",
    "otaru.hokkaido.jp",
    "otobe.hokkaido.jp",
    "otofuke.hokkaido.jp",
    "otoineppu.hokkaido.jp",
    "oumu.hokkaido.jp",
    "ozora.hokkaido.jp",
    "pippu.hokkaido.jp",
    "rankoshi.hokkaido.jp",
    "rebun.hokkaido.jp",
    "rikubetsu.hokkaido.jp",
    "rishiri.hokkaido.jp",
    "rishirifuji.hokkaido.jp",
    "saroma.hokkaido.jp",
    "sarufutsu.hokkaido.jp",
    "shakotan.hokkaido.jp",
    "shari.hokkaido.jp",
    "shibecha.hokkaido.jp",
    "shibetsu.hokkaido.jp",
    "shikabe.hokkaido.jp",
    "shikaoi.hokkaido.jp",
    "shimamaki.hokkaido.jp",
    "shimizu.hokkaido.jp",
    "shimokawa.hokkaido.jp",
    "shinshinotsu.hokkaido.jp",
    "shintoku.hokkaido.jp",
    "shiranuka.hokkaido.jp",
    "shiraoi.hokkaido.jp",
    "shiriuchi.hokkaido.jp",
    "sobetsu.hokkaido.jp",
    "sunagawa.hokkaido.jp",
    "taiki.hokkaido.jp",
    "takasu.hokkaido.jp",
    "takikawa.hokkaido.jp",
    "takinoue.hokkaido.jp",
    "teshikaga.hokkaido.jp",
    "tobetsu.hokkaido.jp",
    "tohma.hokkaido.jp",
    "tomakomai.hokkaido.jp",
    "tomari.hokkaido.jp",
    "toya.hokkaido.jp",
    "toyako.hokkaido.jp",
    "toyotomi.hokkaido.jp",
    "toyoura.hokkaido.jp",
    "tsubetsu.hokkaido.jp",
    "tsukigata.hokkaido.jp",
    "urakawa.hokkaido.jp",
    "urausu.hokkaido.jp",
    "uryu.hokkaido.jp",
    "utashinai.hokkaido.jp",
    "wakkanai.hokkaido.jp",
    "wassamu.hokkaido.jp",
    "yakumo.hokkaido.jp",
    "yoichi.hokkaido.jp",
    "aioi.hyogo.jp",
    "akashi.hyogo.jp",
    "ako.hyogo.jp",
    "amagasaki.hyogo.jp",
    "aogaki.hyogo.jp",
    "asago.hyogo.jp",
    "ashiya.hyogo.jp",
    "awaji.hyogo.jp",
    "fukusaki.hyogo.jp",
    "goshiki.hyogo.jp",
    "harima.hyogo.jp",
    "himeji.hyogo.jp",
    "ichikawa.hyogo.jp",
    "inagawa.hyogo.jp",
    "itami.hyogo.jp",
    "kakogawa.hyogo.jp",
    "kamigori.hyogo.jp",
    "kamikawa.hyogo.jp",
    "kasai.hyogo.jp",
    "kasuga.hyogo.jp",
    "kawanishi.hyogo.jp",
    "miki.hyogo.jp",
    "minamiawaji.hyogo.jp",
    "nishinomiya.hyogo.jp",
    "nishiwaki.hyogo.jp",
    "ono.hyogo.jp",
    "sanda.hyogo.jp",
    "sannan.hyogo.jp",
    "sasayama.hyogo.jp",
    "sayo.hyogo.jp",
    "shingu.hyogo.jp",
    "shinonsen.hyogo.jp",
    "shiso.hyogo.jp",
    "sumoto.hyogo.jp",
    "taishi.hyogo.jp",
    "taka.hyogo.jp",
    "takarazuka.hyogo.jp",
    "takasago.hyogo.jp",
    "takino.hyogo.jp",
    "tamba.hyogo.jp",
    "tatsuno.hyogo.jp",
    "toyooka.hyogo.jp",
    "yabu.hyogo.jp",
    "yashiro.hyogo.jp",
    "yoka.hyogo.jp",
    "yokawa.hyogo.jp",
    "ami.ibaraki.jp",
    "asahi.ibaraki.jp",
    "bando.ibaraki.jp",
    "chikusei.ibaraki.jp",
    "daigo.ibaraki.jp",
    "fujishiro.ibaraki.jp",
    "hitachi.ibaraki.jp",
    "hitachinaka.ibaraki.jp",
    "hitachiomiya.ibaraki.jp",
    "hitachiota.ibaraki.jp",
    "ibaraki.ibaraki.jp",
    "ina.ibaraki.jp",
    "inashiki.ibaraki.jp",
    "itako.ibaraki.jp",
    "iwama.ibaraki.jp",
    "joso.ibaraki.jp",
    "kamisu.ibaraki.jp",
    "kasama.ibaraki.jp",
    "kashima.ibaraki.jp",
    "kasumigaura.ibaraki.jp",
    "koga.ibaraki.jp",
    "miho.ibaraki.jp",
    "mito.ibaraki.jp",
    "moriya.ibaraki.jp",
    "naka.ibaraki.jp",
    "namegata.ibaraki.jp",
    "oarai.ibaraki.jp",
    "ogawa.ibaraki.jp",
    "omitama.ibaraki.jp",
    "ryugasaki.ibaraki.jp",
    "sakai.ibaraki.jp",
    "sakuragawa.ibaraki.jp",
    "shimodate.ibaraki.jp",
    "shimotsuma.ibaraki.jp",
    "shirosato.ibaraki.jp",
    "sowa.ibaraki.jp",
    "suifu.ibaraki.jp",
    "takahagi.ibaraki.jp",
    "tamatsukuri.ibaraki.jp",
    "tokai.ibaraki.jp",
    "tomobe.ibaraki.jp",
    "tone.ibaraki.jp",
    "toride.ibaraki.jp",
    "tsuchiura.ibaraki.jp",
    "tsukuba.ibaraki.jp",
    "uchihara.ibaraki.jp",
    "ushiku.ibaraki.jp",
    "yachiyo.ibaraki.jp",
    "yamagata.ibaraki.jp",
    "yawara.ibaraki.jp",
    "yuki.ibaraki.jp",
    "anamizu.ishikawa.jp",
    "hakui.ishikawa.jp",
    "hakusan.ishikawa.jp",
    "kaga.ishikawa.jp",
    "kahoku.ishikawa.jp",
    "kanazawa.ishikawa.jp",
    "kawakita.ishikawa.jp",
    "komatsu.ishikawa.jp",
    "nakanoto.ishikawa.jp",
    "nanao.ishikawa.jp",
    "nomi.ishikawa.jp",
    "nonoichi.ishikawa.jp",
    "noto.ishikawa.jp",
    "shika.ishikawa.jp",
    "suzu.ishikawa.jp",
    "tsubata.ishikawa.jp",
    "tsurugi.ishikawa.jp",
    "uchinada.ishikawa.jp",
    "wajima.ishikawa.jp",
    "fudai.iwate.jp",
    "fujisawa.iwate.jp",
    "hanamaki.iwate.jp",
    "hiraizumi.iwate.jp",
    "hirono.iwate.jp",
    "ichinohe.iwate.jp",
    "ichinoseki.iwate.jp",
    "iwaizumi.iwate.jp",
    "iwate.iwate.jp",
    "joboji.iwate.jp",
    "kamaishi.iwate.jp",
    "kanegasaki.iwate.jp",
    "karumai.iwate.jp",
    "kawai.iwate.jp",
    "kitakami.iwate.jp",
    "kuji.iwate.jp",
    "kunohe.iwate.jp",
    "kuzumaki.iwate.jp",
    "miyako.iwate.jp",
    "mizusawa.iwate.jp",
    "morioka.iwate.jp",
    "ninohe.iwate.jp",
    "noda.iwate.jp",
    "ofunato.iwate.jp",
    "oshu.iwate.jp",
    "otsuchi.iwate.jp",
    "rikuzentakata.iwate.jp",
    "shiwa.iwate.jp",
    "shizukuishi.iwate.jp",
    "sumita.iwate.jp",
    "tanohata.iwate.jp",
    "tono.iwate.jp",
    "yahaba.iwate.jp",
    "yamada.iwate.jp",
    "ayagawa.kagawa.jp",
    "higashikagawa.kagawa.jp",
    "kanonji.kagawa.jp",
    "kotohira.kagawa.jp",
    "manno.kagawa.jp",
    "marugame.kagawa.jp",
    "mitoyo.kagawa.jp",
    "naoshima.kagawa.jp",
    "sanuki.kagawa.jp",
    "tadotsu.kagawa.jp",
    "takamatsu.kagawa.jp",
    "tonosho.kagawa.jp",
    "uchinomi.kagawa.jp",
    "utazu.kagawa.jp",
    "zentsuji.kagawa.jp",
    "akune.kagoshima.jp",
    "amami.kagoshima.jp",
    "hioki.kagoshima.jp",
    "isa.kagoshima.jp",
    "isen.kagoshima.jp",
    "izumi.kagoshima.jp",
    "kagoshima.kagoshima.jp",
    "kanoya.kagoshima.jp",
    "kawanabe.kagoshima.jp",
    "kinko.kagoshima.jp",
    "kouyama.kagoshima.jp",
    "makurazaki.kagoshima.jp",
    "matsumoto.kagoshima.jp",
    "minamitane.kagoshima.jp",
    "nakatane.kagoshima.jp",
    "nishinoomote.kagoshima.jp",
    "satsumasendai.kagoshima.jp",
    "soo.kagoshima.jp",
    "tarumizu.kagoshima.jp",
    "yusui.kagoshima.jp",
    "aikawa.kanagawa.jp",
    "atsugi.kanagawa.jp",
    "ayase.kanagawa.jp",
    "chigasaki.kanagawa.jp",
    "ebina.kanagawa.jp",
    "fujisawa.kanagawa.jp",
    "hadano.kanagawa.jp",
    "hakone.kanagawa.jp",
    "hiratsuka.kanagawa.jp",
    "isehara.kanagawa.jp",
    "kaisei.kanagawa.jp",
    "kamakura.kanagawa.jp",
    "kiyokawa.kanagawa.jp",
    "matsuda.kanagawa.jp",
    "minamiashigara.kanagawa.jp",
    "miura.kanagawa.jp",
    "nakai.kanagawa.jp",
    "ninomiya.kanagawa.jp",
    "odawara.kanagawa.jp",
    "oi.kanagawa.jp",
    "oiso.kanagawa.jp",
    "sagamihara.kanagawa.jp",
    "samukawa.kanagawa.jp",
    "tsukui.kanagawa.jp",
    "yamakita.kanagawa.jp",
    "yamato.kanagawa.jp",
    "yokosuka.kanagawa.jp",
    "yugawara.kanagawa.jp",
    "zama.kanagawa.jp",
    "zushi.kanagawa.jp",
    "aki.kochi.jp",
    "geisei.kochi.jp",
    "hidaka.kochi.jp",
    "higashitsuno.kochi.jp",
    "ino.kochi.jp",
    "kagami.kochi.jp",
    "kami.kochi.jp",
    "kitagawa.kochi.jp",
    "kochi.kochi.jp",
    "mihara.kochi.jp",
    "motoyama.kochi.jp",
    "muroto.kochi.jp",
    "nahari.kochi.jp",
    "nakamura.kochi.jp",
    "nankoku.kochi.jp",
    "nishitosa.kochi.jp",
    "niyodogawa.kochi.jp",
    "ochi.kochi.jp",
    "okawa.kochi.jp",
    "otoyo.kochi.jp",
    "otsuki.kochi.jp",
    "sakawa.kochi.jp",
    "sukumo.kochi.jp",
    "susaki.kochi.jp",
    "tosa.kochi.jp",
    "tosashimizu.kochi.jp",
    "toyo.kochi.jp",
    "tsuno.kochi.jp",
    "umaji.kochi.jp",
    "yasuda.kochi.jp",
    "yusuhara.kochi.jp",
    "amakusa.kumamoto.jp",
    "arao.kumamoto.jp",
    "aso.kumamoto.jp",
    "choyo.kumamoto.jp",
    "gyokuto.kumamoto.jp",
    "kamiamakusa.kumamoto.jp",
    "kikuchi.kumamoto.jp",
    "kumamoto.kumamoto.jp",
    "mashiki.kumamoto.jp",
    "mifune.kumamoto.jp",
    "minamata.kumamoto.jp",
    "minamioguni.kumamoto.jp",
    "nagasu.kumamoto.jp",
    "nishihara.kumamoto.jp",
    "oguni.kumamoto.jp",
    "ozu.kumamoto.jp",
    "sumoto.kumamoto.jp",
    "takamori.kumamoto.jp",
    "uki.kumamoto.jp",
    "uto.kumamoto.jp",
    "yamaga.kumamoto.jp",
    "yamato.kumamoto.jp",
    "yatsushiro.kumamoto.jp",
    "ayabe.kyoto.jp",
    "fukuchiyama.kyoto.jp",
    "higashiyama.kyoto.jp",
    "ide.kyoto.jp",
    "ine.kyoto.jp",
    "joyo.kyoto.jp",
    "kameoka.kyoto.jp",
    "kamo.kyoto.jp",
    "kita.kyoto.jp",
    "kizu.kyoto.jp",
    "kumiyama.kyoto.jp",
    "kyotamba.kyoto.jp",
    "kyotanabe.kyoto.jp",
    "kyotango.kyoto.jp",
    "maizuru.kyoto.jp",
    "minami.kyoto.jp",
    "minamiyamashiro.kyoto.jp",
    "miyazu.kyoto.jp",
    "muko.kyoto.jp",
    "nagaokakyo.kyoto.jp",
    "nakagyo.kyoto.jp",
    "nantan.kyoto.jp",
    "oyamazaki.kyoto.jp",
    "sakyo.kyoto.jp",
    "seika.kyoto.jp",
    "tanabe.kyoto.jp",
    "uji.kyoto.jp",
    "ujitawara.kyoto.jp",
    "wazuka.kyoto.jp",
    "yamashina.kyoto.jp",
    "yawata.kyoto.jp",
    "asahi.mie.jp",
    "inabe.mie.jp",
    "ise.mie.jp",
    "kameyama.mie.jp",
    "kawagoe.mie.jp",
    "kiho.mie.jp",
    "kisosaki.mie.jp",
    "kiwa.mie.jp",
    "komono.mie.jp",
    "kumano.mie.jp",
    "kuwana.mie.jp",
    "matsusaka.mie.jp",
    "meiwa.mie.jp",
    "mihama.mie.jp",
    "minamiise.mie.jp",
    "misugi.mie.jp",
    "miyama.mie.jp",
    "nabari.mie.jp",
    "shima.mie.jp",
    "suzuka.mie.jp",
    "tado.mie.jp",
    "taiki.mie.jp",
    "taki.mie.jp",
    "tamaki.mie.jp",
    "toba.mie.jp",
    "tsu.mie.jp",
    "udono.mie.jp",
    "ureshino.mie.jp",
    "watarai.mie.jp",
    "yokkaichi.mie.jp",
    "furukawa.miyagi.jp",
    "higashimatsushima.miyagi.jp",
    "ishinomaki.miyagi.jp",
    "iwanuma.miyagi.jp",
    "kakuda.miyagi.jp",
    "kami.miyagi.jp",
    "kawasaki.miyagi.jp",
    "marumori.miyagi.jp",
    "matsushima.miyagi.jp",
    "minamisanriku.miyagi.jp",
    "misato.miyagi.jp",
    "murata.miyagi.jp",
    "natori.miyagi.jp",
    "ogawara.miyagi.jp",
    "ohira.miyagi.jp",
    "onagawa.miyagi.jp",
    "osaki.miyagi.jp",
    "rifu.miyagi.jp",
    "semine.miyagi.jp",
    "shibata.miyagi.jp",
    "shichikashuku.miyagi.jp",
    "shikama.miyagi.jp",
    "shiogama.miyagi.jp",
    "shiroishi.miyagi.jp",
    "tagajo.miyagi.jp",
    "taiwa.miyagi.jp",
    "tome.miyagi.jp",
    "tomiya.miyagi.jp",
    "wakuya.miyagi.jp",
    "watari.miyagi.jp",
    "yamamoto.miyagi.jp",
    "zao.miyagi.jp",
    "aya.miyazaki.jp",
    "ebino.miyazaki.jp",
    "gokase.miyazaki.jp",
    "hyuga.miyazaki.jp",
    "kadogawa.miyazaki.jp",
    "kawaminami.miyazaki.jp",
    "kijo.miyazaki.jp",
    "kitagawa.miyazaki.jp",
    "kitakata.miyazaki.jp",
    "kitaura.miyazaki.jp",
    "kobayashi.miyazaki.jp",
    "kunitomi.miyazaki.jp",
    "kushima.miyazaki.jp",
    "mimata.miyazaki.jp",
    "miyakonojo.miyazaki.jp",
    "miyazaki.miyazaki.jp",
    "morotsuka.miyazaki.jp",
    "nichinan.miyazaki.jp",
    "nishimera.miyazaki.jp",
    "nobeoka.miyazaki.jp",
    "saito.miyazaki.jp",
    "shiiba.miyazaki.jp",
    "shintomi.miyazaki.jp",
    "takaharu.miyazaki.jp",
    "takanabe.miyazaki.jp",
    "takazaki.miyazaki.jp",
    "tsuno.miyazaki.jp",
    "achi.nagano.jp",
    "agematsu.nagano.jp",
    "anan.nagano.jp",
    "aoki.nagano.jp",
    "asahi.nagano.jp",
    "azumino.nagano.jp",
    "chikuhoku.nagano.jp",
    "chikuma.nagano.jp",
    "chino.nagano.jp",
    "fujimi.nagano.jp",
    "hakuba.nagano.jp",
    "hara.nagano.jp",
    "hiraya.nagano.jp",
    "iida.nagano.jp",
    "iijima.nagano.jp",
    "iiyama.nagano.jp",
    "iizuna.nagano.jp",
    "ikeda.nagano.jp",
    "ikusaka.nagano.jp",
    "ina.nagano.jp",
    "karuizawa.nagano.jp",
    "kawakami.nagano.jp",
    "kiso.nagano.jp",
    "kisofukushima.nagano.jp",
    "kitaaiki.nagano.jp",
    "komagane.nagano.jp",
    "komoro.nagano.jp",
    "matsukawa.nagano.jp",
    "matsumoto.nagano.jp",
    "miasa.nagano.jp",
    "minamiaiki.nagano.jp",
    "minamimaki.nagano.jp",
    "minamiminowa.nagano.jp",
    "minowa.nagano.jp",
    "miyada.nagano.jp",
    "miyota.nagano.jp",
    "mochizuki.nagano.jp",
    "nagano.nagano.jp",
    "nagawa.nagano.jp",
    "nagiso.nagano.jp",
    "nakagawa.nagano.jp",
    "nakano.nagano.jp",
    "nozawaonsen.nagano.jp",
    "obuse.nagano.jp",
    "ogawa.nagano.jp",
    "okaya.nagano.jp",
    "omachi.nagano.jp",
    "omi.nagano.jp",
    "ookuwa.nagano.jp",
    "ooshika.nagano.jp",
    "otaki.nagano.jp",
    "otari.nagano.jp",
    "sakae.nagano.jp",
    "sakaki.nagano.jp",
    "saku.nagano.jp",
    "sakuho.nagano.jp",
    "shimosuwa.nagano.jp",
    "shinanomachi.nagano.jp",
    "shiojiri.nagano.jp",
    "suwa.nagano.jp",
    "suzaka.nagano.jp",
    "takagi.nagano.jp",
    "takamori.nagano.jp",
    "takayama.nagano.jp",
    "tateshina.nagano.jp",
    "tatsuno.nagano.jp",
    "togakushi.nagano.jp",
    "togura.nagano.jp",
    "tomi.nagano.jp",
    "ueda.nagano.jp",
    "wada.nagano.jp",
    "yamagata.nagano.jp",
    "yamanouchi.nagano.jp",
    "yasaka.nagano.jp",
    "yasuoka.nagano.jp",
    "chijiwa.nagasaki.jp",
    "futsu.nagasaki.jp",
    "goto.nagasaki.jp",
    "hasami.nagasaki.jp",
    "hirado.nagasaki.jp",
    "iki.nagasaki.jp",
    "isahaya.nagasaki.jp",
    "kawatana.nagasaki.jp",
    "kuchinotsu.nagasaki.jp",
    "matsuura.nagasaki.jp",
    "nagasaki.nagasaki.jp",
    "obama.nagasaki.jp",
    "omura.nagasaki.jp",
    "oseto.nagasaki.jp",
    "saikai.nagasaki.jp",
    "sasebo.nagasaki.jp",
    "seihi.nagasaki.jp",
    "shimabara.nagasaki.jp",
    "shinkamigoto.nagasaki.jp",
    "togitsu.nagasaki.jp",
    "tsushima.nagasaki.jp",
    "unzen.nagasaki.jp",
    "ando.nara.jp",
    "gose.nara.jp",
    "heguri.nara.jp",
    "higashiyoshino.nara.jp",
    "ikaruga.nara.jp",
    "ikoma.nara.jp",
    "kamikitayama.nara.jp",
    "kanmaki.nara.jp",
    "kashiba.nara.jp",
    "kashihara.nara.jp",
    "katsuragi.nara.jp",
    "kawai.nara.jp",
    "kawakami.nara.jp",
    "kawanishi.nara.jp",
    "koryo.nara.jp",
    "kurotaki.nara.jp",
    "mitsue.nara.jp",
    "miyake.nara.jp",
    "nara.nara.jp",
    "nosegawa.nara.jp",
    "oji.nara.jp",
    "ouda.nara.jp",
    "oyodo.nara.jp",
    "sakurai.nara.jp",
    "sango.nara.jp",
    "shimoichi.nara.jp",
    "shimokitayama.nara.jp",
    "shinjo.nara.jp",
    "soni.nara.jp",
    "takatori.nara.jp",
    "tawaramoto.nara.jp",
    "tenkawa.nara.jp",
    "tenri.nara.jp",
    "uda.nara.jp",
    "yamatokoriyama.nara.jp",
    "yamatotakada.nara.jp",
    "yamazoe.nara.jp",
    "yoshino.nara.jp",
    "aga.niigata.jp",
    "agano.niigata.jp",
    "gosen.niigata.jp",
    "itoigawa.niigata.jp",
    "izumozaki.niigata.jp",
    "joetsu.niigata.jp",
    "kamo.niigata.jp",
    "kariwa.niigata.jp",
    "kashiwazaki.niigata.jp",
    "minamiuonuma.niigata.jp",
    "mitsuke.niigata.jp",
    "muika.niigata.jp",
    "murakami.niigata.jp",
    "myoko.niigata.jp",
    "nagaoka.niigata.jp",
    "niigata.niigata.jp",
    "ojiya.niigata.jp",
    "omi.niigata.jp",
    "sado.niigata.jp",
    "sanjo.niigata.jp",
    "seiro.niigata.jp",
    "seirou.niigata.jp",
    "sekikawa.niigata.jp",
    "shibata.niigata.jp",
    "tagami.niigata.jp",
    "tainai.niigata.jp",
    "tochio.niigata.jp",
    "tokamachi.niigata.jp",
    "tsubame.niigata.jp",
    "tsunan.niigata.jp",
    "uonuma.niigata.jp",
    "yahiko.niigata.jp",
    "yoita.niigata.jp",
    "yuzawa.niigata.jp",
    "beppu.oita.jp",
    "bungoono.oita.jp",
    "bungotakada.oita.jp",
    "hasama.oita.jp",
    "hiji.oita.jp",
    "himeshima.oita.jp",
    "hita.oita.jp",
    "kamitsue.oita.jp",
    "kokonoe.oita.jp",
    "kuju.oita.jp",
    "kunisaki.oita.jp",
    "kusu.oita.jp",
    "oita.oita.jp",
    "saiki.oita.jp",
    "taketa.oita.jp",
    "tsukumi.oita.jp",
    "usa.oita.jp",
    "usuki.oita.jp",
    "yufu.oita.jp",
    "akaiwa.okayama.jp",
    "asakuchi.okayama.jp",
    "bizen.okayama.jp",
    "hayashima.okayama.jp",
    "ibara.okayama.jp",
    "kagamino.okayama.jp",
    "kasaoka.okayama.jp",
    "kibichuo.okayama.jp",
    "kumenan.okayama.jp",
    "kurashiki.okayama.jp",
    "maniwa.okayama.jp",
    "misaki.okayama.jp",
    "nagi.okayama.jp",
    "niimi.okayama.jp",
    "nishiawakura.okayama.jp",
    "okayama.okayama.jp",
    "satosho.okayama.jp",
    "setouchi.okayama.jp",
    "shinjo.okayama.jp",
    "shoo.okayama.jp",
    "soja.okayama.jp",
    "takahashi.okayama.jp",
    "tamano.okayama.jp",
    "tsuyama.okayama.jp",
    "wake.okayama.jp",
    "yakage.okayama.jp",
    "aguni.okinawa.jp",
    "ginowan.okinawa.jp",
    "ginoza.okinawa.jp",
    "gushikami.okinawa.jp",
    "haebaru.okinawa.jp",
    "higashi.okinawa.jp",
    "hirara.okinawa.jp",
    "iheya.okinawa.jp",
    "ishigaki.okinawa.jp",
    "ishikawa.okinawa.jp",
    "itoman.okinawa.jp",
    "izena.okinawa.jp",
    "kadena.okinawa.jp",
    "kin.okinawa.jp",
    "kitadaito.okinawa.jp",
    "kitanakagusuku.okinawa.jp",
    "kumejima.okinawa.jp",
    "kunigami.okinawa.jp",
    "minamidaito.okinawa.jp",
    "motobu.okinawa.jp",
    "nago.okinawa.jp",
    "naha.okinawa.jp",
    "nakagusuku.okinawa.jp",
    "nakijin.okinawa.jp",
    "nanjo.okinawa.jp",
    "nishihara.okinawa.jp",
    "ogimi.okinawa.jp",
    "okinawa.okinawa.jp",
    "onna.okinawa.jp",
    "shimoji.okinawa.jp",
    "taketomi.okinawa.jp",
    "tarama.okinawa.jp",
    "tokashiki.okinawa.jp",
    "tomigusuku.okinawa.jp",
    "tonaki.okinawa.jp",
    "urasoe.okinawa.jp",
    "uruma.okinawa.jp",
    "yaese.okinawa.jp",
    "yomitan.okinawa.jp",
    "yonabaru.okinawa.jp",
    "yonaguni.okinawa.jp",
    "zamami.okinawa.jp",
    "abeno.osaka.jp",
    "chihayaakasaka.osaka.jp",
    "chuo.osaka.jp",
    "daito.osaka.jp",
    "fujiidera.osaka.jp",
    "habikino.osaka.jp",
    "hannan.osaka.jp",
    "higashiosaka.osaka.jp",
    "higashisumiyoshi.osaka.jp",
    "higashiyodogawa.osaka.jp",
    "hirakata.osaka.jp",
    "ibaraki.osaka.jp",
    "ikeda.osaka.jp",
    "izumi.osaka.jp",
    "izumiotsu.osaka.jp",
    "izumisano.osaka.jp",
    "kadoma.osaka.jp",
    "kaizuka.osaka.jp",
    "kanan.osaka.jp",
    "kashiwara.osaka.jp",
    "katano.osaka.jp",
    "kawachinagano.osaka.jp",
    "kishiwada.osaka.jp",
    "kita.osaka.jp",
    "kumatori.osaka.jp",
    "matsubara.osaka.jp",
    "minato.osaka.jp",
    "minoh.osaka.jp",
    "misaki.osaka.jp",
    "moriguchi.osaka.jp",
    "neyagawa.osaka.jp",
    "nishi.osaka.jp",
    "nose.osaka.jp",
    "osakasayama.osaka.jp",
    "sakai.osaka.jp",
    "sayama.osaka.jp",
    "sennan.osaka.jp",
    "settsu.osaka.jp",
    "shijonawate.osaka.jp",
    "shimamoto.osaka.jp",
    "suita.osaka.jp",
    "tadaoka.osaka.jp",
    "taishi.osaka.jp",
    "tajiri.osaka.jp",
    "takaishi.osaka.jp",
    "takatsuki.osaka.jp",
    "tondabayashi.osaka.jp",
    "toyonaka.osaka.jp",
    "toyono.osaka.jp",
    "yao.osaka.jp",
    "ariake.saga.jp",
    "arita.saga.jp",
    "fukudomi.saga.jp",
    "genkai.saga.jp",
    "hamatama.saga.jp",
    "hizen.saga.jp",
    "imari.saga.jp",
    "kamimine.saga.jp",
    "kanzaki.saga.jp",
    "karatsu.saga.jp",
    "kashima.saga.jp",
    "kitagata.saga.jp",
    "kitahata.saga.jp",
    "kiyama.saga.jp",
    "kouhoku.saga.jp",
    "kyuragi.saga.jp",
    "nishiarita.saga.jp",
    "ogi.saga.jp",
    "omachi.saga.jp",
    "ouchi.saga.jp",
    "saga.saga.jp",
    "shiroishi.saga.jp",
    "taku.saga.jp",
    "tara.saga.jp",
    "tosu.saga.jp",
    "yoshinogari.saga.jp",
    "arakawa.saitama.jp",
    "asaka.saitama.jp",
    "chichibu.saitama.jp",
    "fujimi.saitama.jp",
    "fujimino.saitama.jp",
    "fukaya.saitama.jp",
    "hanno.saitama.jp",
    "hanyu.saitama.jp",
    "hasuda.saitama.jp",
    "hatogaya.saitama.jp",
    "hatoyama.saitama.jp",
    "hidaka.saitama.jp",
    "higashichichibu.saitama.jp",
    "higashimatsuyama.saitama.jp",
    "honjo.saitama.jp",
    "ina.saitama.jp",
    "iruma.saitama.jp",
    "iwatsuki.saitama.jp",
    "kamiizumi.saitama.jp",
    "kamikawa.saitama.jp",
    "kamisato.saitama.jp",
    "kasukabe.saitama.jp",
    "kawagoe.saitama.jp",
    "kawaguchi.saitama.jp",
    "kawajima.saitama.jp",
    "kazo.saitama.jp",
    "kitamoto.saitama.jp",
    "koshigaya.saitama.jp",
    "kounosu.saitama.jp",
    "kuki.saitama.jp",
    "kumagaya.saitama.jp",
    "matsubushi.saitama.jp",
    "minano.saitama.jp",
    "misato.saitama.jp",
    "miyashiro.saitama.jp",
    "miyoshi.saitama.jp",
    "moroyama.saitama.jp",
    "nagatoro.saitama.jp",
    "namegawa.saitama.jp",
    "niiza.saitama.jp",
    "ogano.saitama.jp",
    "ogawa.saitama.jp",
    "ogose.saitama.jp",
    "okegawa.saitama.jp",
    "omiya.saitama.jp",
    "otaki.saitama.jp",
    "ranzan.saitama.jp",
    "ryokami.saitama.jp",
    "saitama.saitama.jp",
    "sakado.saitama.jp",
    "satte.saitama.jp",
    "sayama.saitama.jp",
    "shiki.saitama.jp",
    "shiraoka.saitama.jp",
    "soka.saitama.jp",
    "sugito.saitama.jp",
    "toda.saitama.jp",
    "tokigawa.saitama.jp",
    "tokorozawa.saitama.jp",
    "tsurugashima.saitama.jp",
    "urawa.saitama.jp",
    "warabi.saitama.jp",
    "yashio.saitama.jp",
    "yokoze.saitama.jp",
    "yono.saitama.jp",
    "yorii.saitama.jp",
    "yoshida.saitama.jp",
    "yoshikawa.saitama.jp",
    "yoshimi.saitama.jp",
    "aisho.shiga.jp",
    "gamo.shiga.jp",
    "higashiomi.shiga.jp",
    "hikone.shiga.jp",
    "koka.shiga.jp",
    "konan.shiga.jp",
    "kosei.shiga.jp",
    "koto.shiga.jp",
    "kusatsu.shiga.jp",
    "maibara.shiga.jp",
    "moriyama.shiga.jp",
    "nagahama.shiga.jp",
    "nishiazai.shiga.jp",
    "notogawa.shiga.jp",
    "omihachiman.shiga.jp",
    "otsu.shiga.jp",
    "ritto.shiga.jp",
    "ryuoh.shiga.jp",
    "takashima.shiga.jp",
    "takatsuki.shiga.jp",
    "torahime.shiga.jp",
    "toyosato.shiga.jp",
    "yasu.shiga.jp",
    "akagi.shimane.jp",
    "ama.shimane.jp",
    "gotsu.shimane.jp",
    "hamada.shimane.jp",
    "higashiizumo.shimane.jp",
    "hikawa.shimane.jp",
    "hikimi.shimane.jp",
    "izumo.shimane.jp",
    "kakinoki.shimane.jp",
    "masuda.shimane.jp",
    "matsue.shimane.jp",
    "misato.shimane.jp",
    "nishinoshima.shimane.jp",
    "ohda.shimane.jp",
    "okinoshima.shimane.jp",
    "okuizumo.shimane.jp",
    "shimane.shimane.jp",
    "tamayu.shimane.jp",
    "tsuwano.shimane.jp",
    "unnan.shimane.jp",
    "yakumo.shimane.jp",
    "yasugi.shimane.jp",
    "yatsuka.shimane.jp",
    "arai.shizuoka.jp",
    "atami.shizuoka.jp",
    "fuji.shizuoka.jp",
    "fujieda.shizuoka.jp",
    "fujikawa.shizuoka.jp",
    "fujinomiya.shizuoka.jp",
    "fukuroi.shizuoka.jp",
    "gotemba.shizuoka.jp",
    "haibara.shizuoka.jp",
    "hamamatsu.shizuoka.jp",
    "higashiizu.shizuoka.jp",
    "ito.shizuoka.jp",
    "iwata.shizuoka.jp",
    "izu.shizuoka.jp",
    "izunokuni.shizuoka.jp",
    "kakegawa.shizuoka.jp",
    "kannami.shizuoka.jp",
    "kawanehon.shizuoka.jp",
    "kawazu.shizuoka.jp",
    "kikugawa.shizuoka.jp",
    "kosai.shizuoka.jp",
    "makinohara.shizuoka.jp",
    "matsuzaki.shizuoka.jp",
    "minamiizu.shizuoka.jp",
    "mishima.shizuoka.jp",
    "morimachi.shizuoka.jp",
    "nishiizu.shizuoka.jp",
    "numazu.shizuoka.jp",
    "omaezaki.shizuoka.jp",
    "shimada.shizuoka.jp",
    "shimizu.shizuoka.jp",
    "shimoda.shizuoka.jp",
    "shizuoka.shizuoka.jp",
    "susono.shizuoka.jp",
    "yaizu.shizuoka.jp",
    "yoshida.shizuoka.jp",
    "ashikaga.tochigi.jp",
    "bato.tochigi.jp",
    "haga.tochigi.jp",
    "ichikai.tochigi.jp",
    "iwafune.tochigi.jp",
    "kaminokawa.tochigi.jp",
    "kanuma.tochigi.jp",
    "karasuyama.tochigi.jp",
    "kuroiso.tochigi.jp",
    "mashiko.tochigi.jp",
    "mibu.tochigi.jp",
    "moka.tochigi.jp",
    "motegi.tochigi.jp",
    "nasu.tochigi.jp",
    "nasushiobara.tochigi.jp",
    "nikko.tochigi.jp",
    "nishikata.tochigi.jp",
    "nogi.tochigi.jp",
    "ohira.tochigi.jp",
    "ohtawara.tochigi.jp",
    "oyama.tochigi.jp",
    "sakura.tochigi.jp",
    "sano.tochigi.jp",
    "shimotsuke.tochigi.jp",
    "shioya.tochigi.jp",
    "takanezawa.tochigi.jp",
    "tochigi.tochigi.jp",
    "tsuga.tochigi.jp",
    "ujiie.tochigi.jp",
    "utsunomiya.tochigi.jp",
    "yaita.tochigi.jp",
    "aizumi.tokushima.jp",
    "anan.tokushima.jp",
    "ichiba.tokushima.jp",
    "itano.tokushima.jp",
    "kainan.tokushima.jp",
    "komatsushima.tokushima.jp",
    "matsushige.tokushima.jp",
    "mima.tokushima.jp",
    "minami.tokushima.jp",
    "miyoshi.tokushima.jp",
    "mugi.tokushima.jp",
    "nakagawa.tokushima.jp",
    "naruto.tokushima.jp",
    "sanagochi.tokushima.jp",
    "shishikui.tokushima.jp",
    "tokushima.tokushima.jp",
    "wajiki.tokushima.jp",
    "adachi.tokyo.jp",
    "akiruno.tokyo.jp",
    "akishima.tokyo.jp",
    "aogashima.tokyo.jp",
    "arakawa.tokyo.jp",
    "bunkyo.tokyo.jp",
    "chiyoda.tokyo.jp",
    "chofu.tokyo.jp",
    "chuo.tokyo.jp",
    "edogawa.tokyo.jp",
    "fuchu.tokyo.jp",
    "fussa.tokyo.jp",
    "hachijo.tokyo.jp",
    "hachioji.tokyo.jp",
    "hamura.tokyo.jp",
    "higashikurume.tokyo.jp",
    "higashimurayama.tokyo.jp",
    "higashiyamato.tokyo.jp",
    "hino.tokyo.jp",
    "hinode.tokyo.jp",
    "hinohara.tokyo.jp",
    "inagi.tokyo.jp",
    "itabashi.tokyo.jp",
    "katsushika.tokyo.jp",
    "kita.tokyo.jp",
    "kiyose.tokyo.jp",
    "kodaira.tokyo.jp",
    "koganei.tokyo.jp",
    "kokubunji.tokyo.jp",
    "komae.tokyo.jp",
    "koto.tokyo.jp",
    "kouzushima.tokyo.jp",
    "kunitachi.tokyo.jp",
    "machida.tokyo.jp",
    "meguro.tokyo.jp",
    "minato.tokyo.jp",
    "mitaka.tokyo.jp",
    "mizuho.tokyo.jp",
    "musashimurayama.tokyo.jp",
    "musashino.tokyo.jp",
    "nakano.tokyo.jp",
    "nerima.tokyo.jp",
    "ogasawara.tokyo.jp",
    "okutama.tokyo.jp",
    "ome.tokyo.jp",
    "oshima.tokyo.jp",
    "ota.tokyo.jp",
    "setagaya.tokyo.jp",
    "shibuya.tokyo.jp",
    "shinagawa.tokyo.jp",
    "shinjuku.tokyo.jp",
    "suginami.tokyo.jp",
    "sumida.tokyo.jp",
    "tachikawa.tokyo.jp",
    "taito.tokyo.jp",
    "tama.tokyo.jp",
    "toshima.tokyo.jp",
    "chizu.tottori.jp",
    "hino.tottori.jp",
    "kawahara.tottori.jp",
    "koge.tottori.jp",
    "kotoura.tottori.jp",
    "misasa.tottori.jp",
    "nanbu.tottori.jp",
    "nichinan.tottori.jp",
    "sakaiminato.tottori.jp",
    "tottori.tottori.jp",
    "wakasa.tottori.jp",
    "yazu.tottori.jp",
    "yonago.tottori.jp",
    "asahi.toyama.jp",
    "fuchu.toyama.jp",
    "fukumitsu.toyama.jp",
    "funahashi.toyama.jp",
    "himi.toyama.jp",
    "imizu.toyama.jp",
    "inami.toyama.jp",
    "johana.toyama.jp",
    "kamiichi.toyama.jp",
    "kurobe.toyama.jp",
    "nakaniikawa.toyama.jp",
    "namerikawa.toyama.jp",
    "nanto.toyama.jp",
    "nyuzen.toyama.jp",
    "oyabe.toyama.jp",
    "taira.toyama.jp",
    "takaoka.toyama.jp",
    "tateyama.toyama.jp",
    "toga.toyama.jp",
    "tonami.toyama.jp",
    "toyama.toyama.jp",
    "unazuki.toyama.jp",
    "uozu.toyama.jp",
    "yamada.toyama.jp",
    "arida.wakayama.jp",
    "aridagawa.wakayama.jp",
    "gobo.wakayama.jp",
    "hashimoto.wakayama.jp",
    "hidaka.wakayama.jp",
    "hirogawa.wakayama.jp",
    "inami.wakayama.jp",
    "iwade.wakayama.jp",
    "kainan.wakayama.jp",
    "kamitonda.wakayama.jp",
    "katsuragi.wakayama.jp",
    "kimino.wakayama.jp",
    "kinokawa.wakayama.jp",
    "kitayama.wakayama.jp",
    "koya.wakayama.jp",
    "koza.wakayama.jp",
    "kozagawa.wakayama.jp",
    "kudoyama.wakayama.jp",
    "kushimoto.wakayama.jp",
    "mihama.wakayama.jp",
    "misato.wakayama.jp",
    "nachikatsuura.wakayama.jp",
    "shingu.wakayama.jp",
    "shirahama.wakayama.jp",
    "taiji.wakayama.jp",
    "tanabe.wakayama.jp",
    "wakayama.wakayama.jp",
    "yuasa.wakayama.jp",
    "yura.wakayama.jp",
    "asahi.yamagata.jp",
    "funagata.yamagata.jp",
    "higashine.yamagata.jp",
    "iide.yamagata.jp",
    "kahoku.yamagata.jp",
    "kaminoyama.yamagata.jp",
    "kaneyama.yamagata.jp",
    "kawanishi.yamagata.jp",
    "mamurogawa.yamagata.jp",
    "mikawa.yamagata.jp",
    "murayama.yamagata.jp",
    "nagai.yamagata.jp",
    "nakayama.yamagata.jp",
    "nanyo.yamagata.jp",
    "nishikawa.yamagata.jp",
    "obanazawa.yamagata.jp",
    "oe.yamagata.jp",
    "oguni.yamagata.jp",
    "ohkura.yamagata.jp",
    "oishida.yamagata.jp",
    "sagae.yamagata.jp",
    "sakata.yamagata.jp",
    "sakegawa.yamagata.jp",
    "shinjo.yamagata.jp",
    "shirataka.yamagata.jp",
    "shonai.yamagata.jp",
    "takahata.yamagata.jp",
    "tendo.yamagata.jp",
    "tozawa.yamagata.jp",
    "tsuruoka.yamagata.jp",
    "yamagata.yamagata.jp",
    "yamanobe.yamagata.jp",
    "yonezawa.yamagata.jp",
    "yuza.yamagata.jp",
    "abu.yamaguchi.jp",
    "hagi.yamaguchi.jp",
    "hikari.yamaguchi.jp",
    "hofu.yamaguchi.jp",
    "iwakuni.yamaguchi.jp",
    "kudamatsu.yamaguchi.jp",
    "mitou.yamaguchi.jp",
    "nagato.yamaguchi.jp",
    "oshima.yamaguchi.jp",
    "shimonoseki.yamaguchi.jp",
    "shunan.yamaguchi.jp",
    "tabuse.yamaguchi.jp",
    "tokuyama.yamaguchi.jp",
    "toyota.yamaguchi.jp",
    "ube.yamaguchi.jp",
    "yuu.yamaguchi.jp",
    "chuo.yamanashi.jp",
    "doshi.yamanashi.jp",
    "fuefuki.yamanashi.jp",
    "fujikawa.yamanashi.jp",
    "fujikawaguchiko.yamanashi.jp",
    "fujiyoshida.yamanashi.jp",
    "hayakawa.yamanashi.jp",
    "hokuto.yamanashi.jp",
    "ichikawamisato.yamanashi.jp",
    "kai.yamanashi.jp",
    "kofu.yamanashi.jp",
    "koshu.yamanashi.jp",
    "kosuge.yamanashi.jp",
    "minami-alps.yamanashi.jp",
    "minobu.yamanashi.jp",
    "nakamichi.yamanashi.jp",
    "nanbu.yamanashi.jp",
    "narusawa.yamanashi.jp",
    "nirasaki.yamanashi.jp",
    "nishikatsura.yamanashi.jp",
    "oshino.yamanashi.jp",
    "otsuki.yamanashi.jp",
    "showa.yamanashi.jp",
    "tabayama.yamanashi.jp",
    "tsuru.yamanashi.jp",
    "uenohara.yamanashi.jp",
    "yamanakako.yamanashi.jp",
    "yamanashi.yamanashi.jp",
    "ke",
    "ac.ke",
    "co.ke",
    "go.ke",
    "info.ke",
    "me.ke",
    "mobi.ke",
    "ne.ke",
    "or.ke",
    "sc.ke",
    "kg",
    "org.kg",
    "net.kg",
    "com.kg",
    "edu.kg",
    "gov.kg",
    "mil.kg",
    "*.kh",
    "ki",
    "edu.ki",
    "biz.ki",
    "net.ki",
    "org.ki",
    "gov.ki",
    "info.ki",
    "com.ki",
    "km",
    "org.km",
    "nom.km",
    "gov.km",
    "prd.km",
    "tm.km",
    "edu.km",
    "mil.km",
    "ass.km",
    "com.km",
    "coop.km",
    "asso.km",
    "presse.km",
    "medecin.km",
    "notaires.km",
    "pharmaciens.km",
    "veterinaire.km",
    "gouv.km",
    "kn",
    "net.kn",
    "org.kn",
    "edu.kn",
    "gov.kn",
    "kp",
    "com.kp",
    "edu.kp",
    "gov.kp",
    "org.kp",
    "rep.kp",
    "tra.kp",
    "kr",
    "ac.kr",
    "co.kr",
    "es.kr",
    "go.kr",
    "hs.kr",
    "kg.kr",
    "mil.kr",
    "ms.kr",
    "ne.kr",
    "or.kr",
    "pe.kr",
    "re.kr",
    "sc.kr",
    "busan.kr",
    "chungbuk.kr",
    "chungnam.kr",
    "daegu.kr",
    "daejeon.kr",
    "gangwon.kr",
    "gwangju.kr",
    "gyeongbuk.kr",
    "gyeonggi.kr",
    "gyeongnam.kr",
    "incheon.kr",
    "jeju.kr",
    "jeonbuk.kr",
    "jeonnam.kr",
    "seoul.kr",
    "ulsan.kr",
    "kw",
    "com.kw",
    "edu.kw",
    "emb.kw",
    "gov.kw",
    "ind.kw",
    "net.kw",
    "org.kw",
    "ky",
    "edu.ky",
    "gov.ky",
    "com.ky",
    "org.ky",
    "net.ky",
    "kz",
    "org.kz",
    "edu.kz",
    "net.kz",
    "gov.kz",
    "mil.kz",
    "com.kz",
    "la",
    "int.la",
    "net.la",
    "info.la",
    "edu.la",
    "gov.la",
    "per.la",
    "com.la",
    "org.la",
    "lb",
    "com.lb",
    "edu.lb",
    "gov.lb",
    "net.lb",
    "org.lb",
    "lc",
    "com.lc",
    "net.lc",
    "co.lc",
    "org.lc",
    "edu.lc",
    "gov.lc",
    "li",
    "lk",
    "gov.lk",
    "sch.lk",
    "net.lk",
    "int.lk",
    "com.lk",
    "org.lk",
    "edu.lk",
    "ngo.lk",
    "soc.lk",
    "web.lk",
    "ltd.lk",
    "assn.lk",
    "grp.lk",
    "hotel.lk",
    "ac.lk",
    "lr",
    "com.lr",
    "edu.lr",
    "gov.lr",
    "org.lr",
    "net.lr",
    "ls",
    "ac.ls",
    "biz.ls",
    "co.ls",
    "edu.ls",
    "gov.ls",
    "info.ls",
    "net.ls",
    "org.ls",
    "sc.ls",
    "lt",
    "gov.lt",
    "lu",
    "lv",
    "com.lv",
    "edu.lv",
    "gov.lv",
    "org.lv",
    "mil.lv",
    "id.lv",
    "net.lv",
    "asn.lv",
    "conf.lv",
    "ly",
    "com.ly",
    "net.ly",
    "gov.ly",
    "plc.ly",
    "edu.ly",
    "sch.ly",
    "med.ly",
    "org.ly",
    "id.ly",
    "ma",
    "co.ma",
    "net.ma",
    "gov.ma",
    "org.ma",
    "ac.ma",
    "press.ma",
    "mc",
    "tm.mc",
    "asso.mc",
    "md",
    "me",
    "co.me",
    "net.me",
    "org.me",
    "edu.me",
    "ac.me",
    "gov.me",
    "its.me",
    "priv.me",
    "mg",
    "org.mg",
    "nom.mg",
    "gov.mg",
    "prd.mg",
    "tm.mg",
    "edu.mg",
    "mil.mg",
    "com.mg",
    "co.mg",
    "mh",
    "mil",
    "mk",
    "com.mk",
    "org.mk",
    "net.mk",
    "edu.mk",
    "gov.mk",
    "inf.mk",
    "name.mk",
    "ml",
    "com.ml",
    "edu.ml",
    "gouv.ml",
    "gov.ml",
    "net.ml",
    "org.ml",
    "presse.ml",
    "*.mm",
    "mn",
    "gov.mn",
    "edu.mn",
    "org.mn",
    "mo",
    "com.mo",
    "net.mo",
    "org.mo",
    "edu.mo",
    "gov.mo",
    "mobi",
    "mp",
    "mq",
    "mr",
    "gov.mr",
    "ms",
    "com.ms",
    "edu.ms",
    "gov.ms",
    "net.ms",
    "org.ms",
    "mt",
    "com.mt",
    "edu.mt",
    "net.mt",
    "org.mt",
    "mu",
    "com.mu",
    "net.mu",
    "org.mu",
    "gov.mu",
    "ac.mu",
    "co.mu",
    "or.mu",
    "museum",
    "academy.museum",
    "agriculture.museum",
    "air.museum",
    "airguard.museum",
    "alabama.museum",
    "alaska.museum",
    "amber.museum",
    "ambulance.museum",
    "american.museum",
    "americana.museum",
    "americanantiques.museum",
    "americanart.museum",
    "amsterdam.museum",
    "and.museum",
    "annefrank.museum",
    "anthro.museum",
    "anthropology.museum",
    "antiques.museum",
    "aquarium.museum",
    "arboretum.museum",
    "archaeological.museum",
    "archaeology.museum",
    "architecture.museum",
    "art.museum",
    "artanddesign.museum",
    "artcenter.museum",
    "artdeco.museum",
    "arteducation.museum",
    "artgallery.museum",
    "arts.museum",
    "artsandcrafts.museum",
    "asmatart.museum",
    "assassination.museum",
    "assisi.museum",
    "association.museum",
    "astronomy.museum",
    "atlanta.museum",
    "austin.museum",
    "australia.museum",
    "automotive.museum",
    "aviation.museum",
    "axis.museum",
    "badajoz.museum",
    "baghdad.museum",
    "bahn.museum",
    "bale.museum",
    "baltimore.museum",
    "barcelona.museum",
    "baseball.museum",
    "basel.museum",
    "baths.museum",
    "bauern.museum",
    "beauxarts.museum",
    "beeldengeluid.museum",
    "bellevue.museum",
    "bergbau.museum",
    "berkeley.museum",
    "berlin.museum",
    "bern.museum",
    "bible.museum",
    "bilbao.museum",
    "bill.museum",
    "birdart.museum",
    "birthplace.museum",
    "bonn.museum",
    "boston.museum",
    "botanical.museum",
    "botanicalgarden.museum",
    "botanicgarden.museum",
    "botany.museum",
    "brandywinevalley.museum",
    "brasil.museum",
    "bristol.museum",
    "british.museum",
    "britishcolumbia.museum",
    "broadcast.museum",
    "brunel.museum",
    "brussel.museum",
    "brussels.museum",
    "bruxelles.museum",
    "building.museum",
    "burghof.museum",
    "bus.museum",
    "bushey.museum",
    "cadaques.museum",
    "california.museum",
    "cambridge.museum",
    "can.museum",
    "canada.museum",
    "capebreton.museum",
    "carrier.museum",
    "cartoonart.museum",
    "casadelamoneda.museum",
    "castle.museum",
    "castres.museum",
    "celtic.museum",
    "center.museum",
    "chattanooga.museum",
    "cheltenham.museum",
    "chesapeakebay.museum",
    "chicago.museum",
    "children.museum",
    "childrens.museum",
    "childrensgarden.museum",
    "chiropractic.museum",
    "chocolate.museum",
    "christiansburg.museum",
    "cincinnati.museum",
    "cinema.museum",
    "circus.museum",
    "civilisation.museum",
    "civilization.museum",
    "civilwar.museum",
    "clinton.museum",
    "clock.museum",
    "coal.museum",
    "coastaldefence.museum",
    "cody.museum",
    "coldwar.museum",
    "collection.museum",
    "colonialwilliamsburg.museum",
    "coloradoplateau.museum",
    "columbia.museum",
    "columbus.museum",
    "communication.museum",
    "communications.museum",
    "community.museum",
    "computer.museum",
    "computerhistory.museum",
    "comunica\xE7\xF5es.museum",
    "contemporary.museum",
    "contemporaryart.museum",
    "convent.museum",
    "copenhagen.museum",
    "corporation.museum",
    "correios-e-telecomunica\xE7\xF5es.museum",
    "corvette.museum",
    "costume.museum",
    "countryestate.museum",
    "county.museum",
    "crafts.museum",
    "cranbrook.museum",
    "creation.museum",
    "cultural.museum",
    "culturalcenter.museum",
    "culture.museum",
    "cyber.museum",
    "cymru.museum",
    "dali.museum",
    "dallas.museum",
    "database.museum",
    "ddr.museum",
    "decorativearts.museum",
    "delaware.museum",
    "delmenhorst.museum",
    "denmark.museum",
    "depot.museum",
    "design.museum",
    "detroit.museum",
    "dinosaur.museum",
    "discovery.museum",
    "dolls.museum",
    "donostia.museum",
    "durham.museum",
    "eastafrica.museum",
    "eastcoast.museum",
    "education.museum",
    "educational.museum",
    "egyptian.museum",
    "eisenbahn.museum",
    "elburg.museum",
    "elvendrell.museum",
    "embroidery.museum",
    "encyclopedic.museum",
    "england.museum",
    "entomology.museum",
    "environment.museum",
    "environmentalconservation.museum",
    "epilepsy.museum",
    "essex.museum",
    "estate.museum",
    "ethnology.museum",
    "exeter.museum",
    "exhibition.museum",
    "family.museum",
    "farm.museum",
    "farmequipment.museum",
    "farmers.museum",
    "farmstead.museum",
    "field.museum",
    "figueres.museum",
    "filatelia.museum",
    "film.museum",
    "fineart.museum",
    "finearts.museum",
    "finland.museum",
    "flanders.museum",
    "florida.museum",
    "force.museum",
    "fortmissoula.museum",
    "fortworth.museum",
    "foundation.museum",
    "francaise.museum",
    "frankfurt.museum",
    "franziskaner.museum",
    "freemasonry.museum",
    "freiburg.museum",
    "fribourg.museum",
    "frog.museum",
    "fundacio.museum",
    "furniture.museum",
    "gallery.museum",
    "garden.museum",
    "gateway.museum",
    "geelvinck.museum",
    "gemological.museum",
    "geology.museum",
    "georgia.museum",
    "giessen.museum",
    "glas.museum",
    "glass.museum",
    "gorge.museum",
    "grandrapids.museum",
    "graz.museum",
    "guernsey.museum",
    "halloffame.museum",
    "hamburg.museum",
    "handson.museum",
    "harvestcelebration.museum",
    "hawaii.museum",
    "health.museum",
    "heimatunduhren.museum",
    "hellas.museum",
    "helsinki.museum",
    "hembygdsforbund.museum",
    "heritage.museum",
    "histoire.museum",
    "historical.museum",
    "historicalsociety.museum",
    "historichouses.museum",
    "historisch.museum",
    "historisches.museum",
    "history.museum",
    "historyofscience.museum",
    "horology.museum",
    "house.museum",
    "humanities.museum",
    "illustration.museum",
    "imageandsound.museum",
    "indian.museum",
    "indiana.museum",
    "indianapolis.museum",
    "indianmarket.museum",
    "intelligence.museum",
    "interactive.museum",
    "iraq.museum",
    "iron.museum",
    "isleofman.museum",
    "jamison.museum",
    "jefferson.museum",
    "jerusalem.museum",
    "jewelry.museum",
    "jewish.museum",
    "jewishart.museum",
    "jfk.museum",
    "journalism.museum",
    "judaica.museum",
    "judygarland.museum",
    "juedisches.museum",
    "juif.museum",
    "karate.museum",
    "karikatur.museum",
    "kids.museum",
    "koebenhavn.museum",
    "koeln.museum",
    "kunst.museum",
    "kunstsammlung.museum",
    "kunstunddesign.museum",
    "labor.museum",
    "labour.museum",
    "lajolla.museum",
    "lancashire.museum",
    "landes.museum",
    "lans.museum",
    "l\xE4ns.museum",
    "larsson.museum",
    "lewismiller.museum",
    "lincoln.museum",
    "linz.museum",
    "living.museum",
    "livinghistory.museum",
    "localhistory.museum",
    "london.museum",
    "losangeles.museum",
    "louvre.museum",
    "loyalist.museum",
    "lucerne.museum",
    "luxembourg.museum",
    "luzern.museum",
    "mad.museum",
    "madrid.museum",
    "mallorca.museum",
    "manchester.museum",
    "mansion.museum",
    "mansions.museum",
    "manx.museum",
    "marburg.museum",
    "maritime.museum",
    "maritimo.museum",
    "maryland.museum",
    "marylhurst.museum",
    "media.museum",
    "medical.museum",
    "medizinhistorisches.museum",
    "meeres.museum",
    "memorial.museum",
    "mesaverde.museum",
    "michigan.museum",
    "midatlantic.museum",
    "military.museum",
    "mill.museum",
    "miners.museum",
    "mining.museum",
    "minnesota.museum",
    "missile.museum",
    "missoula.museum",
    "modern.museum",
    "moma.museum",
    "money.museum",
    "monmouth.museum",
    "monticello.museum",
    "montreal.museum",
    "moscow.museum",
    "motorcycle.museum",
    "muenchen.museum",
    "muenster.museum",
    "mulhouse.museum",
    "muncie.museum",
    "museet.museum",
    "museumcenter.museum",
    "museumvereniging.museum",
    "music.museum",
    "national.museum",
    "nationalfirearms.museum",
    "nationalheritage.museum",
    "nativeamerican.museum",
    "naturalhistory.museum",
    "naturalhistorymuseum.museum",
    "naturalsciences.museum",
    "nature.museum",
    "naturhistorisches.museum",
    "natuurwetenschappen.museum",
    "naumburg.museum",
    "naval.museum",
    "nebraska.museum",
    "neues.museum",
    "newhampshire.museum",
    "newjersey.museum",
    "newmexico.museum",
    "newport.museum",
    "newspaper.museum",
    "newyork.museum",
    "niepce.museum",
    "norfolk.museum",
    "north.museum",
    "nrw.museum",
    "nuernberg.museum",
    "nuremberg.museum",
    "nyc.museum",
    "nyny.museum",
    "oceanographic.museum",
    "oceanographique.museum",
    "omaha.museum",
    "online.museum",
    "ontario.museum",
    "openair.museum",
    "oregon.museum",
    "oregontrail.museum",
    "otago.museum",
    "oxford.museum",
    "pacific.museum",
    "paderborn.museum",
    "palace.museum",
    "paleo.museum",
    "palmsprings.museum",
    "panama.museum",
    "paris.museum",
    "pasadena.museum",
    "pharmacy.museum",
    "philadelphia.museum",
    "philadelphiaarea.museum",
    "philately.museum",
    "phoenix.museum",
    "photography.museum",
    "pilots.museum",
    "pittsburgh.museum",
    "planetarium.museum",
    "plantation.museum",
    "plants.museum",
    "plaza.museum",
    "portal.museum",
    "portland.museum",
    "portlligat.museum",
    "posts-and-telecommunications.museum",
    "preservation.museum",
    "presidio.museum",
    "press.museum",
    "project.museum",
    "public.museum",
    "pubol.museum",
    "quebec.museum",
    "railroad.museum",
    "railway.museum",
    "research.museum",
    "resistance.museum",
    "riodejaneiro.museum",
    "rochester.museum",
    "rockart.museum",
    "roma.museum",
    "russia.museum",
    "saintlouis.museum",
    "salem.museum",
    "salvadordali.museum",
    "salzburg.museum",
    "sandiego.museum",
    "sanfrancisco.museum",
    "santabarbara.museum",
    "santacruz.museum",
    "santafe.museum",
    "saskatchewan.museum",
    "satx.museum",
    "savannahga.museum",
    "schlesisches.museum",
    "schoenbrunn.museum",
    "schokoladen.museum",
    "school.museum",
    "schweiz.museum",
    "science.museum",
    "scienceandhistory.museum",
    "scienceandindustry.museum",
    "sciencecenter.museum",
    "sciencecenters.museum",
    "science-fiction.museum",
    "sciencehistory.museum",
    "sciences.museum",
    "sciencesnaturelles.museum",
    "scotland.museum",
    "seaport.museum",
    "settlement.museum",
    "settlers.museum",
    "shell.museum",
    "sherbrooke.museum",
    "sibenik.museum",
    "silk.museum",
    "ski.museum",
    "skole.museum",
    "society.museum",
    "sologne.museum",
    "soundandvision.museum",
    "southcarolina.museum",
    "southwest.museum",
    "space.museum",
    "spy.museum",
    "square.museum",
    "stadt.museum",
    "stalbans.museum",
    "starnberg.museum",
    "state.museum",
    "stateofdelaware.museum",
    "station.museum",
    "steam.museum",
    "steiermark.museum",
    "stjohn.museum",
    "stockholm.museum",
    "stpetersburg.museum",
    "stuttgart.museum",
    "suisse.museum",
    "surgeonshall.museum",
    "surrey.museum",
    "svizzera.museum",
    "sweden.museum",
    "sydney.museum",
    "tank.museum",
    "tcm.museum",
    "technology.museum",
    "telekommunikation.museum",
    "television.museum",
    "texas.museum",
    "textile.museum",
    "theater.museum",
    "time.museum",
    "timekeeping.museum",
    "topology.museum",
    "torino.museum",
    "touch.museum",
    "town.museum",
    "transport.museum",
    "tree.museum",
    "trolley.museum",
    "trust.museum",
    "trustee.museum",
    "uhren.museum",
    "ulm.museum",
    "undersea.museum",
    "university.museum",
    "usa.museum",
    "usantiques.museum",
    "usarts.museum",
    "uscountryestate.museum",
    "usculture.museum",
    "usdecorativearts.museum",
    "usgarden.museum",
    "ushistory.museum",
    "ushuaia.museum",
    "uslivinghistory.museum",
    "utah.museum",
    "uvic.museum",
    "valley.museum",
    "vantaa.museum",
    "versailles.museum",
    "viking.museum",
    "village.museum",
    "virginia.museum",
    "virtual.museum",
    "virtuel.museum",
    "vlaanderen.museum",
    "volkenkunde.museum",
    "wales.museum",
    "wallonie.museum",
    "war.museum",
    "washingtondc.museum",
    "watchandclock.museum",
    "watch-and-clock.museum",
    "western.museum",
    "westfalen.museum",
    "whaling.museum",
    "wildlife.museum",
    "williamsburg.museum",
    "windmill.museum",
    "workshop.museum",
    "york.museum",
    "yorkshire.museum",
    "yosemite.museum",
    "youth.museum",
    "zoological.museum",
    "zoology.museum",
    "\u05D9\u05E8\u05D5\u05E9\u05DC\u05D9\u05DD.museum",
    "\u0438\u043A\u043E\u043C.museum",
    "mv",
    "aero.mv",
    "biz.mv",
    "com.mv",
    "coop.mv",
    "edu.mv",
    "gov.mv",
    "info.mv",
    "int.mv",
    "mil.mv",
    "museum.mv",
    "name.mv",
    "net.mv",
    "org.mv",
    "pro.mv",
    "mw",
    "ac.mw",
    "biz.mw",
    "co.mw",
    "com.mw",
    "coop.mw",
    "edu.mw",
    "gov.mw",
    "int.mw",
    "museum.mw",
    "net.mw",
    "org.mw",
    "mx",
    "com.mx",
    "org.mx",
    "gob.mx",
    "edu.mx",
    "net.mx",
    "my",
    "com.my",
    "net.my",
    "org.my",
    "gov.my",
    "edu.my",
    "mil.my",
    "name.my",
    "mz",
    "ac.mz",
    "adv.mz",
    "co.mz",
    "edu.mz",
    "gov.mz",
    "mil.mz",
    "net.mz",
    "org.mz",
    "na",
    "info.na",
    "pro.na",
    "name.na",
    "school.na",
    "or.na",
    "dr.na",
    "us.na",
    "mx.na",
    "ca.na",
    "in.na",
    "cc.na",
    "tv.na",
    "ws.na",
    "mobi.na",
    "co.na",
    "com.na",
    "org.na",
    "name",
    "nc",
    "asso.nc",
    "nom.nc",
    "ne",
    "net",
    "nf",
    "com.nf",
    "net.nf",
    "per.nf",
    "rec.nf",
    "web.nf",
    "arts.nf",
    "firm.nf",
    "info.nf",
    "other.nf",
    "store.nf",
    "ng",
    "com.ng",
    "edu.ng",
    "gov.ng",
    "i.ng",
    "mil.ng",
    "mobi.ng",
    "name.ng",
    "net.ng",
    "org.ng",
    "sch.ng",
    "ni",
    "ac.ni",
    "biz.ni",
    "co.ni",
    "com.ni",
    "edu.ni",
    "gob.ni",
    "in.ni",
    "info.ni",
    "int.ni",
    "mil.ni",
    "net.ni",
    "nom.ni",
    "org.ni",
    "web.ni",
    "nl",
    "no",
    "fhs.no",
    "vgs.no",
    "fylkesbibl.no",
    "folkebibl.no",
    "museum.no",
    "idrett.no",
    "priv.no",
    "mil.no",
    "stat.no",
    "dep.no",
    "kommune.no",
    "herad.no",
    "aa.no",
    "ah.no",
    "bu.no",
    "fm.no",
    "hl.no",
    "hm.no",
    "jan-mayen.no",
    "mr.no",
    "nl.no",
    "nt.no",
    "of.no",
    "ol.no",
    "oslo.no",
    "rl.no",
    "sf.no",
    "st.no",
    "svalbard.no",
    "tm.no",
    "tr.no",
    "va.no",
    "vf.no",
    "gs.aa.no",
    "gs.ah.no",
    "gs.bu.no",
    "gs.fm.no",
    "gs.hl.no",
    "gs.hm.no",
    "gs.jan-mayen.no",
    "gs.mr.no",
    "gs.nl.no",
    "gs.nt.no",
    "gs.of.no",
    "gs.ol.no",
    "gs.oslo.no",
    "gs.rl.no",
    "gs.sf.no",
    "gs.st.no",
    "gs.svalbard.no",
    "gs.tm.no",
    "gs.tr.no",
    "gs.va.no",
    "gs.vf.no",
    "akrehamn.no",
    "\xE5krehamn.no",
    "algard.no",
    "\xE5lg\xE5rd.no",
    "arna.no",
    "brumunddal.no",
    "bryne.no",
    "bronnoysund.no",
    "br\xF8nn\xF8ysund.no",
    "drobak.no",
    "dr\xF8bak.no",
    "egersund.no",
    "fetsund.no",
    "floro.no",
    "flor\xF8.no",
    "fredrikstad.no",
    "hokksund.no",
    "honefoss.no",
    "h\xF8nefoss.no",
    "jessheim.no",
    "jorpeland.no",
    "j\xF8rpeland.no",
    "kirkenes.no",
    "kopervik.no",
    "krokstadelva.no",
    "langevag.no",
    "langev\xE5g.no",
    "leirvik.no",
    "mjondalen.no",
    "mj\xF8ndalen.no",
    "mo-i-rana.no",
    "mosjoen.no",
    "mosj\xF8en.no",
    "nesoddtangen.no",
    "orkanger.no",
    "osoyro.no",
    "os\xF8yro.no",
    "raholt.no",
    "r\xE5holt.no",
    "sandnessjoen.no",
    "sandnessj\xF8en.no",
    "skedsmokorset.no",
    "slattum.no",
    "spjelkavik.no",
    "stathelle.no",
    "stavern.no",
    "stjordalshalsen.no",
    "stj\xF8rdalshalsen.no",
    "tananger.no",
    "tranby.no",
    "vossevangen.no",
    "afjord.no",
    "\xE5fjord.no",
    "agdenes.no",
    "al.no",
    "\xE5l.no",
    "alesund.no",
    "\xE5lesund.no",
    "alstahaug.no",
    "alta.no",
    "\xE1lt\xE1.no",
    "alaheadju.no",
    "\xE1laheadju.no",
    "alvdal.no",
    "amli.no",
    "\xE5mli.no",
    "amot.no",
    "\xE5mot.no",
    "andebu.no",
    "andoy.no",
    "and\xF8y.no",
    "andasuolo.no",
    "ardal.no",
    "\xE5rdal.no",
    "aremark.no",
    "arendal.no",
    "\xE5s.no",
    "aseral.no",
    "\xE5seral.no",
    "asker.no",
    "askim.no",
    "askvoll.no",
    "askoy.no",
    "ask\xF8y.no",
    "asnes.no",
    "\xE5snes.no",
    "audnedaln.no",
    "aukra.no",
    "aure.no",
    "aurland.no",
    "aurskog-holand.no",
    "aurskog-h\xF8land.no",
    "austevoll.no",
    "austrheim.no",
    "averoy.no",
    "aver\xF8y.no",
    "balestrand.no",
    "ballangen.no",
    "balat.no",
    "b\xE1l\xE1t.no",
    "balsfjord.no",
    "bahccavuotna.no",
    "b\xE1hccavuotna.no",
    "bamble.no",
    "bardu.no",
    "beardu.no",
    "beiarn.no",
    "bajddar.no",
    "b\xE1jddar.no",
    "baidar.no",
    "b\xE1id\xE1r.no",
    "berg.no",
    "bergen.no",
    "berlevag.no",
    "berlev\xE5g.no",
    "bearalvahki.no",
    "bearalv\xE1hki.no",
    "bindal.no",
    "birkenes.no",
    "bjarkoy.no",
    "bjark\xF8y.no",
    "bjerkreim.no",
    "bjugn.no",
    "bodo.no",
    "bod\xF8.no",
    "badaddja.no",
    "b\xE5d\xE5ddj\xE5.no",
    "budejju.no",
    "bokn.no",
    "bremanger.no",
    "bronnoy.no",
    "br\xF8nn\xF8y.no",
    "bygland.no",
    "bykle.no",
    "barum.no",
    "b\xE6rum.no",
    "bo.telemark.no",
    "b\xF8.telemark.no",
    "bo.nordland.no",
    "b\xF8.nordland.no",
    "bievat.no",
    "biev\xE1t.no",
    "bomlo.no",
    "b\xF8mlo.no",
    "batsfjord.no",
    "b\xE5tsfjord.no",
    "bahcavuotna.no",
    "b\xE1hcavuotna.no",
    "dovre.no",
    "drammen.no",
    "drangedal.no",
    "dyroy.no",
    "dyr\xF8y.no",
    "donna.no",
    "d\xF8nna.no",
    "eid.no",
    "eidfjord.no",
    "eidsberg.no",
    "eidskog.no",
    "eidsvoll.no",
    "eigersund.no",
    "elverum.no",
    "enebakk.no",
    "engerdal.no",
    "etne.no",
    "etnedal.no",
    "evenes.no",
    "evenassi.no",
    "even\xE1\u0161\u0161i.no",
    "evje-og-hornnes.no",
    "farsund.no",
    "fauske.no",
    "fuossko.no",
    "fuoisku.no",
    "fedje.no",
    "fet.no",
    "finnoy.no",
    "finn\xF8y.no",
    "fitjar.no",
    "fjaler.no",
    "fjell.no",
    "flakstad.no",
    "flatanger.no",
    "flekkefjord.no",
    "flesberg.no",
    "flora.no",
    "fla.no",
    "fl\xE5.no",
    "folldal.no",
    "forsand.no",
    "fosnes.no",
    "frei.no",
    "frogn.no",
    "froland.no",
    "frosta.no",
    "frana.no",
    "fr\xE6na.no",
    "froya.no",
    "fr\xF8ya.no",
    "fusa.no",
    "fyresdal.no",
    "forde.no",
    "f\xF8rde.no",
    "gamvik.no",
    "gangaviika.no",
    "g\xE1\u014Bgaviika.no",
    "gaular.no",
    "gausdal.no",
    "gildeskal.no",
    "gildesk\xE5l.no",
    "giske.no",
    "gjemnes.no",
    "gjerdrum.no",
    "gjerstad.no",
    "gjesdal.no",
    "gjovik.no",
    "gj\xF8vik.no",
    "gloppen.no",
    "gol.no",
    "gran.no",
    "grane.no",
    "granvin.no",
    "gratangen.no",
    "grimstad.no",
    "grong.no",
    "kraanghke.no",
    "kr\xE5anghke.no",
    "grue.no",
    "gulen.no",
    "hadsel.no",
    "halden.no",
    "halsa.no",
    "hamar.no",
    "hamaroy.no",
    "habmer.no",
    "h\xE1bmer.no",
    "hapmir.no",
    "h\xE1pmir.no",
    "hammerfest.no",
    "hammarfeasta.no",
    "h\xE1mm\xE1rfeasta.no",
    "haram.no",
    "hareid.no",
    "harstad.no",
    "hasvik.no",
    "aknoluokta.no",
    "\xE1k\u014Boluokta.no",
    "hattfjelldal.no",
    "aarborte.no",
    "haugesund.no",
    "hemne.no",
    "hemnes.no",
    "hemsedal.no",
    "heroy.more-og-romsdal.no",
    "her\xF8y.m\xF8re-og-romsdal.no",
    "heroy.nordland.no",
    "her\xF8y.nordland.no",
    "hitra.no",
    "hjartdal.no",
    "hjelmeland.no",
    "hobol.no",
    "hob\xF8l.no",
    "hof.no",
    "hol.no",
    "hole.no",
    "holmestrand.no",
    "holtalen.no",
    "holt\xE5len.no",
    "hornindal.no",
    "horten.no",
    "hurdal.no",
    "hurum.no",
    "hvaler.no",
    "hyllestad.no",
    "hagebostad.no",
    "h\xE6gebostad.no",
    "hoyanger.no",
    "h\xF8yanger.no",
    "hoylandet.no",
    "h\xF8ylandet.no",
    "ha.no",
    "h\xE5.no",
    "ibestad.no",
    "inderoy.no",
    "inder\xF8y.no",
    "iveland.no",
    "jevnaker.no",
    "jondal.no",
    "jolster.no",
    "j\xF8lster.no",
    "karasjok.no",
    "karasjohka.no",
    "k\xE1r\xE1\u0161johka.no",
    "karlsoy.no",
    "galsa.no",
    "g\xE1ls\xE1.no",
    "karmoy.no",
    "karm\xF8y.no",
    "kautokeino.no",
    "guovdageaidnu.no",
    "klepp.no",
    "klabu.no",
    "kl\xE6bu.no",
    "kongsberg.no",
    "kongsvinger.no",
    "kragero.no",
    "krager\xF8.no",
    "kristiansand.no",
    "kristiansund.no",
    "krodsherad.no",
    "kr\xF8dsherad.no",
    "kvalsund.no",
    "rahkkeravju.no",
    "r\xE1hkker\xE1vju.no",
    "kvam.no",
    "kvinesdal.no",
    "kvinnherad.no",
    "kviteseid.no",
    "kvitsoy.no",
    "kvits\xF8y.no",
    "kvafjord.no",
    "kv\xE6fjord.no",
    "giehtavuoatna.no",
    "kvanangen.no",
    "kv\xE6nangen.no",
    "navuotna.no",
    "n\xE1vuotna.no",
    "kafjord.no",
    "k\xE5fjord.no",
    "gaivuotna.no",
    "g\xE1ivuotna.no",
    "larvik.no",
    "lavangen.no",
    "lavagis.no",
    "loabat.no",
    "loab\xE1t.no",
    "lebesby.no",
    "davvesiida.no",
    "leikanger.no",
    "leirfjord.no",
    "leka.no",
    "leksvik.no",
    "lenvik.no",
    "leangaviika.no",
    "lea\u014Bgaviika.no",
    "lesja.no",
    "levanger.no",
    "lier.no",
    "lierne.no",
    "lillehammer.no",
    "lillesand.no",
    "lindesnes.no",
    "lindas.no",
    "lind\xE5s.no",
    "lom.no",
    "loppa.no",
    "lahppi.no",
    "l\xE1hppi.no",
    "lund.no",
    "lunner.no",
    "luroy.no",
    "lur\xF8y.no",
    "luster.no",
    "lyngdal.no",
    "lyngen.no",
    "ivgu.no",
    "lardal.no",
    "lerdal.no",
    "l\xE6rdal.no",
    "lodingen.no",
    "l\xF8dingen.no",
    "lorenskog.no",
    "l\xF8renskog.no",
    "loten.no",
    "l\xF8ten.no",
    "malvik.no",
    "masoy.no",
    "m\xE5s\xF8y.no",
    "muosat.no",
    "muos\xE1t.no",
    "mandal.no",
    "marker.no",
    "marnardal.no",
    "masfjorden.no",
    "meland.no",
    "meldal.no",
    "melhus.no",
    "meloy.no",
    "mel\xF8y.no",
    "meraker.no",
    "mer\xE5ker.no",
    "moareke.no",
    "mo\xE5reke.no",
    "midsund.no",
    "midtre-gauldal.no",
    "modalen.no",
    "modum.no",
    "molde.no",
    "moskenes.no",
    "moss.no",
    "mosvik.no",
    "malselv.no",
    "m\xE5lselv.no",
    "malatvuopmi.no",
    "m\xE1latvuopmi.no",
    "namdalseid.no",
    "aejrie.no",
    "namsos.no",
    "namsskogan.no",
    "naamesjevuemie.no",
    "n\xE5\xE5mesjevuemie.no",
    "laakesvuemie.no",
    "nannestad.no",
    "narvik.no",
    "narviika.no",
    "naustdal.no",
    "nedre-eiker.no",
    "nes.akershus.no",
    "nes.buskerud.no",
    "nesna.no",
    "nesodden.no",
    "nesseby.no",
    "unjarga.no",
    "unj\xE1rga.no",
    "nesset.no",
    "nissedal.no",
    "nittedal.no",
    "nord-aurdal.no",
    "nord-fron.no",
    "nord-odal.no",
    "norddal.no",
    "nordkapp.no",
    "davvenjarga.no",
    "davvenj\xE1rga.no",
    "nordre-land.no",
    "nordreisa.no",
    "raisa.no",
    "r\xE1isa.no",
    "nore-og-uvdal.no",
    "notodden.no",
    "naroy.no",
    "n\xE6r\xF8y.no",
    "notteroy.no",
    "n\xF8tter\xF8y.no",
    "odda.no",
    "oksnes.no",
    "\xF8ksnes.no",
    "oppdal.no",
    "oppegard.no",
    "oppeg\xE5rd.no",
    "orkdal.no",
    "orland.no",
    "\xF8rland.no",
    "orskog.no",
    "\xF8rskog.no",
    "orsta.no",
    "\xF8rsta.no",
    "os.hedmark.no",
    "os.hordaland.no",
    "osen.no",
    "osteroy.no",
    "oster\xF8y.no",
    "ostre-toten.no",
    "\xF8stre-toten.no",
    "overhalla.no",
    "ovre-eiker.no",
    "\xF8vre-eiker.no",
    "oyer.no",
    "\xF8yer.no",
    "oygarden.no",
    "\xF8ygarden.no",
    "oystre-slidre.no",
    "\xF8ystre-slidre.no",
    "porsanger.no",
    "porsangu.no",
    "pors\xE1\u014Bgu.no",
    "porsgrunn.no",
    "radoy.no",
    "rad\xF8y.no",
    "rakkestad.no",
    "rana.no",
    "ruovat.no",
    "randaberg.no",
    "rauma.no",
    "rendalen.no",
    "rennebu.no",
    "rennesoy.no",
    "rennes\xF8y.no",
    "rindal.no",
    "ringebu.no",
    "ringerike.no",
    "ringsaker.no",
    "rissa.no",
    "risor.no",
    "ris\xF8r.no",
    "roan.no",
    "rollag.no",
    "rygge.no",
    "ralingen.no",
    "r\xE6lingen.no",
    "rodoy.no",
    "r\xF8d\xF8y.no",
    "romskog.no",
    "r\xF8mskog.no",
    "roros.no",
    "r\xF8ros.no",
    "rost.no",
    "r\xF8st.no",
    "royken.no",
    "r\xF8yken.no",
    "royrvik.no",
    "r\xF8yrvik.no",
    "rade.no",
    "r\xE5de.no",
    "salangen.no",
    "siellak.no",
    "saltdal.no",
    "salat.no",
    "s\xE1l\xE1t.no",
    "s\xE1lat.no",
    "samnanger.no",
    "sande.more-og-romsdal.no",
    "sande.m\xF8re-og-romsdal.no",
    "sande.vestfold.no",
    "sandefjord.no",
    "sandnes.no",
    "sandoy.no",
    "sand\xF8y.no",
    "sarpsborg.no",
    "sauda.no",
    "sauherad.no",
    "sel.no",
    "selbu.no",
    "selje.no",
    "seljord.no",
    "sigdal.no",
    "siljan.no",
    "sirdal.no",
    "skaun.no",
    "skedsmo.no",
    "ski.no",
    "skien.no",
    "skiptvet.no",
    "skjervoy.no",
    "skjerv\xF8y.no",
    "skierva.no",
    "skierv\xE1.no",
    "skjak.no",
    "skj\xE5k.no",
    "skodje.no",
    "skanland.no",
    "sk\xE5nland.no",
    "skanit.no",
    "sk\xE1nit.no",
    "smola.no",
    "sm\xF8la.no",
    "snillfjord.no",
    "snasa.no",
    "sn\xE5sa.no",
    "snoasa.no",
    "snaase.no",
    "sn\xE5ase.no",
    "sogndal.no",
    "sokndal.no",
    "sola.no",
    "solund.no",
    "songdalen.no",
    "sortland.no",
    "spydeberg.no",
    "stange.no",
    "stavanger.no",
    "steigen.no",
    "steinkjer.no",
    "stjordal.no",
    "stj\xF8rdal.no",
    "stokke.no",
    "stor-elvdal.no",
    "stord.no",
    "stordal.no",
    "storfjord.no",
    "omasvuotna.no",
    "strand.no",
    "stranda.no",
    "stryn.no",
    "sula.no",
    "suldal.no",
    "sund.no",
    "sunndal.no",
    "surnadal.no",
    "sveio.no",
    "svelvik.no",
    "sykkylven.no",
    "sogne.no",
    "s\xF8gne.no",
    "somna.no",
    "s\xF8mna.no",
    "sondre-land.no",
    "s\xF8ndre-land.no",
    "sor-aurdal.no",
    "s\xF8r-aurdal.no",
    "sor-fron.no",
    "s\xF8r-fron.no",
    "sor-odal.no",
    "s\xF8r-odal.no",
    "sor-varanger.no",
    "s\xF8r-varanger.no",
    "matta-varjjat.no",
    "m\xE1tta-v\xE1rjjat.no",
    "sorfold.no",
    "s\xF8rfold.no",
    "sorreisa.no",
    "s\xF8rreisa.no",
    "sorum.no",
    "s\xF8rum.no",
    "tana.no",
    "deatnu.no",
    "time.no",
    "tingvoll.no",
    "tinn.no",
    "tjeldsund.no",
    "dielddanuorri.no",
    "tjome.no",
    "tj\xF8me.no",
    "tokke.no",
    "tolga.no",
    "torsken.no",
    "tranoy.no",
    "tran\xF8y.no",
    "tromso.no",
    "troms\xF8.no",
    "tromsa.no",
    "romsa.no",
    "trondheim.no",
    "troandin.no",
    "trysil.no",
    "trana.no",
    "tr\xE6na.no",
    "trogstad.no",
    "tr\xF8gstad.no",
    "tvedestrand.no",
    "tydal.no",
    "tynset.no",
    "tysfjord.no",
    "divtasvuodna.no",
    "divttasvuotna.no",
    "tysnes.no",
    "tysvar.no",
    "tysv\xE6r.no",
    "tonsberg.no",
    "t\xF8nsberg.no",
    "ullensaker.no",
    "ullensvang.no",
    "ulvik.no",
    "utsira.no",
    "vadso.no",
    "vads\xF8.no",
    "cahcesuolo.no",
    "\u010D\xE1hcesuolo.no",
    "vaksdal.no",
    "valle.no",
    "vang.no",
    "vanylven.no",
    "vardo.no",
    "vard\xF8.no",
    "varggat.no",
    "v\xE1rgg\xE1t.no",
    "vefsn.no",
    "vaapste.no",
    "vega.no",
    "vegarshei.no",
    "veg\xE5rshei.no",
    "vennesla.no",
    "verdal.no",
    "verran.no",
    "vestby.no",
    "vestnes.no",
    "vestre-slidre.no",
    "vestre-toten.no",
    "vestvagoy.no",
    "vestv\xE5g\xF8y.no",
    "vevelstad.no",
    "vik.no",
    "vikna.no",
    "vindafjord.no",
    "volda.no",
    "voss.no",
    "varoy.no",
    "v\xE6r\xF8y.no",
    "vagan.no",
    "v\xE5gan.no",
    "voagat.no",
    "vagsoy.no",
    "v\xE5gs\xF8y.no",
    "vaga.no",
    "v\xE5g\xE5.no",
    "valer.ostfold.no",
    "v\xE5ler.\xF8stfold.no",
    "valer.hedmark.no",
    "v\xE5ler.hedmark.no",
    "*.np",
    "nr",
    "biz.nr",
    "info.nr",
    "gov.nr",
    "edu.nr",
    "org.nr",
    "net.nr",
    "com.nr",
    "nu",
    "nz",
    "ac.nz",
    "co.nz",
    "cri.nz",
    "geek.nz",
    "gen.nz",
    "govt.nz",
    "health.nz",
    "iwi.nz",
    "kiwi.nz",
    "maori.nz",
    "mil.nz",
    "m\u0101ori.nz",
    "net.nz",
    "org.nz",
    "parliament.nz",
    "school.nz",
    "om",
    "co.om",
    "com.om",
    "edu.om",
    "gov.om",
    "med.om",
    "museum.om",
    "net.om",
    "org.om",
    "pro.om",
    "onion",
    "org",
    "pa",
    "ac.pa",
    "gob.pa",
    "com.pa",
    "org.pa",
    "sld.pa",
    "edu.pa",
    "net.pa",
    "ing.pa",
    "abo.pa",
    "med.pa",
    "nom.pa",
    "pe",
    "edu.pe",
    "gob.pe",
    "nom.pe",
    "mil.pe",
    "org.pe",
    "com.pe",
    "net.pe",
    "pf",
    "com.pf",
    "org.pf",
    "edu.pf",
    "*.pg",
    "ph",
    "com.ph",
    "net.ph",
    "org.ph",
    "gov.ph",
    "edu.ph",
    "ngo.ph",
    "mil.ph",
    "i.ph",
    "pk",
    "com.pk",
    "net.pk",
    "edu.pk",
    "org.pk",
    "fam.pk",
    "biz.pk",
    "web.pk",
    "gov.pk",
    "gob.pk",
    "gok.pk",
    "gon.pk",
    "gop.pk",
    "gos.pk",
    "info.pk",
    "pl",
    "com.pl",
    "net.pl",
    "org.pl",
    "aid.pl",
    "agro.pl",
    "atm.pl",
    "auto.pl",
    "biz.pl",
    "edu.pl",
    "gmina.pl",
    "gsm.pl",
    "info.pl",
    "mail.pl",
    "miasta.pl",
    "media.pl",
    "mil.pl",
    "nieruchomosci.pl",
    "nom.pl",
    "pc.pl",
    "powiat.pl",
    "priv.pl",
    "realestate.pl",
    "rel.pl",
    "sex.pl",
    "shop.pl",
    "sklep.pl",
    "sos.pl",
    "szkola.pl",
    "targi.pl",
    "tm.pl",
    "tourism.pl",
    "travel.pl",
    "turystyka.pl",
    "gov.pl",
    "ap.gov.pl",
    "ic.gov.pl",
    "is.gov.pl",
    "us.gov.pl",
    "kmpsp.gov.pl",
    "kppsp.gov.pl",
    "kwpsp.gov.pl",
    "psp.gov.pl",
    "wskr.gov.pl",
    "kwp.gov.pl",
    "mw.gov.pl",
    "ug.gov.pl",
    "um.gov.pl",
    "umig.gov.pl",
    "ugim.gov.pl",
    "upow.gov.pl",
    "uw.gov.pl",
    "starostwo.gov.pl",
    "pa.gov.pl",
    "po.gov.pl",
    "psse.gov.pl",
    "pup.gov.pl",
    "rzgw.gov.pl",
    "sa.gov.pl",
    "so.gov.pl",
    "sr.gov.pl",
    "wsa.gov.pl",
    "sko.gov.pl",
    "uzs.gov.pl",
    "wiih.gov.pl",
    "winb.gov.pl",
    "pinb.gov.pl",
    "wios.gov.pl",
    "witd.gov.pl",
    "wzmiuw.gov.pl",
    "piw.gov.pl",
    "wiw.gov.pl",
    "griw.gov.pl",
    "wif.gov.pl",
    "oum.gov.pl",
    "sdn.gov.pl",
    "zp.gov.pl",
    "uppo.gov.pl",
    "mup.gov.pl",
    "wuoz.gov.pl",
    "konsulat.gov.pl",
    "oirm.gov.pl",
    "augustow.pl",
    "babia-gora.pl",
    "bedzin.pl",
    "beskidy.pl",
    "bialowieza.pl",
    "bialystok.pl",
    "bielawa.pl",
    "bieszczady.pl",
    "boleslawiec.pl",
    "bydgoszcz.pl",
    "bytom.pl",
    "cieszyn.pl",
    "czeladz.pl",
    "czest.pl",
    "dlugoleka.pl",
    "elblag.pl",
    "elk.pl",
    "glogow.pl",
    "gniezno.pl",
    "gorlice.pl",
    "grajewo.pl",
    "ilawa.pl",
    "jaworzno.pl",
    "jelenia-gora.pl",
    "jgora.pl",
    "kalisz.pl",
    "kazimierz-dolny.pl",
    "karpacz.pl",
    "kartuzy.pl",
    "kaszuby.pl",
    "katowice.pl",
    "kepno.pl",
    "ketrzyn.pl",
    "klodzko.pl",
    "kobierzyce.pl",
    "kolobrzeg.pl",
    "konin.pl",
    "konskowola.pl",
    "kutno.pl",
    "lapy.pl",
    "lebork.pl",
    "legnica.pl",
    "lezajsk.pl",
    "limanowa.pl",
    "lomza.pl",
    "lowicz.pl",
    "lubin.pl",
    "lukow.pl",
    "malbork.pl",
    "malopolska.pl",
    "mazowsze.pl",
    "mazury.pl",
    "mielec.pl",
    "mielno.pl",
    "mragowo.pl",
    "naklo.pl",
    "nowaruda.pl",
    "nysa.pl",
    "olawa.pl",
    "olecko.pl",
    "olkusz.pl",
    "olsztyn.pl",
    "opoczno.pl",
    "opole.pl",
    "ostroda.pl",
    "ostroleka.pl",
    "ostrowiec.pl",
    "ostrowwlkp.pl",
    "pila.pl",
    "pisz.pl",
    "podhale.pl",
    "podlasie.pl",
    "polkowice.pl",
    "pomorze.pl",
    "pomorskie.pl",
    "prochowice.pl",
    "pruszkow.pl",
    "przeworsk.pl",
    "pulawy.pl",
    "radom.pl",
    "rawa-maz.pl",
    "rybnik.pl",
    "rzeszow.pl",
    "sanok.pl",
    "sejny.pl",
    "slask.pl",
    "slupsk.pl",
    "sosnowiec.pl",
    "stalowa-wola.pl",
    "skoczow.pl",
    "starachowice.pl",
    "stargard.pl",
    "suwalki.pl",
    "swidnica.pl",
    "swiebodzin.pl",
    "swinoujscie.pl",
    "szczecin.pl",
    "szczytno.pl",
    "tarnobrzeg.pl",
    "tgory.pl",
    "turek.pl",
    "tychy.pl",
    "ustka.pl",
    "walbrzych.pl",
    "warmia.pl",
    "warszawa.pl",
    "waw.pl",
    "wegrow.pl",
    "wielun.pl",
    "wlocl.pl",
    "wloclawek.pl",
    "wodzislaw.pl",
    "wolomin.pl",
    "wroclaw.pl",
    "zachpomor.pl",
    "zagan.pl",
    "zarow.pl",
    "zgora.pl",
    "zgorzelec.pl",
    "pm",
    "pn",
    "gov.pn",
    "co.pn",
    "org.pn",
    "edu.pn",
    "net.pn",
    "post",
    "pr",
    "com.pr",
    "net.pr",
    "org.pr",
    "gov.pr",
    "edu.pr",
    "isla.pr",
    "pro.pr",
    "biz.pr",
    "info.pr",
    "name.pr",
    "est.pr",
    "prof.pr",
    "ac.pr",
    "pro",
    "aaa.pro",
    "aca.pro",
    "acct.pro",
    "avocat.pro",
    "bar.pro",
    "cpa.pro",
    "eng.pro",
    "jur.pro",
    "law.pro",
    "med.pro",
    "recht.pro",
    "ps",
    "edu.ps",
    "gov.ps",
    "sec.ps",
    "plo.ps",
    "com.ps",
    "org.ps",
    "net.ps",
    "pt",
    "net.pt",
    "gov.pt",
    "org.pt",
    "edu.pt",
    "int.pt",
    "publ.pt",
    "com.pt",
    "nome.pt",
    "pw",
    "co.pw",
    "ne.pw",
    "or.pw",
    "ed.pw",
    "go.pw",
    "belau.pw",
    "py",
    "com.py",
    "coop.py",
    "edu.py",
    "gov.py",
    "mil.py",
    "net.py",
    "org.py",
    "qa",
    "com.qa",
    "edu.qa",
    "gov.qa",
    "mil.qa",
    "name.qa",
    "net.qa",
    "org.qa",
    "sch.qa",
    "re",
    "asso.re",
    "com.re",
    "nom.re",
    "ro",
    "arts.ro",
    "com.ro",
    "firm.ro",
    "info.ro",
    "nom.ro",
    "nt.ro",
    "org.ro",
    "rec.ro",
    "store.ro",
    "tm.ro",
    "www.ro",
    "rs",
    "ac.rs",
    "co.rs",
    "edu.rs",
    "gov.rs",
    "in.rs",
    "org.rs",
    "ru",
    "ac.ru",
    "edu.ru",
    "gov.ru",
    "int.ru",
    "mil.ru",
    "test.ru",
    "rw",
    "ac.rw",
    "co.rw",
    "coop.rw",
    "gov.rw",
    "mil.rw",
    "net.rw",
    "org.rw",
    "sa",
    "com.sa",
    "net.sa",
    "org.sa",
    "gov.sa",
    "med.sa",
    "pub.sa",
    "edu.sa",
    "sch.sa",
    "sb",
    "com.sb",
    "edu.sb",
    "gov.sb",
    "net.sb",
    "org.sb",
    "sc",
    "com.sc",
    "gov.sc",
    "net.sc",
    "org.sc",
    "edu.sc",
    "sd",
    "com.sd",
    "net.sd",
    "org.sd",
    "edu.sd",
    "med.sd",
    "tv.sd",
    "gov.sd",
    "info.sd",
    "se",
    "a.se",
    "ac.se",
    "b.se",
    "bd.se",
    "brand.se",
    "c.se",
    "d.se",
    "e.se",
    "f.se",
    "fh.se",
    "fhsk.se",
    "fhv.se",
    "g.se",
    "h.se",
    "i.se",
    "k.se",
    "komforb.se",
    "kommunalforbund.se",
    "komvux.se",
    "l.se",
    "lanbib.se",
    "m.se",
    "n.se",
    "naturbruksgymn.se",
    "o.se",
    "org.se",
    "p.se",
    "parti.se",
    "pp.se",
    "press.se",
    "r.se",
    "s.se",
    "t.se",
    "tm.se",
    "u.se",
    "w.se",
    "x.se",
    "y.se",
    "z.se",
    "sg",
    "com.sg",
    "net.sg",
    "org.sg",
    "gov.sg",
    "edu.sg",
    "per.sg",
    "sh",
    "com.sh",
    "net.sh",
    "gov.sh",
    "org.sh",
    "mil.sh",
    "si",
    "sj",
    "sk",
    "sl",
    "com.sl",
    "net.sl",
    "edu.sl",
    "gov.sl",
    "org.sl",
    "sm",
    "sn",
    "art.sn",
    "com.sn",
    "edu.sn",
    "gouv.sn",
    "org.sn",
    "perso.sn",
    "univ.sn",
    "so",
    "com.so",
    "net.so",
    "org.so",
    "sr",
    "st",
    "co.st",
    "com.st",
    "consulado.st",
    "edu.st",
    "embaixada.st",
    "gov.st",
    "mil.st",
    "net.st",
    "org.st",
    "principe.st",
    "saotome.st",
    "store.st",
    "su",
    "sv",
    "com.sv",
    "edu.sv",
    "gob.sv",
    "org.sv",
    "red.sv",
    "sx",
    "gov.sx",
    "sy",
    "edu.sy",
    "gov.sy",
    "net.sy",
    "mil.sy",
    "com.sy",
    "org.sy",
    "sz",
    "co.sz",
    "ac.sz",
    "org.sz",
    "tc",
    "td",
    "tel",
    "tf",
    "tg",
    "th",
    "ac.th",
    "co.th",
    "go.th",
    "in.th",
    "mi.th",
    "net.th",
    "or.th",
    "tj",
    "ac.tj",
    "biz.tj",
    "co.tj",
    "com.tj",
    "edu.tj",
    "go.tj",
    "gov.tj",
    "int.tj",
    "mil.tj",
    "name.tj",
    "net.tj",
    "nic.tj",
    "org.tj",
    "test.tj",
    "web.tj",
    "tk",
    "tl",
    "gov.tl",
    "tm",
    "com.tm",
    "co.tm",
    "org.tm",
    "net.tm",
    "nom.tm",
    "gov.tm",
    "mil.tm",
    "edu.tm",
    "tn",
    "com.tn",
    "ens.tn",
    "fin.tn",
    "gov.tn",
    "ind.tn",
    "intl.tn",
    "nat.tn",
    "net.tn",
    "org.tn",
    "info.tn",
    "perso.tn",
    "tourism.tn",
    "edunet.tn",
    "rnrt.tn",
    "rns.tn",
    "rnu.tn",
    "mincom.tn",
    "agrinet.tn",
    "defense.tn",
    "turen.tn",
    "to",
    "com.to",
    "gov.to",
    "net.to",
    "org.to",
    "edu.to",
    "mil.to",
    "tr",
    "av.tr",
    "bbs.tr",
    "bel.tr",
    "biz.tr",
    "com.tr",
    "dr.tr",
    "edu.tr",
    "gen.tr",
    "gov.tr",
    "info.tr",
    "mil.tr",
    "k12.tr",
    "kep.tr",
    "name.tr",
    "net.tr",
    "org.tr",
    "pol.tr",
    "tel.tr",
    "tsk.tr",
    "tv.tr",
    "web.tr",
    "nc.tr",
    "gov.nc.tr",
    "tt",
    "co.tt",
    "com.tt",
    "org.tt",
    "net.tt",
    "biz.tt",
    "info.tt",
    "pro.tt",
    "int.tt",
    "coop.tt",
    "jobs.tt",
    "mobi.tt",
    "travel.tt",
    "museum.tt",
    "aero.tt",
    "name.tt",
    "gov.tt",
    "edu.tt",
    "tv",
    "tw",
    "edu.tw",
    "gov.tw",
    "mil.tw",
    "com.tw",
    "net.tw",
    "org.tw",
    "idv.tw",
    "game.tw",
    "ebiz.tw",
    "club.tw",
    "\u7DB2\u8DEF.tw",
    "\u7D44\u7E54.tw",
    "\u5546\u696D.tw",
    "tz",
    "ac.tz",
    "co.tz",
    "go.tz",
    "hotel.tz",
    "info.tz",
    "me.tz",
    "mil.tz",
    "mobi.tz",
    "ne.tz",
    "or.tz",
    "sc.tz",
    "tv.tz",
    "ua",
    "com.ua",
    "edu.ua",
    "gov.ua",
    "in.ua",
    "net.ua",
    "org.ua",
    "cherkassy.ua",
    "cherkasy.ua",
    "chernigov.ua",
    "chernihiv.ua",
    "chernivtsi.ua",
    "chernovtsy.ua",
    "ck.ua",
    "cn.ua",
    "cr.ua",
    "crimea.ua",
    "cv.ua",
    "dn.ua",
    "dnepropetrovsk.ua",
    "dnipropetrovsk.ua",
    "dominic.ua",
    "donetsk.ua",
    "dp.ua",
    "if.ua",
    "ivano-frankivsk.ua",
    "kh.ua",
    "kharkiv.ua",
    "kharkov.ua",
    "kherson.ua",
    "khmelnitskiy.ua",
    "khmelnytskyi.ua",
    "kiev.ua",
    "kirovograd.ua",
    "km.ua",
    "kr.ua",
    "krym.ua",
    "ks.ua",
    "kv.ua",
    "kyiv.ua",
    "lg.ua",
    "lt.ua",
    "lugansk.ua",
    "lutsk.ua",
    "lv.ua",
    "lviv.ua",
    "mk.ua",
    "mykolaiv.ua",
    "nikolaev.ua",
    "od.ua",
    "odesa.ua",
    "odessa.ua",
    "pl.ua",
    "poltava.ua",
    "rivne.ua",
    "rovno.ua",
    "rv.ua",
    "sb.ua",
    "sebastopol.ua",
    "sevastopol.ua",
    "sm.ua",
    "sumy.ua",
    "te.ua",
    "ternopil.ua",
    "uz.ua",
    "uzhgorod.ua",
    "vinnica.ua",
    "vinnytsia.ua",
    "vn.ua",
    "volyn.ua",
    "yalta.ua",
    "zaporizhzhe.ua",
    "zaporizhzhia.ua",
    "zhitomir.ua",
    "zhytomyr.ua",
    "zp.ua",
    "zt.ua",
    "ug",
    "co.ug",
    "or.ug",
    "ac.ug",
    "sc.ug",
    "go.ug",
    "ne.ug",
    "com.ug",
    "org.ug",
    "uk",
    "ac.uk",
    "co.uk",
    "gov.uk",
    "ltd.uk",
    "me.uk",
    "net.uk",
    "nhs.uk",
    "org.uk",
    "plc.uk",
    "police.uk",
    "*.sch.uk",
    "us",
    "dni.us",
    "fed.us",
    "isa.us",
    "kids.us",
    "nsn.us",
    "ak.us",
    "al.us",
    "ar.us",
    "as.us",
    "az.us",
    "ca.us",
    "co.us",
    "ct.us",
    "dc.us",
    "de.us",
    "fl.us",
    "ga.us",
    "gu.us",
    "hi.us",
    "ia.us",
    "id.us",
    "il.us",
    "in.us",
    "ks.us",
    "ky.us",
    "la.us",
    "ma.us",
    "md.us",
    "me.us",
    "mi.us",
    "mn.us",
    "mo.us",
    "ms.us",
    "mt.us",
    "nc.us",
    "nd.us",
    "ne.us",
    "nh.us",
    "nj.us",
    "nm.us",
    "nv.us",
    "ny.us",
    "oh.us",
    "ok.us",
    "or.us",
    "pa.us",
    "pr.us",
    "ri.us",
    "sc.us",
    "sd.us",
    "tn.us",
    "tx.us",
    "ut.us",
    "vi.us",
    "vt.us",
    "va.us",
    "wa.us",
    "wi.us",
    "wv.us",
    "wy.us",
    "k12.ak.us",
    "k12.al.us",
    "k12.ar.us",
    "k12.as.us",
    "k12.az.us",
    "k12.ca.us",
    "k12.co.us",
    "k12.ct.us",
    "k12.dc.us",
    "k12.de.us",
    "k12.fl.us",
    "k12.ga.us",
    "k12.gu.us",
    "k12.ia.us",
    "k12.id.us",
    "k12.il.us",
    "k12.in.us",
    "k12.ks.us",
    "k12.ky.us",
    "k12.la.us",
    "k12.ma.us",
    "k12.md.us",
    "k12.me.us",
    "k12.mi.us",
    "k12.mn.us",
    "k12.mo.us",
    "k12.ms.us",
    "k12.mt.us",
    "k12.nc.us",
    "k12.ne.us",
    "k12.nh.us",
    "k12.nj.us",
    "k12.nm.us",
    "k12.nv.us",
    "k12.ny.us",
    "k12.oh.us",
    "k12.ok.us",
    "k12.or.us",
    "k12.pa.us",
    "k12.pr.us",
    "k12.ri.us",
    "k12.sc.us",
    "k12.tn.us",
    "k12.tx.us",
    "k12.ut.us",
    "k12.vi.us",
    "k12.vt.us",
    "k12.va.us",
    "k12.wa.us",
    "k12.wi.us",
    "k12.wy.us",
    "cc.ak.us",
    "cc.al.us",
    "cc.ar.us",
    "cc.as.us",
    "cc.az.us",
    "cc.ca.us",
    "cc.co.us",
    "cc.ct.us",
    "cc.dc.us",
    "cc.de.us",
    "cc.fl.us",
    "cc.ga.us",
    "cc.gu.us",
    "cc.hi.us",
    "cc.ia.us",
    "cc.id.us",
    "cc.il.us",
    "cc.in.us",
    "cc.ks.us",
    "cc.ky.us",
    "cc.la.us",
    "cc.ma.us",
    "cc.md.us",
    "cc.me.us",
    "cc.mi.us",
    "cc.mn.us",
    "cc.mo.us",
    "cc.ms.us",
    "cc.mt.us",
    "cc.nc.us",
    "cc.nd.us",
    "cc.ne.us",
    "cc.nh.us",
    "cc.nj.us",
    "cc.nm.us",
    "cc.nv.us",
    "cc.ny.us",
    "cc.oh.us",
    "cc.ok.us",
    "cc.or.us",
    "cc.pa.us",
    "cc.pr.us",
    "cc.ri.us",
    "cc.sc.us",
    "cc.sd.us",
    "cc.tn.us",
    "cc.tx.us",
    "cc.ut.us",
    "cc.vi.us",
    "cc.vt.us",
    "cc.va.us",
    "cc.wa.us",
    "cc.wi.us",
    "cc.wv.us",
    "cc.wy.us",
    "lib.ak.us",
    "lib.al.us",
    "lib.ar.us",
    "lib.as.us",
    "lib.az.us",
    "lib.ca.us",
    "lib.co.us",
    "lib.ct.us",
    "lib.dc.us",
    "lib.fl.us",
    "lib.ga.us",
    "lib.gu.us",
    "lib.hi.us",
    "lib.ia.us",
    "lib.id.us",
    "lib.il.us",
    "lib.in.us",
    "lib.ks.us",
    "lib.ky.us",
    "lib.la.us",
    "lib.ma.us",
    "lib.md.us",
    "lib.me.us",
    "lib.mi.us",
    "lib.mn.us",
    "lib.mo.us",
    "lib.ms.us",
    "lib.mt.us",
    "lib.nc.us",
    "lib.nd.us",
    "lib.ne.us",
    "lib.nh.us",
    "lib.nj.us",
    "lib.nm.us",
    "lib.nv.us",
    "lib.ny.us",
    "lib.oh.us",
    "lib.ok.us",
    "lib.or.us",
    "lib.pa.us",
    "lib.pr.us",
    "lib.ri.us",
    "lib.sc.us",
    "lib.sd.us",
    "lib.tn.us",
    "lib.tx.us",
    "lib.ut.us",
    "lib.vi.us",
    "lib.vt.us",
    "lib.va.us",
    "lib.wa.us",
    "lib.wi.us",
    "lib.wy.us",
    "pvt.k12.ma.us",
    "chtr.k12.ma.us",
    "paroch.k12.ma.us",
    "ann-arbor.mi.us",
    "cog.mi.us",
    "dst.mi.us",
    "eaton.mi.us",
    "gen.mi.us",
    "mus.mi.us",
    "tec.mi.us",
    "washtenaw.mi.us",
    "uy",
    "com.uy",
    "edu.uy",
    "gub.uy",
    "mil.uy",
    "net.uy",
    "org.uy",
    "uz",
    "co.uz",
    "com.uz",
    "net.uz",
    "org.uz",
    "va",
    "vc",
    "com.vc",
    "net.vc",
    "org.vc",
    "gov.vc",
    "mil.vc",
    "edu.vc",
    "ve",
    "arts.ve",
    "co.ve",
    "com.ve",
    "e12.ve",
    "edu.ve",
    "firm.ve",
    "gob.ve",
    "gov.ve",
    "info.ve",
    "int.ve",
    "mil.ve",
    "net.ve",
    "org.ve",
    "rec.ve",
    "store.ve",
    "tec.ve",
    "web.ve",
    "vg",
    "vi",
    "co.vi",
    "com.vi",
    "k12.vi",
    "net.vi",
    "org.vi",
    "vn",
    "com.vn",
    "net.vn",
    "org.vn",
    "edu.vn",
    "gov.vn",
    "int.vn",
    "ac.vn",
    "biz.vn",
    "info.vn",
    "name.vn",
    "pro.vn",
    "health.vn",
    "vu",
    "com.vu",
    "edu.vu",
    "net.vu",
    "org.vu",
    "wf",
    "ws",
    "com.ws",
    "net.ws",
    "org.ws",
    "gov.ws",
    "edu.ws",
    "yt",
    "\u0627\u0645\u0627\u0631\u0627\u062A",
    "\u0570\u0561\u0575",
    "\u09AC\u09BE\u0982\u09B2\u09BE",
    "\u0431\u0433",
    "\u0431\u0435\u043B",
    "\u4E2D\u56FD",
    "\u4E2D\u570B",
    "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
    "\u0645\u0635\u0631",
    "\u0435\u044E",
    "\u10D2\u10D4",
    "\u03B5\u03BB",
    "\u9999\u6E2F",
    "\u516C\u53F8.\u9999\u6E2F",
    "\u6559\u80B2.\u9999\u6E2F",
    "\u653F\u5E9C.\u9999\u6E2F",
    "\u500B\u4EBA.\u9999\u6E2F",
    "\u7DB2\u7D61.\u9999\u6E2F",
    "\u7D44\u7E54.\u9999\u6E2F",
    "\u0CAD\u0CBE\u0CB0\u0CA4",
    "\u0B2D\u0B3E\u0B30\u0B24",
    "\u09AD\u09BE\u09F0\u09A4",
    "\u092D\u093E\u0930\u0924\u092E\u094D",
    "\u092D\u093E\u0930\u094B\u0924",
    "\u0680\u0627\u0631\u062A",
    "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
    "\u092D\u093E\u0930\u0924",
    "\u0628\u0627\u0631\u062A",
    "\u0628\u06BE\u0627\u0631\u062A",
    "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
    "\u0AAD\u0ABE\u0AB0\u0AA4",
    "\u0A2D\u0A3E\u0A30\u0A24",
    "\u09AD\u09BE\u09B0\u09A4",
    "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
    "\u0627\u06CC\u0631\u0627\u0646",
    "\u0627\u064A\u0631\u0627\u0646",
    "\u0639\u0631\u0627\u0642",
    "\u0627\u0644\u0627\u0631\u062F\u0646",
    "\uD55C\uAD6D",
    "\u049B\u0430\u0437",
    "\u0DBD\u0D82\u0D9A\u0DCF",
    "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
    "\u0627\u0644\u0645\u063A\u0631\u0628",
    "\u043C\u043A\u0434",
    "\u043C\u043E\u043D",
    "\u6FB3\u9580",
    "\u6FB3\u95E8",
    "\u0645\u0644\u064A\u0633\u064A\u0627",
    "\u0639\u0645\u0627\u0646",
    "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
    "\u067E\u0627\u0643\u0633\u062A\u0627\u0646",
    "\u0641\u0644\u0633\u0637\u064A\u0646",
    "\u0441\u0440\u0431",
    "\u043F\u0440.\u0441\u0440\u0431",
    "\u043E\u0440\u0433.\u0441\u0440\u0431",
    "\u043E\u0431\u0440.\u0441\u0440\u0431",
    "\u043E\u0434.\u0441\u0440\u0431",
    "\u0443\u043F\u0440.\u0441\u0440\u0431",
    "\u0430\u043A.\u0441\u0440\u0431",
    "\u0440\u0444",
    "\u0642\u0637\u0631",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u0629",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u06C3",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0647",
    "\u0633\u0648\u062F\u0627\u0646",
    "\u65B0\u52A0\u5761",
    "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
    "\u0633\u0648\u0631\u064A\u0629",
    "\u0633\u0648\u0631\u064A\u0627",
    "\u0E44\u0E17\u0E22",
    "\u0E28\u0E36\u0E01\u0E29\u0E32.\u0E44\u0E17\u0E22",
    "\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08.\u0E44\u0E17\u0E22",
    "\u0E23\u0E31\u0E10\u0E1A\u0E32\u0E25.\u0E44\u0E17\u0E22",
    "\u0E17\u0E2B\u0E32\u0E23.\u0E44\u0E17\u0E22",
    "\u0E40\u0E19\u0E47\u0E15.\u0E44\u0E17\u0E22",
    "\u0E2D\u0E07\u0E04\u0E4C\u0E01\u0E23.\u0E44\u0E17\u0E22",
    "\u062A\u0648\u0646\u0633",
    "\u53F0\u7063",
    "\u53F0\u6E7E",
    "\u81FA\u7063",
    "\u0443\u043A\u0440",
    "\u0627\u0644\u064A\u0645\u0646",
    "xxx",
    "*.ye",
    "ac.za",
    "agric.za",
    "alt.za",
    "co.za",
    "edu.za",
    "gov.za",
    "grondar.za",
    "law.za",
    "mil.za",
    "net.za",
    "ngo.za",
    "nic.za",
    "nis.za",
    "nom.za",
    "org.za",
    "school.za",
    "tm.za",
    "web.za",
    "zm",
    "ac.zm",
    "biz.zm",
    "co.zm",
    "com.zm",
    "edu.zm",
    "gov.zm",
    "info.zm",
    "mil.zm",
    "net.zm",
    "org.zm",
    "sch.zm",
    "zw",
    "ac.zw",
    "co.zw",
    "gov.zw",
    "mil.zw",
    "org.zw",
    "aaa",
    "aarp",
    "abarth",
    "abb",
    "abbott",
    "abbvie",
    "abc",
    "able",
    "abogado",
    "abudhabi",
    "academy",
    "accenture",
    "accountant",
    "accountants",
    "aco",
    "actor",
    "adac",
    "ads",
    "adult",
    "aeg",
    "aetna",
    "afamilycompany",
    "afl",
    "africa",
    "agakhan",
    "agency",
    "aig",
    "aigo",
    "airbus",
    "airforce",
    "airtel",
    "akdn",
    "alfaromeo",
    "alibaba",
    "alipay",
    "allfinanz",
    "allstate",
    "ally",
    "alsace",
    "alstom",
    "americanexpress",
    "americanfamily",
    "amex",
    "amfam",
    "amica",
    "amsterdam",
    "analytics",
    "android",
    "anquan",
    "anz",
    "aol",
    "apartments",
    "app",
    "apple",
    "aquarelle",
    "arab",
    "aramco",
    "archi",
    "army",
    "art",
    "arte",
    "asda",
    "associates",
    "athleta",
    "attorney",
    "auction",
    "audi",
    "audible",
    "audio",
    "auspost",
    "author",
    "auto",
    "autos",
    "avianca",
    "aws",
    "axa",
    "azure",
    "baby",
    "baidu",
    "banamex",
    "bananarepublic",
    "band",
    "bank",
    "bar",
    "barcelona",
    "barclaycard",
    "barclays",
    "barefoot",
    "bargains",
    "baseball",
    "basketball",
    "bauhaus",
    "bayern",
    "bbc",
    "bbt",
    "bbva",
    "bcg",
    "bcn",
    "beats",
    "beauty",
    "beer",
    "bentley",
    "berlin",
    "best",
    "bestbuy",
    "bet",
    "bharti",
    "bible",
    "bid",
    "bike",
    "bing",
    "bingo",
    "bio",
    "black",
    "blackfriday",
    "blockbuster",
    "blog",
    "bloomberg",
    "blue",
    "bms",
    "bmw",
    "bnl",
    "bnpparibas",
    "boats",
    "boehringer",
    "bofa",
    "bom",
    "bond",
    "boo",
    "book",
    "booking",
    "bosch",
    "bostik",
    "boston",
    "bot",
    "boutique",
    "box",
    "bradesco",
    "bridgestone",
    "broadway",
    "broker",
    "brother",
    "brussels",
    "budapest",
    "bugatti",
    "build",
    "builders",
    "business",
    "buy",
    "buzz",
    "bzh",
    "cab",
    "cafe",
    "cal",
    "call",
    "calvinklein",
    "cam",
    "camera",
    "camp",
    "cancerresearch",
    "canon",
    "capetown",
    "capital",
    "capitalone",
    "car",
    "caravan",
    "cards",
    "care",
    "career",
    "careers",
    "cars",
    "cartier",
    "casa",
    "case",
    "caseih",
    "cash",
    "casino",
    "catering",
    "catholic",
    "cba",
    "cbn",
    "cbre",
    "cbs",
    "ceb",
    "center",
    "ceo",
    "cern",
    "cfa",
    "cfd",
    "chanel",
    "channel",
    "charity",
    "chase",
    "chat",
    "cheap",
    "chintai",
    "christmas",
    "chrome",
    "chrysler",
    "church",
    "cipriani",
    "circle",
    "cisco",
    "citadel",
    "citi",
    "citic",
    "city",
    "cityeats",
    "claims",
    "cleaning",
    "click",
    "clinic",
    "clinique",
    "clothing",
    "cloud",
    "club",
    "clubmed",
    "coach",
    "codes",
    "coffee",
    "college",
    "cologne",
    "comcast",
    "commbank",
    "community",
    "company",
    "compare",
    "computer",
    "comsec",
    "condos",
    "construction",
    "consulting",
    "contact",
    "contractors",
    "cooking",
    "cookingchannel",
    "cool",
    "corsica",
    "country",
    "coupon",
    "coupons",
    "courses",
    "cpa",
    "credit",
    "creditcard",
    "creditunion",
    "cricket",
    "crown",
    "crs",
    "cruise",
    "cruises",
    "csc",
    "cuisinella",
    "cymru",
    "cyou",
    "dabur",
    "dad",
    "dance",
    "data",
    "date",
    "dating",
    "datsun",
    "day",
    "dclk",
    "dds",
    "deal",
    "dealer",
    "deals",
    "degree",
    "delivery",
    "dell",
    "deloitte",
    "delta",
    "democrat",
    "dental",
    "dentist",
    "desi",
    "design",
    "dev",
    "dhl",
    "diamonds",
    "diet",
    "digital",
    "direct",
    "directory",
    "discount",
    "discover",
    "dish",
    "diy",
    "dnp",
    "docs",
    "doctor",
    "dodge",
    "dog",
    "domains",
    "dot",
    "download",
    "drive",
    "dtv",
    "dubai",
    "duck",
    "dunlop",
    "duns",
    "dupont",
    "durban",
    "dvag",
    "dvr",
    "earth",
    "eat",
    "eco",
    "edeka",
    "education",
    "email",
    "emerck",
    "energy",
    "engineer",
    "engineering",
    "enterprises",
    "epson",
    "equipment",
    "ericsson",
    "erni",
    "esq",
    "estate",
    "esurance",
    "etisalat",
    "eurovision",
    "eus",
    "events",
    "everbank",
    "exchange",
    "expert",
    "exposed",
    "express",
    "extraspace",
    "fage",
    "fail",
    "fairwinds",
    "faith",
    "family",
    "fan",
    "fans",
    "farm",
    "farmers",
    "fashion",
    "fast",
    "fedex",
    "feedback",
    "ferrari",
    "ferrero",
    "fiat",
    "fidelity",
    "fido",
    "film",
    "final",
    "finance",
    "financial",
    "fire",
    "firestone",
    "firmdale",
    "fish",
    "fishing",
    "fit",
    "fitness",
    "flickr",
    "flights",
    "flir",
    "florist",
    "flowers",
    "fly",
    "foo",
    "food",
    "foodnetwork",
    "football",
    "ford",
    "forex",
    "forsale",
    "forum",
    "foundation",
    "fox",
    "free",
    "fresenius",
    "frl",
    "frogans",
    "frontdoor",
    "frontier",
    "ftr",
    "fujitsu",
    "fujixerox",
    "fun",
    "fund",
    "furniture",
    "futbol",
    "fyi",
    "gal",
    "gallery",
    "gallo",
    "gallup",
    "game",
    "games",
    "gap",
    "garden",
    "gay",
    "gbiz",
    "gdn",
    "gea",
    "gent",
    "genting",
    "george",
    "ggee",
    "gift",
    "gifts",
    "gives",
    "giving",
    "glade",
    "glass",
    "gle",
    "global",
    "globo",
    "gmail",
    "gmbh",
    "gmo",
    "gmx",
    "godaddy",
    "gold",
    "goldpoint",
    "golf",
    "goo",
    "goodyear",
    "goog",
    "google",
    "gop",
    "got",
    "grainger",
    "graphics",
    "gratis",
    "green",
    "gripe",
    "grocery",
    "group",
    "guardian",
    "gucci",
    "guge",
    "guide",
    "guitars",
    "guru",
    "hair",
    "hamburg",
    "hangout",
    "haus",
    "hbo",
    "hdfc",
    "hdfcbank",
    "health",
    "healthcare",
    "help",
    "helsinki",
    "here",
    "hermes",
    "hgtv",
    "hiphop",
    "hisamitsu",
    "hitachi",
    "hiv",
    "hkt",
    "hockey",
    "holdings",
    "holiday",
    "homedepot",
    "homegoods",
    "homes",
    "homesense",
    "honda",
    "honeywell",
    "horse",
    "hospital",
    "host",
    "hosting",
    "hot",
    "hoteles",
    "hotels",
    "hotmail",
    "house",
    "how",
    "hsbc",
    "hughes",
    "hyatt",
    "hyundai",
    "ibm",
    "icbc",
    "ice",
    "icu",
    "ieee",
    "ifm",
    "ikano",
    "imamat",
    "imdb",
    "immo",
    "immobilien",
    "inc",
    "industries",
    "infiniti",
    "ing",
    "ink",
    "institute",
    "insurance",
    "insure",
    "intel",
    "international",
    "intuit",
    "investments",
    "ipiranga",
    "irish",
    "iselect",
    "ismaili",
    "ist",
    "istanbul",
    "itau",
    "itv",
    "iveco",
    "jaguar",
    "java",
    "jcb",
    "jcp",
    "jeep",
    "jetzt",
    "jewelry",
    "jio",
    "jll",
    "jmp",
    "jnj",
    "joburg",
    "jot",
    "joy",
    "jpmorgan",
    "jprs",
    "juegos",
    "juniper",
    "kaufen",
    "kddi",
    "kerryhotels",
    "kerrylogistics",
    "kerryproperties",
    "kfh",
    "kia",
    "kim",
    "kinder",
    "kindle",
    "kitchen",
    "kiwi",
    "koeln",
    "komatsu",
    "kosher",
    "kpmg",
    "kpn",
    "krd",
    "kred",
    "kuokgroup",
    "kyoto",
    "lacaixa",
    "ladbrokes",
    "lamborghini",
    "lamer",
    "lancaster",
    "lancia",
    "lancome",
    "land",
    "landrover",
    "lanxess",
    "lasalle",
    "lat",
    "latino",
    "latrobe",
    "law",
    "lawyer",
    "lds",
    "lease",
    "leclerc",
    "lefrak",
    "legal",
    "lego",
    "lexus",
    "lgbt",
    "liaison",
    "lidl",
    "life",
    "lifeinsurance",
    "lifestyle",
    "lighting",
    "like",
    "lilly",
    "limited",
    "limo",
    "lincoln",
    "linde",
    "link",
    "lipsy",
    "live",
    "living",
    "lixil",
    "llc",
    "loan",
    "loans",
    "locker",
    "locus",
    "loft",
    "lol",
    "london",
    "lotte",
    "lotto",
    "love",
    "lpl",
    "lplfinancial",
    "ltd",
    "ltda",
    "lundbeck",
    "lupin",
    "luxe",
    "luxury",
    "macys",
    "madrid",
    "maif",
    "maison",
    "makeup",
    "man",
    "management",
    "mango",
    "map",
    "market",
    "marketing",
    "markets",
    "marriott",
    "marshalls",
    "maserati",
    "mattel",
    "mba",
    "mckinsey",
    "med",
    "media",
    "meet",
    "melbourne",
    "meme",
    "memorial",
    "men",
    "menu",
    "merckmsd",
    "metlife",
    "miami",
    "microsoft",
    "mini",
    "mint",
    "mit",
    "mitsubishi",
    "mlb",
    "mls",
    "mma",
    "mobile",
    "mobily",
    "moda",
    "moe",
    "moi",
    "mom",
    "monash",
    "money",
    "monster",
    "mopar",
    "mormon",
    "mortgage",
    "moscow",
    "moto",
    "motorcycles",
    "mov",
    "movie",
    "movistar",
    "msd",
    "mtn",
    "mtr",
    "mutual",
    "nab",
    "nadex",
    "nagoya",
    "nationwide",
    "natura",
    "navy",
    "nba",
    "nec",
    "netbank",
    "netflix",
    "network",
    "neustar",
    "new",
    "newholland",
    "news",
    "next",
    "nextdirect",
    "nexus",
    "nfl",
    "ngo",
    "nhk",
    "nico",
    "nike",
    "nikon",
    "ninja",
    "nissan",
    "nissay",
    "nokia",
    "northwesternmutual",
    "norton",
    "now",
    "nowruz",
    "nowtv",
    "nra",
    "nrw",
    "ntt",
    "nyc",
    "obi",
    "observer",
    "off",
    "office",
    "okinawa",
    "olayan",
    "olayangroup",
    "oldnavy",
    "ollo",
    "omega",
    "one",
    "ong",
    "onl",
    "online",
    "onyourside",
    "ooo",
    "open",
    "oracle",
    "orange",
    "organic",
    "origins",
    "osaka",
    "otsuka",
    "ott",
    "ovh",
    "page",
    "panasonic",
    "paris",
    "pars",
    "partners",
    "parts",
    "party",
    "passagens",
    "pay",
    "pccw",
    "pet",
    "pfizer",
    "pharmacy",
    "phd",
    "philips",
    "phone",
    "photo",
    "photography",
    "photos",
    "physio",
    "piaget",
    "pics",
    "pictet",
    "pictures",
    "pid",
    "pin",
    "ping",
    "pink",
    "pioneer",
    "pizza",
    "place",
    "play",
    "playstation",
    "plumbing",
    "plus",
    "pnc",
    "pohl",
    "poker",
    "politie",
    "porn",
    "pramerica",
    "praxi",
    "press",
    "prime",
    "prod",
    "productions",
    "prof",
    "progressive",
    "promo",
    "properties",
    "property",
    "protection",
    "pru",
    "prudential",
    "pub",
    "pwc",
    "qpon",
    "quebec",
    "quest",
    "qvc",
    "racing",
    "radio",
    "raid",
    "read",
    "realestate",
    "realtor",
    "realty",
    "recipes",
    "red",
    "redstone",
    "redumbrella",
    "rehab",
    "reise",
    "reisen",
    "reit",
    "reliance",
    "ren",
    "rent",
    "rentals",
    "repair",
    "report",
    "republican",
    "rest",
    "restaurant",
    "review",
    "reviews",
    "rexroth",
    "rich",
    "richardli",
    "ricoh",
    "rightathome",
    "ril",
    "rio",
    "rip",
    "rmit",
    "rocher",
    "rocks",
    "rodeo",
    "rogers",
    "room",
    "rsvp",
    "rugby",
    "ruhr",
    "run",
    "rwe",
    "ryukyu",
    "saarland",
    "safe",
    "safety",
    "sakura",
    "sale",
    "salon",
    "samsclub",
    "samsung",
    "sandvik",
    "sandvikcoromant",
    "sanofi",
    "sap",
    "sarl",
    "sas",
    "save",
    "saxo",
    "sbi",
    "sbs",
    "sca",
    "scb",
    "schaeffler",
    "schmidt",
    "scholarships",
    "school",
    "schule",
    "schwarz",
    "science",
    "scjohnson",
    "scor",
    "scot",
    "search",
    "seat",
    "secure",
    "security",
    "seek",
    "select",
    "sener",
    "services",
    "ses",
    "seven",
    "sew",
    "sex",
    "sexy",
    "sfr",
    "shangrila",
    "sharp",
    "shaw",
    "shell",
    "shia",
    "shiksha",
    "shoes",
    "shop",
    "shopping",
    "shouji",
    "show",
    "showtime",
    "shriram",
    "silk",
    "sina",
    "singles",
    "site",
    "ski",
    "skin",
    "sky",
    "skype",
    "sling",
    "smart",
    "smile",
    "sncf",
    "soccer",
    "social",
    "softbank",
    "software",
    "sohu",
    "solar",
    "solutions",
    "song",
    "sony",
    "soy",
    "space",
    "sport",
    "spot",
    "spreadbetting",
    "srl",
    "srt",
    "stada",
    "staples",
    "star",
    "starhub",
    "statebank",
    "statefarm",
    "stc",
    "stcgroup",
    "stockholm",
    "storage",
    "store",
    "stream",
    "studio",
    "study",
    "style",
    "sucks",
    "supplies",
    "supply",
    "support",
    "surf",
    "surgery",
    "suzuki",
    "swatch",
    "swiftcover",
    "swiss",
    "sydney",
    "symantec",
    "systems",
    "tab",
    "taipei",
    "talk",
    "taobao",
    "target",
    "tatamotors",
    "tatar",
    "tattoo",
    "tax",
    "taxi",
    "tci",
    "tdk",
    "team",
    "tech",
    "technology",
    "telefonica",
    "temasek",
    "tennis",
    "teva",
    "thd",
    "theater",
    "theatre",
    "tiaa",
    "tickets",
    "tienda",
    "tiffany",
    "tips",
    "tires",
    "tirol",
    "tjmaxx",
    "tjx",
    "tkmaxx",
    "tmall",
    "today",
    "tokyo",
    "tools",
    "top",
    "toray",
    "toshiba",
    "total",
    "tours",
    "town",
    "toyota",
    "toys",
    "trade",
    "trading",
    "training",
    "travel",
    "travelchannel",
    "travelers",
    "travelersinsurance",
    "trust",
    "trv",
    "tube",
    "tui",
    "tunes",
    "tushu",
    "tvs",
    "ubank",
    "ubs",
    "uconnect",
    "unicom",
    "university",
    "uno",
    "uol",
    "ups",
    "vacations",
    "vana",
    "vanguard",
    "vegas",
    "ventures",
    "verisign",
    "versicherung",
    "vet",
    "viajes",
    "video",
    "vig",
    "viking",
    "villas",
    "vin",
    "vip",
    "virgin",
    "visa",
    "vision",
    "vistaprint",
    "viva",
    "vivo",
    "vlaanderen",
    "vodka",
    "volkswagen",
    "volvo",
    "vote",
    "voting",
    "voto",
    "voyage",
    "vuelos",
    "wales",
    "walmart",
    "walter",
    "wang",
    "wanggou",
    "warman",
    "watch",
    "watches",
    "weather",
    "weatherchannel",
    "webcam",
    "weber",
    "website",
    "wed",
    "wedding",
    "weibo",
    "weir",
    "whoswho",
    "wien",
    "wiki",
    "williamhill",
    "win",
    "windows",
    "wine",
    "winners",
    "wme",
    "wolterskluwer",
    "woodside",
    "work",
    "works",
    "world",
    "wow",
    "wtc",
    "wtf",
    "xbox",
    "xerox",
    "xfinity",
    "xihuan",
    "xin",
    "\u0915\u0949\u092E",
    "\u30BB\u30FC\u30EB",
    "\u4F5B\u5C71",
    "\u6148\u5584",
    "\u96C6\u56E2",
    "\u5728\u7EBF",
    "\u5927\u4F17\u6C7D\u8F66",
    "\u70B9\u770B",
    "\u0E04\u0E2D\u0E21",
    "\u516B\u5366",
    "\u0645\u0648\u0642\u0639",
    "\u516C\u76CA",
    "\u516C\u53F8",
    "\u9999\u683C\u91CC\u62C9",
    "\u7F51\u7AD9",
    "\u79FB\u52A8",
    "\u6211\u7231\u4F60",
    "\u043C\u043E\u0441\u043A\u0432\u0430",
    "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
    "\u043E\u043D\u043B\u0430\u0439\u043D",
    "\u0441\u0430\u0439\u0442",
    "\u8054\u901A",
    "\u05E7\u05D5\u05DD",
    "\u65F6\u5C1A",
    "\u5FAE\u535A",
    "\u6DE1\u9A6C\u9521",
    "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
    "\u043E\u0440\u0433",
    "\u0928\u0947\u091F",
    "\u30B9\u30C8\u30A2",
    "\uC0BC\uC131",
    "\u5546\u6807",
    "\u5546\u5E97",
    "\u5546\u57CE",
    "\u0434\u0435\u0442\u0438",
    "\u30DD\u30A4\u30F3\u30C8",
    "\u65B0\u95FB",
    "\u5DE5\u884C",
    "\u5BB6\u96FB",
    "\u0643\u0648\u0645",
    "\u4E2D\u6587\u7F51",
    "\u4E2D\u4FE1",
    "\u5A31\u4E50",
    "\u8C37\u6B4C",
    "\u96FB\u8A0A\u76C8\u79D1",
    "\u8D2D\u7269",
    "\u30AF\u30E9\u30A6\u30C9",
    "\u901A\u8CA9",
    "\u7F51\u5E97",
    "\u0938\u0902\u0917\u0920\u0928",
    "\u9910\u5385",
    "\u7F51\u7EDC",
    "\u043A\u043E\u043C",
    "\u8BFA\u57FA\u4E9A",
    "\u98DF\u54C1",
    "\u98DE\u5229\u6D66",
    "\u624B\u8868",
    "\u624B\u673A",
    "\u0627\u0631\u0627\u0645\u0643\u0648",
    "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
    "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
    "\u0628\u0627\u0632\u0627\u0631",
    "\u0645\u0648\u0628\u0627\u064A\u0644\u064A",
    "\u0627\u0628\u0648\u0638\u0628\u064A",
    "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
    "\u0647\u0645\u0631\u0627\u0647",
    "\uB2F7\uCEF4",
    "\u653F\u5E9C",
    "\u0634\u0628\u0643\u0629",
    "\u0628\u064A\u062A\u0643",
    "\u0639\u0631\u0628",
    "\u673A\u6784",
    "\u7EC4\u7EC7\u673A\u6784",
    "\u5065\u5EB7",
    "\u62DB\u8058",
    "\u0440\u0443\u0441",
    "\u73E0\u5B9D",
    "\u5927\u62FF",
    "\u307F\u3093\u306A",
    "\u30B0\u30FC\u30B0\u30EB",
    "\u4E16\u754C",
    "\u66F8\u7C4D",
    "\u7F51\u5740",
    "\uB2F7\uB137",
    "\u30B3\u30E0",
    "\u5929\u4E3B\u6559",
    "\u6E38\u620F",
    "verm\xF6gensberater",
    "verm\xF6gensberatung",
    "\u4F01\u4E1A",
    "\u4FE1\u606F",
    "\u5609\u91CC\u5927\u9152\u5E97",
    "\u5609\u91CC",
    "\u5E7F\u4E1C",
    "\u653F\u52A1",
    "xyz",
    "yachts",
    "yahoo",
    "yamaxun",
    "yandex",
    "yodobashi",
    "yoga",
    "yokohama",
    "you",
    "youtube",
    "yun",
    "zappos",
    "zara",
    "zero",
    "zip",
    "zone",
    "zuerich",
    "cc.ua",
    "inf.ua",
    "ltd.ua",
    "beep.pl",
    "barsy.ca",
    "*.compute.estate",
    "*.alces.network",
    "alwaysdata.net",
    "cloudfront.net",
    "*.compute.amazonaws.com",
    "*.compute-1.amazonaws.com",
    "*.compute.amazonaws.com.cn",
    "us-east-1.amazonaws.com",
    "cn-north-1.eb.amazonaws.com.cn",
    "cn-northwest-1.eb.amazonaws.com.cn",
    "elasticbeanstalk.com",
    "ap-northeast-1.elasticbeanstalk.com",
    "ap-northeast-2.elasticbeanstalk.com",
    "ap-northeast-3.elasticbeanstalk.com",
    "ap-south-1.elasticbeanstalk.com",
    "ap-southeast-1.elasticbeanstalk.com",
    "ap-southeast-2.elasticbeanstalk.com",
    "ca-central-1.elasticbeanstalk.com",
    "eu-central-1.elasticbeanstalk.com",
    "eu-west-1.elasticbeanstalk.com",
    "eu-west-2.elasticbeanstalk.com",
    "eu-west-3.elasticbeanstalk.com",
    "sa-east-1.elasticbeanstalk.com",
    "us-east-1.elasticbeanstalk.com",
    "us-east-2.elasticbeanstalk.com",
    "us-gov-west-1.elasticbeanstalk.com",
    "us-west-1.elasticbeanstalk.com",
    "us-west-2.elasticbeanstalk.com",
    "*.elb.amazonaws.com",
    "*.elb.amazonaws.com.cn",
    "s3.amazonaws.com",
    "s3-ap-northeast-1.amazonaws.com",
    "s3-ap-northeast-2.amazonaws.com",
    "s3-ap-south-1.amazonaws.com",
    "s3-ap-southeast-1.amazonaws.com",
    "s3-ap-southeast-2.amazonaws.com",
    "s3-ca-central-1.amazonaws.com",
    "s3-eu-central-1.amazonaws.com",
    "s3-eu-west-1.amazonaws.com",
    "s3-eu-west-2.amazonaws.com",
    "s3-eu-west-3.amazonaws.com",
    "s3-external-1.amazonaws.com",
    "s3-fips-us-gov-west-1.amazonaws.com",
    "s3-sa-east-1.amazonaws.com",
    "s3-us-gov-west-1.amazonaws.com",
    "s3-us-east-2.amazonaws.com",
    "s3-us-west-1.amazonaws.com",
    "s3-us-west-2.amazonaws.com",
    "s3.ap-northeast-2.amazonaws.com",
    "s3.ap-south-1.amazonaws.com",
    "s3.cn-north-1.amazonaws.com.cn",
    "s3.ca-central-1.amazonaws.com",
    "s3.eu-central-1.amazonaws.com",
    "s3.eu-west-2.amazonaws.com",
    "s3.eu-west-3.amazonaws.com",
    "s3.us-east-2.amazonaws.com",
    "s3.dualstack.ap-northeast-1.amazonaws.com",
    "s3.dualstack.ap-northeast-2.amazonaws.com",
    "s3.dualstack.ap-south-1.amazonaws.com",
    "s3.dualstack.ap-southeast-1.amazonaws.com",
    "s3.dualstack.ap-southeast-2.amazonaws.com",
    "s3.dualstack.ca-central-1.amazonaws.com",
    "s3.dualstack.eu-central-1.amazonaws.com",
    "s3.dualstack.eu-west-1.amazonaws.com",
    "s3.dualstack.eu-west-2.amazonaws.com",
    "s3.dualstack.eu-west-3.amazonaws.com",
    "s3.dualstack.sa-east-1.amazonaws.com",
    "s3.dualstack.us-east-1.amazonaws.com",
    "s3.dualstack.us-east-2.amazonaws.com",
    "s3-website-us-east-1.amazonaws.com",
    "s3-website-us-west-1.amazonaws.com",
    "s3-website-us-west-2.amazonaws.com",
    "s3-website-ap-northeast-1.amazonaws.com",
    "s3-website-ap-southeast-1.amazonaws.com",
    "s3-website-ap-southeast-2.amazonaws.com",
    "s3-website-eu-west-1.amazonaws.com",
    "s3-website-sa-east-1.amazonaws.com",
    "s3-website.ap-northeast-2.amazonaws.com",
    "s3-website.ap-south-1.amazonaws.com",
    "s3-website.ca-central-1.amazonaws.com",
    "s3-website.eu-central-1.amazonaws.com",
    "s3-website.eu-west-2.amazonaws.com",
    "s3-website.eu-west-3.amazonaws.com",
    "s3-website.us-east-2.amazonaws.com",
    "t3l3p0rt.net",
    "tele.amune.org",
    "apigee.io",
    "on-aptible.com",
    "user.aseinet.ne.jp",
    "gv.vc",
    "d.gv.vc",
    "user.party.eus",
    "pimienta.org",
    "poivron.org",
    "potager.org",
    "sweetpepper.org",
    "myasustor.com",
    "go-vip.co",
    "go-vip.net",
    "wpcomstaging.com",
    "myfritz.net",
    "*.awdev.ca",
    "*.advisor.ws",
    "b-data.io",
    "backplaneapp.io",
    "balena-devices.com",
    "app.banzaicloud.io",
    "betainabox.com",
    "bnr.la",
    "blackbaudcdn.net",
    "boomla.net",
    "boxfuse.io",
    "square7.ch",
    "bplaced.com",
    "bplaced.de",
    "square7.de",
    "bplaced.net",
    "square7.net",
    "browsersafetymark.io",
    "uk0.bigv.io",
    "dh.bytemark.co.uk",
    "vm.bytemark.co.uk",
    "mycd.eu",
    "carrd.co",
    "crd.co",
    "uwu.ai",
    "ae.org",
    "ar.com",
    "br.com",
    "cn.com",
    "com.de",
    "com.se",
    "de.com",
    "eu.com",
    "gb.com",
    "gb.net",
    "hu.com",
    "hu.net",
    "jp.net",
    "jpn.com",
    "kr.com",
    "mex.com",
    "no.com",
    "qc.com",
    "ru.com",
    "sa.com",
    "se.net",
    "uk.com",
    "uk.net",
    "us.com",
    "uy.com",
    "za.bz",
    "za.com",
    "africa.com",
    "gr.com",
    "in.net",
    "us.org",
    "co.com",
    "c.la",
    "certmgr.org",
    "xenapponazure.com",
    "discourse.group",
    "virtueeldomein.nl",
    "cleverapps.io",
    "*.lcl.dev",
    "*.stg.dev",
    "c66.me",
    "cloud66.ws",
    "cloud66.zone",
    "jdevcloud.com",
    "wpdevcloud.com",
    "cloudaccess.host",
    "freesite.host",
    "cloudaccess.net",
    "cloudcontrolled.com",
    "cloudcontrolapp.com",
    "cloudera.site",
    "trycloudflare.com",
    "workers.dev",
    "wnext.app",
    "co.ca",
    "*.otap.co",
    "co.cz",
    "c.cdn77.org",
    "cdn77-ssl.net",
    "r.cdn77.net",
    "rsc.cdn77.org",
    "ssl.origin.cdn77-secure.org",
    "cloudns.asia",
    "cloudns.biz",
    "cloudns.club",
    "cloudns.cc",
    "cloudns.eu",
    "cloudns.in",
    "cloudns.info",
    "cloudns.org",
    "cloudns.pro",
    "cloudns.pw",
    "cloudns.us",
    "cloudeity.net",
    "cnpy.gdn",
    "co.nl",
    "co.no",
    "webhosting.be",
    "hosting-cluster.nl",
    "dyn.cosidns.de",
    "dynamisches-dns.de",
    "dnsupdater.de",
    "internet-dns.de",
    "l-o-g-i-n.de",
    "dynamic-dns.info",
    "feste-ip.net",
    "knx-server.net",
    "static-access.net",
    "realm.cz",
    "*.cryptonomic.net",
    "cupcake.is",
    "cyon.link",
    "cyon.site",
    "daplie.me",
    "localhost.daplie.me",
    "dattolocal.com",
    "dattorelay.com",
    "dattoweb.com",
    "mydatto.com",
    "dattolocal.net",
    "mydatto.net",
    "biz.dk",
    "co.dk",
    "firm.dk",
    "reg.dk",
    "store.dk",
    "*.dapps.earth",
    "*.bzz.dapps.earth",
    "debian.net",
    "dedyn.io",
    "dnshome.de",
    "online.th",
    "shop.th",
    "drayddns.com",
    "dreamhosters.com",
    "mydrobo.com",
    "drud.io",
    "drud.us",
    "duckdns.org",
    "dy.fi",
    "tunk.org",
    "dyndns-at-home.com",
    "dyndns-at-work.com",
    "dyndns-blog.com",
    "dyndns-free.com",
    "dyndns-home.com",
    "dyndns-ip.com",
    "dyndns-mail.com",
    "dyndns-office.com",
    "dyndns-pics.com",
    "dyndns-remote.com",
    "dyndns-server.com",
    "dyndns-web.com",
    "dyndns-wiki.com",
    "dyndns-work.com",
    "dyndns.biz",
    "dyndns.info",
    "dyndns.org",
    "dyndns.tv",
    "at-band-camp.net",
    "ath.cx",
    "barrel-of-knowledge.info",
    "barrell-of-knowledge.info",
    "better-than.tv",
    "blogdns.com",
    "blogdns.net",
    "blogdns.org",
    "blogsite.org",
    "boldlygoingnowhere.org",
    "broke-it.net",
    "buyshouses.net",
    "cechire.com",
    "dnsalias.com",
    "dnsalias.net",
    "dnsalias.org",
    "dnsdojo.com",
    "dnsdojo.net",
    "dnsdojo.org",
    "does-it.net",
    "doesntexist.com",
    "doesntexist.org",
    "dontexist.com",
    "dontexist.net",
    "dontexist.org",
    "doomdns.com",
    "doomdns.org",
    "dvrdns.org",
    "dyn-o-saur.com",
    "dynalias.com",
    "dynalias.net",
    "dynalias.org",
    "dynathome.net",
    "dyndns.ws",
    "endofinternet.net",
    "endofinternet.org",
    "endoftheinternet.org",
    "est-a-la-maison.com",
    "est-a-la-masion.com",
    "est-le-patron.com",
    "est-mon-blogueur.com",
    "for-better.biz",
    "for-more.biz",
    "for-our.info",
    "for-some.biz",
    "for-the.biz",
    "forgot.her.name",
    "forgot.his.name",
    "from-ak.com",
    "from-al.com",
    "from-ar.com",
    "from-az.net",
    "from-ca.com",
    "from-co.net",
    "from-ct.com",
    "from-dc.com",
    "from-de.com",
    "from-fl.com",
    "from-ga.com",
    "from-hi.com",
    "from-ia.com",
    "from-id.com",
    "from-il.com",
    "from-in.com",
    "from-ks.com",
    "from-ky.com",
    "from-la.net",
    "from-ma.com",
    "from-md.com",
    "from-me.org",
    "from-mi.com",
    "from-mn.com",
    "from-mo.com",
    "from-ms.com",
    "from-mt.com",
    "from-nc.com",
    "from-nd.com",
    "from-ne.com",
    "from-nh.com",
    "from-nj.com",
    "from-nm.com",
    "from-nv.com",
    "from-ny.net",
    "from-oh.com",
    "from-ok.com",
    "from-or.com",
    "from-pa.com",
    "from-pr.com",
    "from-ri.com",
    "from-sc.com",
    "from-sd.com",
    "from-tn.com",
    "from-tx.com",
    "from-ut.com",
    "from-va.com",
    "from-vt.com",
    "from-wa.com",
    "from-wi.com",
    "from-wv.com",
    "from-wy.com",
    "ftpaccess.cc",
    "fuettertdasnetz.de",
    "game-host.org",
    "game-server.cc",
    "getmyip.com",
    "gets-it.net",
    "go.dyndns.org",
    "gotdns.com",
    "gotdns.org",
    "groks-the.info",
    "groks-this.info",
    "ham-radio-op.net",
    "here-for-more.info",
    "hobby-site.com",
    "hobby-site.org",
    "home.dyndns.org",
    "homedns.org",
    "homeftp.net",
    "homeftp.org",
    "homeip.net",
    "homelinux.com",
    "homelinux.net",
    "homelinux.org",
    "homeunix.com",
    "homeunix.net",
    "homeunix.org",
    "iamallama.com",
    "in-the-band.net",
    "is-a-anarchist.com",
    "is-a-blogger.com",
    "is-a-bookkeeper.com",
    "is-a-bruinsfan.org",
    "is-a-bulls-fan.com",
    "is-a-candidate.org",
    "is-a-caterer.com",
    "is-a-celticsfan.org",
    "is-a-chef.com",
    "is-a-chef.net",
    "is-a-chef.org",
    "is-a-conservative.com",
    "is-a-cpa.com",
    "is-a-cubicle-slave.com",
    "is-a-democrat.com",
    "is-a-designer.com",
    "is-a-doctor.com",
    "is-a-financialadvisor.com",
    "is-a-geek.com",
    "is-a-geek.net",
    "is-a-geek.org",
    "is-a-green.com",
    "is-a-guru.com",
    "is-a-hard-worker.com",
    "is-a-hunter.com",
    "is-a-knight.org",
    "is-a-landscaper.com",
    "is-a-lawyer.com",
    "is-a-liberal.com",
    "is-a-libertarian.com",
    "is-a-linux-user.org",
    "is-a-llama.com",
    "is-a-musician.com",
    "is-a-nascarfan.com",
    "is-a-nurse.com",
    "is-a-painter.com",
    "is-a-patsfan.org",
    "is-a-personaltrainer.com",
    "is-a-photographer.com",
    "is-a-player.com",
    "is-a-republican.com",
    "is-a-rockstar.com",
    "is-a-socialist.com",
    "is-a-soxfan.org",
    "is-a-student.com",
    "is-a-teacher.com",
    "is-a-techie.com",
    "is-a-therapist.com",
    "is-an-accountant.com",
    "is-an-actor.com",
    "is-an-actress.com",
    "is-an-anarchist.com",
    "is-an-artist.com",
    "is-an-engineer.com",
    "is-an-entertainer.com",
    "is-by.us",
    "is-certified.com",
    "is-found.org",
    "is-gone.com",
    "is-into-anime.com",
    "is-into-cars.com",
    "is-into-cartoons.com",
    "is-into-games.com",
    "is-leet.com",
    "is-lost.org",
    "is-not-certified.com",
    "is-saved.org",
    "is-slick.com",
    "is-uberleet.com",
    "is-very-bad.org",
    "is-very-evil.org",
    "is-very-good.org",
    "is-very-nice.org",
    "is-very-sweet.org",
    "is-with-theband.com",
    "isa-geek.com",
    "isa-geek.net",
    "isa-geek.org",
    "isa-hockeynut.com",
    "issmarterthanyou.com",
    "isteingeek.de",
    "istmein.de",
    "kicks-ass.net",
    "kicks-ass.org",
    "knowsitall.info",
    "land-4-sale.us",
    "lebtimnetz.de",
    "leitungsen.de",
    "likes-pie.com",
    "likescandy.com",
    "merseine.nu",
    "mine.nu",
    "misconfused.org",
    "mypets.ws",
    "myphotos.cc",
    "neat-url.com",
    "office-on-the.net",
    "on-the-web.tv",
    "podzone.net",
    "podzone.org",
    "readmyblog.org",
    "saves-the-whales.com",
    "scrapper-site.net",
    "scrapping.cc",
    "selfip.biz",
    "selfip.com",
    "selfip.info",
    "selfip.net",
    "selfip.org",
    "sells-for-less.com",
    "sells-for-u.com",
    "sells-it.net",
    "sellsyourhome.org",
    "servebbs.com",
    "servebbs.net",
    "servebbs.org",
    "serveftp.net",
    "serveftp.org",
    "servegame.org",
    "shacknet.nu",
    "simple-url.com",
    "space-to-rent.com",
    "stuff-4-sale.org",
    "stuff-4-sale.us",
    "teaches-yoga.com",
    "thruhere.net",
    "traeumtgerade.de",
    "webhop.biz",
    "webhop.info",
    "webhop.net",
    "webhop.org",
    "worse-than.tv",
    "writesthisblog.com",
    "ddnss.de",
    "dyn.ddnss.de",
    "dyndns.ddnss.de",
    "dyndns1.de",
    "dyn-ip24.de",
    "home-webserver.de",
    "dyn.home-webserver.de",
    "myhome-server.de",
    "ddnss.org",
    "definima.net",
    "definima.io",
    "bci.dnstrace.pro",
    "ddnsfree.com",
    "ddnsgeek.com",
    "giize.com",
    "gleeze.com",
    "kozow.com",
    "loseyourip.com",
    "ooguy.com",
    "theworkpc.com",
    "casacam.net",
    "dynu.net",
    "accesscam.org",
    "camdvr.org",
    "freeddns.org",
    "mywire.org",
    "webredirect.org",
    "myddns.rocks",
    "blogsite.xyz",
    "dynv6.net",
    "e4.cz",
    "mytuleap.com",
    "onred.one",
    "staging.onred.one",
    "enonic.io",
    "customer.enonic.io",
    "eu.org",
    "al.eu.org",
    "asso.eu.org",
    "at.eu.org",
    "au.eu.org",
    "be.eu.org",
    "bg.eu.org",
    "ca.eu.org",
    "cd.eu.org",
    "ch.eu.org",
    "cn.eu.org",
    "cy.eu.org",
    "cz.eu.org",
    "de.eu.org",
    "dk.eu.org",
    "edu.eu.org",
    "ee.eu.org",
    "es.eu.org",
    "fi.eu.org",
    "fr.eu.org",
    "gr.eu.org",
    "hr.eu.org",
    "hu.eu.org",
    "ie.eu.org",
    "il.eu.org",
    "in.eu.org",
    "int.eu.org",
    "is.eu.org",
    "it.eu.org",
    "jp.eu.org",
    "kr.eu.org",
    "lt.eu.org",
    "lu.eu.org",
    "lv.eu.org",
    "mc.eu.org",
    "me.eu.org",
    "mk.eu.org",
    "mt.eu.org",
    "my.eu.org",
    "net.eu.org",
    "ng.eu.org",
    "nl.eu.org",
    "no.eu.org",
    "nz.eu.org",
    "paris.eu.org",
    "pl.eu.org",
    "pt.eu.org",
    "q-a.eu.org",
    "ro.eu.org",
    "ru.eu.org",
    "se.eu.org",
    "si.eu.org",
    "sk.eu.org",
    "tr.eu.org",
    "uk.eu.org",
    "us.eu.org",
    "eu-1.evennode.com",
    "eu-2.evennode.com",
    "eu-3.evennode.com",
    "eu-4.evennode.com",
    "us-1.evennode.com",
    "us-2.evennode.com",
    "us-3.evennode.com",
    "us-4.evennode.com",
    "twmail.cc",
    "twmail.net",
    "twmail.org",
    "mymailer.com.tw",
    "url.tw",
    "apps.fbsbx.com",
    "ru.net",
    "adygeya.ru",
    "bashkiria.ru",
    "bir.ru",
    "cbg.ru",
    "com.ru",
    "dagestan.ru",
    "grozny.ru",
    "kalmykia.ru",
    "kustanai.ru",
    "marine.ru",
    "mordovia.ru",
    "msk.ru",
    "mytis.ru",
    "nalchik.ru",
    "nov.ru",
    "pyatigorsk.ru",
    "spb.ru",
    "vladikavkaz.ru",
    "vladimir.ru",
    "abkhazia.su",
    "adygeya.su",
    "aktyubinsk.su",
    "arkhangelsk.su",
    "armenia.su",
    "ashgabad.su",
    "azerbaijan.su",
    "balashov.su",
    "bashkiria.su",
    "bryansk.su",
    "bukhara.su",
    "chimkent.su",
    "dagestan.su",
    "east-kazakhstan.su",
    "exnet.su",
    "georgia.su",
    "grozny.su",
    "ivanovo.su",
    "jambyl.su",
    "kalmykia.su",
    "kaluga.su",
    "karacol.su",
    "karaganda.su",
    "karelia.su",
    "khakassia.su",
    "krasnodar.su",
    "kurgan.su",
    "kustanai.su",
    "lenug.su",
    "mangyshlak.su",
    "mordovia.su",
    "msk.su",
    "murmansk.su",
    "nalchik.su",
    "navoi.su",
    "north-kazakhstan.su",
    "nov.su",
    "obninsk.su",
    "penza.su",
    "pokrovsk.su",
    "sochi.su",
    "spb.su",
    "tashkent.su",
    "termez.su",
    "togliatti.su",
    "troitsk.su",
    "tselinograd.su",
    "tula.su",
    "tuva.su",
    "vladikavkaz.su",
    "vladimir.su",
    "vologda.su",
    "channelsdvr.net",
    "fastly-terrarium.com",
    "fastlylb.net",
    "map.fastlylb.net",
    "freetls.fastly.net",
    "map.fastly.net",
    "a.prod.fastly.net",
    "global.prod.fastly.net",
    "a.ssl.fastly.net",
    "b.ssl.fastly.net",
    "global.ssl.fastly.net",
    "fastpanel.direct",
    "fastvps-server.com",
    "fhapp.xyz",
    "fedorainfracloud.org",
    "fedorapeople.org",
    "cloud.fedoraproject.org",
    "app.os.fedoraproject.org",
    "app.os.stg.fedoraproject.org",
    "mydobiss.com",
    "filegear.me",
    "filegear-au.me",
    "filegear-de.me",
    "filegear-gb.me",
    "filegear-ie.me",
    "filegear-jp.me",
    "filegear-sg.me",
    "firebaseapp.com",
    "flynnhub.com",
    "flynnhosting.net",
    "freebox-os.com",
    "freeboxos.com",
    "fbx-os.fr",
    "fbxos.fr",
    "freebox-os.fr",
    "freeboxos.fr",
    "freedesktop.org",
    "*.futurecms.at",
    "*.ex.futurecms.at",
    "*.in.futurecms.at",
    "futurehosting.at",
    "futuremailing.at",
    "*.ex.ortsinfo.at",
    "*.kunden.ortsinfo.at",
    "*.statics.cloud",
    "service.gov.uk",
    "gehirn.ne.jp",
    "usercontent.jp",
    "lab.ms",
    "github.io",
    "githubusercontent.com",
    "gitlab.io",
    "glitch.me",
    "cloudapps.digital",
    "london.cloudapps.digital",
    "homeoffice.gov.uk",
    "ro.im",
    "shop.ro",
    "goip.de",
    "run.app",
    "a.run.app",
    "web.app",
    "*.0emm.com",
    "appspot.com",
    "blogspot.ae",
    "blogspot.al",
    "blogspot.am",
    "blogspot.ba",
    "blogspot.be",
    "blogspot.bg",
    "blogspot.bj",
    "blogspot.ca",
    "blogspot.cf",
    "blogspot.ch",
    "blogspot.cl",
    "blogspot.co.at",
    "blogspot.co.id",
    "blogspot.co.il",
    "blogspot.co.ke",
    "blogspot.co.nz",
    "blogspot.co.uk",
    "blogspot.co.za",
    "blogspot.com",
    "blogspot.com.ar",
    "blogspot.com.au",
    "blogspot.com.br",
    "blogspot.com.by",
    "blogspot.com.co",
    "blogspot.com.cy",
    "blogspot.com.ee",
    "blogspot.com.eg",
    "blogspot.com.es",
    "blogspot.com.mt",
    "blogspot.com.ng",
    "blogspot.com.tr",
    "blogspot.com.uy",
    "blogspot.cv",
    "blogspot.cz",
    "blogspot.de",
    "blogspot.dk",
    "blogspot.fi",
    "blogspot.fr",
    "blogspot.gr",
    "blogspot.hk",
    "blogspot.hr",
    "blogspot.hu",
    "blogspot.ie",
    "blogspot.in",
    "blogspot.is",
    "blogspot.it",
    "blogspot.jp",
    "blogspot.kr",
    "blogspot.li",
    "blogspot.lt",
    "blogspot.lu",
    "blogspot.md",
    "blogspot.mk",
    "blogspot.mr",
    "blogspot.mx",
    "blogspot.my",
    "blogspot.nl",
    "blogspot.no",
    "blogspot.pe",
    "blogspot.pt",
    "blogspot.qa",
    "blogspot.re",
    "blogspot.ro",
    "blogspot.rs",
    "blogspot.ru",
    "blogspot.se",
    "blogspot.sg",
    "blogspot.si",
    "blogspot.sk",
    "blogspot.sn",
    "blogspot.td",
    "blogspot.tw",
    "blogspot.ug",
    "blogspot.vn",
    "cloudfunctions.net",
    "cloud.goog",
    "codespot.com",
    "googleapis.com",
    "googlecode.com",
    "pagespeedmobilizer.com",
    "publishproxy.com",
    "withgoogle.com",
    "withyoutube.com",
    "fin.ci",
    "free.hr",
    "caa.li",
    "ua.rs",
    "conf.se",
    "hs.zone",
    "hs.run",
    "hashbang.sh",
    "hasura.app",
    "hasura-app.io",
    "hepforge.org",
    "herokuapp.com",
    "herokussl.com",
    "myravendb.com",
    "ravendb.community",
    "ravendb.me",
    "development.run",
    "ravendb.run",
    "bpl.biz",
    "orx.biz",
    "ng.city",
    "biz.gl",
    "ng.ink",
    "col.ng",
    "firm.ng",
    "gen.ng",
    "ltd.ng",
    "ng.school",
    "sch.so",
    "h\xE4kkinen.fi",
    "*.moonscale.io",
    "moonscale.net",
    "iki.fi",
    "dyn-berlin.de",
    "in-berlin.de",
    "in-brb.de",
    "in-butter.de",
    "in-dsl.de",
    "in-dsl.net",
    "in-dsl.org",
    "in-vpn.de",
    "in-vpn.net",
    "in-vpn.org",
    "biz.at",
    "info.at",
    "info.cx",
    "ac.leg.br",
    "al.leg.br",
    "am.leg.br",
    "ap.leg.br",
    "ba.leg.br",
    "ce.leg.br",
    "df.leg.br",
    "es.leg.br",
    "go.leg.br",
    "ma.leg.br",
    "mg.leg.br",
    "ms.leg.br",
    "mt.leg.br",
    "pa.leg.br",
    "pb.leg.br",
    "pe.leg.br",
    "pi.leg.br",
    "pr.leg.br",
    "rj.leg.br",
    "rn.leg.br",
    "ro.leg.br",
    "rr.leg.br",
    "rs.leg.br",
    "sc.leg.br",
    "se.leg.br",
    "sp.leg.br",
    "to.leg.br",
    "pixolino.com",
    "ipifony.net",
    "mein-iserv.de",
    "test-iserv.de",
    "iserv.dev",
    "iobb.net",
    "myjino.ru",
    "*.hosting.myjino.ru",
    "*.landing.myjino.ru",
    "*.spectrum.myjino.ru",
    "*.vps.myjino.ru",
    "*.triton.zone",
    "*.cns.joyent.com",
    "js.org",
    "kaas.gg",
    "khplay.nl",
    "keymachine.de",
    "kinghost.net",
    "uni5.net",
    "knightpoint.systems",
    "co.krd",
    "edu.krd",
    "git-repos.de",
    "lcube-server.de",
    "svn-repos.de",
    "leadpages.co",
    "lpages.co",
    "lpusercontent.com",
    "lelux.site",
    "co.business",
    "co.education",
    "co.events",
    "co.financial",
    "co.network",
    "co.place",
    "co.technology",
    "app.lmpm.com",
    "linkitools.space",
    "linkyard.cloud",
    "linkyard-cloud.ch",
    "members.linode.com",
    "nodebalancer.linode.com",
    "we.bs",
    "loginline.app",
    "loginline.dev",
    "loginline.io",
    "loginline.services",
    "loginline.site",
    "krasnik.pl",
    "leczna.pl",
    "lubartow.pl",
    "lublin.pl",
    "poniatowa.pl",
    "swidnik.pl",
    "uklugs.org",
    "glug.org.uk",
    "lug.org.uk",
    "lugs.org.uk",
    "barsy.bg",
    "barsy.co.uk",
    "barsyonline.co.uk",
    "barsycenter.com",
    "barsyonline.com",
    "barsy.club",
    "barsy.de",
    "barsy.eu",
    "barsy.in",
    "barsy.info",
    "barsy.io",
    "barsy.me",
    "barsy.menu",
    "barsy.mobi",
    "barsy.net",
    "barsy.online",
    "barsy.org",
    "barsy.pro",
    "barsy.pub",
    "barsy.shop",
    "barsy.site",
    "barsy.support",
    "barsy.uk",
    "*.magentosite.cloud",
    "mayfirst.info",
    "mayfirst.org",
    "hb.cldmail.ru",
    "miniserver.com",
    "memset.net",
    "cloud.metacentrum.cz",
    "custom.metacentrum.cz",
    "flt.cloud.muni.cz",
    "usr.cloud.muni.cz",
    "meteorapp.com",
    "eu.meteorapp.com",
    "co.pl",
    "azurecontainer.io",
    "azurewebsites.net",
    "azure-mobile.net",
    "cloudapp.net",
    "mozilla-iot.org",
    "bmoattachments.org",
    "net.ru",
    "org.ru",
    "pp.ru",
    "ui.nabu.casa",
    "pony.club",
    "of.fashion",
    "on.fashion",
    "of.football",
    "in.london",
    "of.london",
    "for.men",
    "and.mom",
    "for.mom",
    "for.one",
    "for.sale",
    "of.work",
    "to.work",
    "nctu.me",
    "bitballoon.com",
    "netlify.com",
    "4u.com",
    "ngrok.io",
    "nh-serv.co.uk",
    "nfshost.com",
    "dnsking.ch",
    "mypi.co",
    "n4t.co",
    "001www.com",
    "ddnslive.com",
    "myiphost.com",
    "forumz.info",
    "16-b.it",
    "32-b.it",
    "64-b.it",
    "soundcast.me",
    "tcp4.me",
    "dnsup.net",
    "hicam.net",
    "now-dns.net",
    "ownip.net",
    "vpndns.net",
    "dynserv.org",
    "now-dns.org",
    "x443.pw",
    "now-dns.top",
    "ntdll.top",
    "freeddns.us",
    "crafting.xyz",
    "zapto.xyz",
    "nsupdate.info",
    "nerdpol.ovh",
    "blogsyte.com",
    "brasilia.me",
    "cable-modem.org",
    "ciscofreak.com",
    "collegefan.org",
    "couchpotatofries.org",
    "damnserver.com",
    "ddns.me",
    "ditchyourip.com",
    "dnsfor.me",
    "dnsiskinky.com",
    "dvrcam.info",
    "dynns.com",
    "eating-organic.net",
    "fantasyleague.cc",
    "geekgalaxy.com",
    "golffan.us",
    "health-carereform.com",
    "homesecuritymac.com",
    "homesecuritypc.com",
    "hopto.me",
    "ilovecollege.info",
    "loginto.me",
    "mlbfan.org",
    "mmafan.biz",
    "myactivedirectory.com",
    "mydissent.net",
    "myeffect.net",
    "mymediapc.net",
    "mypsx.net",
    "mysecuritycamera.com",
    "mysecuritycamera.net",
    "mysecuritycamera.org",
    "net-freaks.com",
    "nflfan.org",
    "nhlfan.net",
    "no-ip.ca",
    "no-ip.co.uk",
    "no-ip.net",
    "noip.us",
    "onthewifi.com",
    "pgafan.net",
    "point2this.com",
    "pointto.us",
    "privatizehealthinsurance.net",
    "quicksytes.com",
    "read-books.org",
    "securitytactics.com",
    "serveexchange.com",
    "servehumour.com",
    "servep2p.com",
    "servesarcasm.com",
    "stufftoread.com",
    "ufcfan.org",
    "unusualperson.com",
    "workisboring.com",
    "3utilities.com",
    "bounceme.net",
    "ddns.net",
    "ddnsking.com",
    "gotdns.ch",
    "hopto.org",
    "myftp.biz",
    "myftp.org",
    "myvnc.com",
    "no-ip.biz",
    "no-ip.info",
    "no-ip.org",
    "noip.me",
    "redirectme.net",
    "servebeer.com",
    "serveblog.net",
    "servecounterstrike.com",
    "serveftp.com",
    "servegame.com",
    "servehalflife.com",
    "servehttp.com",
    "serveirc.com",
    "serveminecraft.net",
    "servemp3.com",
    "servepics.com",
    "servequake.com",
    "sytes.net",
    "webhop.me",
    "zapto.org",
    "stage.nodeart.io",
    "nodum.co",
    "nodum.io",
    "pcloud.host",
    "nyc.mn",
    "nom.ae",
    "nom.af",
    "nom.ai",
    "nom.al",
    "nym.by",
    "nym.bz",
    "nom.cl",
    "nym.ec",
    "nom.gd",
    "nom.ge",
    "nom.gl",
    "nym.gr",
    "nom.gt",
    "nym.gy",
    "nym.hk",
    "nom.hn",
    "nym.ie",
    "nom.im",
    "nom.ke",
    "nym.kz",
    "nym.la",
    "nym.lc",
    "nom.li",
    "nym.li",
    "nym.lt",
    "nym.lu",
    "nym.me",
    "nom.mk",
    "nym.mn",
    "nym.mx",
    "nom.nu",
    "nym.nz",
    "nym.pe",
    "nym.pt",
    "nom.pw",
    "nom.qa",
    "nym.ro",
    "nom.rs",
    "nom.si",
    "nym.sk",
    "nom.st",
    "nym.su",
    "nym.sx",
    "nom.tj",
    "nym.tw",
    "nom.ug",
    "nom.uy",
    "nom.vc",
    "nom.vg",
    "cya.gg",
    "cloudycluster.net",
    "nid.io",
    "opencraft.hosting",
    "operaunite.com",
    "outsystemscloud.com",
    "ownprovider.com",
    "own.pm",
    "ox.rs",
    "oy.lc",
    "pgfog.com",
    "pagefrontapp.com",
    "art.pl",
    "gliwice.pl",
    "krakow.pl",
    "poznan.pl",
    "wroc.pl",
    "zakopane.pl",
    "pantheonsite.io",
    "gotpantheon.com",
    "mypep.link",
    "on-web.fr",
    "*.platform.sh",
    "*.platformsh.site",
    "dyn53.io",
    "co.bn",
    "xen.prgmr.com",
    "priv.at",
    "prvcy.page",
    "*.dweb.link",
    "protonet.io",
    "chirurgiens-dentistes-en-france.fr",
    "byen.site",
    "pubtls.org",
    "qualifioapp.com",
    "instantcloud.cn",
    "ras.ru",
    "qa2.com",
    "dev-myqnapcloud.com",
    "alpha-myqnapcloud.com",
    "myqnapcloud.com",
    "*.quipelements.com",
    "vapor.cloud",
    "vaporcloud.io",
    "rackmaze.com",
    "rackmaze.net",
    "*.on-rancher.cloud",
    "*.on-rio.io",
    "readthedocs.io",
    "rhcloud.com",
    "app.render.com",
    "onrender.com",
    "repl.co",
    "repl.run",
    "resindevice.io",
    "devices.resinstaging.io",
    "hzc.io",
    "wellbeingzone.eu",
    "ptplus.fit",
    "wellbeingzone.co.uk",
    "git-pages.rit.edu",
    "sandcats.io",
    "logoip.de",
    "logoip.com",
    "schokokeks.net",
    "scrysec.com",
    "firewall-gateway.com",
    "firewall-gateway.de",
    "my-gateway.de",
    "my-router.de",
    "spdns.de",
    "spdns.eu",
    "firewall-gateway.net",
    "my-firewall.org",
    "myfirewall.org",
    "spdns.org",
    "biz.ua",
    "co.ua",
    "pp.ua",
    "shiftedit.io",
    "myshopblocks.com",
    "shopitsite.com",
    "mo-siemens.io",
    "1kapp.com",
    "appchizi.com",
    "applinzi.com",
    "sinaapp.com",
    "vipsinaapp.com",
    "siteleaf.net",
    "bounty-full.com",
    "alpha.bounty-full.com",
    "beta.bounty-full.com",
    "stackhero-network.com",
    "static.land",
    "dev.static.land",
    "sites.static.land",
    "apps.lair.io",
    "*.stolos.io",
    "spacekit.io",
    "customer.speedpartner.de",
    "api.stdlib.com",
    "storj.farm",
    "utwente.io",
    "soc.srcf.net",
    "user.srcf.net",
    "temp-dns.com",
    "applicationcloud.io",
    "scapp.io",
    "*.s5y.io",
    "*.sensiosite.cloud",
    "syncloud.it",
    "diskstation.me",
    "dscloud.biz",
    "dscloud.me",
    "dscloud.mobi",
    "dsmynas.com",
    "dsmynas.net",
    "dsmynas.org",
    "familyds.com",
    "familyds.net",
    "familyds.org",
    "i234.me",
    "myds.me",
    "synology.me",
    "vpnplus.to",
    "taifun-dns.de",
    "gda.pl",
    "gdansk.pl",
    "gdynia.pl",
    "med.pl",
    "sopot.pl",
    "edugit.org",
    "telebit.app",
    "telebit.io",
    "*.telebit.xyz",
    "gwiddle.co.uk",
    "thingdustdata.com",
    "cust.dev.thingdust.io",
    "cust.disrec.thingdust.io",
    "cust.prod.thingdust.io",
    "cust.testing.thingdust.io",
    "arvo.network",
    "azimuth.network",
    "bloxcms.com",
    "townnews-staging.com",
    "12hp.at",
    "2ix.at",
    "4lima.at",
    "lima-city.at",
    "12hp.ch",
    "2ix.ch",
    "4lima.ch",
    "lima-city.ch",
    "trafficplex.cloud",
    "de.cool",
    "12hp.de",
    "2ix.de",
    "4lima.de",
    "lima-city.de",
    "1337.pictures",
    "clan.rip",
    "lima-city.rocks",
    "webspace.rocks",
    "lima.zone",
    "*.transurl.be",
    "*.transurl.eu",
    "*.transurl.nl",
    "tuxfamily.org",
    "dd-dns.de",
    "diskstation.eu",
    "diskstation.org",
    "dray-dns.de",
    "draydns.de",
    "dyn-vpn.de",
    "dynvpn.de",
    "mein-vigor.de",
    "my-vigor.de",
    "my-wan.de",
    "syno-ds.de",
    "synology-diskstation.de",
    "synology-ds.de",
    "uber.space",
    "*.uberspace.de",
    "hk.com",
    "hk.org",
    "ltd.hk",
    "inc.hk",
    "virtualuser.de",
    "virtual-user.de",
    "lib.de.us",
    "2038.io",
    "router.management",
    "v-info.info",
    "voorloper.cloud",
    "wafflecell.com",
    "*.webhare.dev",
    "wedeploy.io",
    "wedeploy.me",
    "wedeploy.sh",
    "remotewd.com",
    "wmflabs.org",
    "half.host",
    "xnbay.com",
    "u2.xnbay.com",
    "u2-local.xnbay.com",
    "cistron.nl",
    "demon.nl",
    "xs4all.space",
    "yandexcloud.net",
    "storage.yandexcloud.net",
    "website.yandexcloud.net",
    "official.academy",
    "yolasite.com",
    "ybo.faith",
    "yombo.me",
    "homelink.one",
    "ybo.party",
    "ybo.review",
    "ybo.science",
    "ybo.trade",
    "nohost.me",
    "noho.st",
    "za.net",
    "za.org",
    "now.sh",
    "bss.design",
    "basicserver.io",
    "virtualserver.io",
    "site.builder.nu",
    "enterprisecloud.nu",
    "zone.id"
  ];
});

// node_modules/psl/index.js
var require_psl = __commonJS((exports2) => {
  "use strict";
  var Punycode = require("punycode");
  var internals = {};
  internals.rules = require_rules().map(function(rule) {
    return {
      rule,
      suffix: rule.replace(/^(\*\.|\!)/, ""),
      punySuffix: -1,
      wildcard: rule.charAt(0) === "*",
      exception: rule.charAt(0) === "!"
    };
  });
  internals.endsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };
  internals.findRule = function(domain) {
    var punyDomain = Punycode.toASCII(domain);
    return internals.rules.reduce(function(memo, rule) {
      if (rule.punySuffix === -1) {
        rule.punySuffix = Punycode.toASCII(rule.suffix);
      }
      if (!internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix) {
        return memo;
      }
      return rule;
    }, null);
  };
  exports2.errorCodes = {
    DOMAIN_TOO_SHORT: "Domain name too short.",
    DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
    LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
    LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
    LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
    LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
    LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
  };
  internals.validate = function(input) {
    var ascii = Punycode.toASCII(input);
    if (ascii.length < 1) {
      return "DOMAIN_TOO_SHORT";
    }
    if (ascii.length > 255) {
      return "DOMAIN_TOO_LONG";
    }
    var labels = ascii.split(".");
    var label;
    for (var i = 0; i < labels.length; ++i) {
      label = labels[i];
      if (!label.length) {
        return "LABEL_TOO_SHORT";
      }
      if (label.length > 63) {
        return "LABEL_TOO_LONG";
      }
      if (label.charAt(0) === "-") {
        return "LABEL_STARTS_WITH_DASH";
      }
      if (label.charAt(label.length - 1) === "-") {
        return "LABEL_ENDS_WITH_DASH";
      }
      if (!/^[a-z0-9\-]+$/.test(label)) {
        return "LABEL_INVALID_CHARS";
      }
    }
  };
  exports2.parse = function(input) {
    if (typeof input !== "string") {
      throw new TypeError("Domain name must be a string.");
    }
    var domain = input.slice(0).toLowerCase();
    if (domain.charAt(domain.length - 1) === ".") {
      domain = domain.slice(0, domain.length - 1);
    }
    var error = internals.validate(domain);
    if (error) {
      return {
        input,
        error: {
          message: exports2.errorCodes[error],
          code: error
        }
      };
    }
    var parsed = {
      input,
      tld: null,
      sld: null,
      domain: null,
      subdomain: null,
      listed: false
    };
    var domainParts = domain.split(".");
    if (domainParts[domainParts.length - 1] === "local") {
      return parsed;
    }
    var handlePunycode = function() {
      if (!/xn--/.test(domain)) {
        return parsed;
      }
      if (parsed.domain) {
        parsed.domain = Punycode.toASCII(parsed.domain);
      }
      if (parsed.subdomain) {
        parsed.subdomain = Punycode.toASCII(parsed.subdomain);
      }
      return parsed;
    };
    var rule = internals.findRule(domain);
    if (!rule) {
      if (domainParts.length < 2) {
        return parsed;
      }
      parsed.tld = domainParts.pop();
      parsed.sld = domainParts.pop();
      parsed.domain = [parsed.sld, parsed.tld].join(".");
      if (domainParts.length) {
        parsed.subdomain = domainParts.pop();
      }
      return handlePunycode();
    }
    parsed.listed = true;
    var tldParts = rule.suffix.split(".");
    var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
    if (rule.exception) {
      privateParts.push(tldParts.shift());
    }
    parsed.tld = tldParts.join(".");
    if (!privateParts.length) {
      return handlePunycode();
    }
    if (rule.wildcard) {
      tldParts.unshift(privateParts.pop());
      parsed.tld = tldParts.join(".");
    }
    if (!privateParts.length) {
      return handlePunycode();
    }
    parsed.sld = privateParts.pop();
    parsed.domain = [parsed.sld, parsed.tld].join(".");
    if (privateParts.length) {
      parsed.subdomain = privateParts.join(".");
    }
    return handlePunycode();
  };
  exports2.get = function(domain) {
    if (!domain) {
      return null;
    }
    return exports2.parse(domain).domain || null;
  };
  exports2.isValid = function(domain) {
    var parsed = exports2.parse(domain);
    return Boolean(parsed.domain && parsed.listed);
  };
});

// node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var psl = require_psl();
  function getPublicSuffix(domain) {
    return psl.get(domain);
  }
  exports2.getPublicSuffix = getPublicSuffix;
});

// node_modules/tough-cookie/lib/store.js
var require_store = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  function Store() {
  }
  exports2.Store = Store;
  Store.prototype.synchronous = false;
  Store.prototype.findCookie = function(domain, path, key, cb) {
    throw new Error("findCookie is not implemented");
  };
  Store.prototype.findCookies = function(domain, path, cb) {
    throw new Error("findCookies is not implemented");
  };
  Store.prototype.putCookie = function(cookie, cb) {
    throw new Error("putCookie is not implemented");
  };
  Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
    throw new Error("updateCookie is not implemented");
  };
  Store.prototype.removeCookie = function(domain, path, key, cb) {
    throw new Error("removeCookie is not implemented");
  };
  Store.prototype.removeCookies = function(domain, path, cb) {
    throw new Error("removeCookies is not implemented");
  };
  Store.prototype.getAllCookies = function(cb) {
    throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
  };
});

// node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var pubsuffix = require_pubsuffix_psl();
  function permuteDomain(domain) {
    var pubSuf = pubsuffix.getPublicSuffix(domain);
    if (!pubSuf) {
      return null;
    }
    if (pubSuf == domain) {
      return [domain];
    }
    var prefix = domain.slice(0, -(pubSuf.length + 1));
    var parts = prefix.split(".").reverse();
    var cur = pubSuf;
    var permutations = [cur];
    while (parts.length) {
      cur = parts.shift() + "." + cur;
      permutations.push(cur);
    }
    return permutations;
  }
  exports2.permuteDomain = permuteDomain;
});

// node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  function pathMatch(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
      return true;
    }
    var idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
      if (cookiePath.substr(-1) === "/") {
        return true;
      }
      if (reqPath.substr(cookiePath.length, 1) === "/") {
        return true;
      }
    }
    return false;
  }
  exports2.pathMatch = pathMatch;
});

// node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var Store = require_store().Store;
  var permuteDomain = require_permuteDomain().permuteDomain;
  var pathMatch = require_pathMatch().pathMatch;
  var util = require("util");
  function MemoryCookieStore() {
    Store.call(this);
    this.idx = {};
  }
  util.inherits(MemoryCookieStore, Store);
  exports2.MemoryCookieStore = MemoryCookieStore;
  MemoryCookieStore.prototype.idx = null;
  MemoryCookieStore.prototype.synchronous = true;
  MemoryCookieStore.prototype.inspect = function() {
    return "{ idx: " + util.inspect(this.idx, false, 2) + " }";
  };
  if (util.inspect.custom) {
    MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;
  }
  MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
    if (!this.idx[domain]) {
      return cb(null, void 0);
    }
    if (!this.idx[domain][path]) {
      return cb(null, void 0);
    }
    return cb(null, this.idx[domain][path][key] || null);
  };
  MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
    var results = [];
    if (!domain) {
      return cb(null, []);
    }
    var pathMatcher;
    if (!path) {
      pathMatcher = function matchAll(domainIndex) {
        for (var curPath in domainIndex) {
          var pathIndex = domainIndex[curPath];
          for (var key in pathIndex) {
            results.push(pathIndex[key]);
          }
        }
      };
    } else {
      pathMatcher = function matchRFC(domainIndex) {
        Object.keys(domainIndex).forEach(function(cookiePath) {
          if (pathMatch(path, cookiePath)) {
            var pathIndex = domainIndex[cookiePath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        });
      };
    }
    var domains = permuteDomain(domain) || [domain];
    var idx = this.idx;
    domains.forEach(function(curDomain) {
      var domainIndex = idx[curDomain];
      if (!domainIndex) {
        return;
      }
      pathMatcher(domainIndex);
    });
    cb(null, results);
  };
  MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
    if (!this.idx[cookie.domain]) {
      this.idx[cookie.domain] = {};
    }
    if (!this.idx[cookie.domain][cookie.path]) {
      this.idx[cookie.domain][cookie.path] = {};
    }
    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
    cb(null);
  };
  MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
    this.putCookie(newCookie, cb);
  };
  MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
    if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
      delete this.idx[domain][path][key];
    }
    cb(null);
  };
  MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
    if (this.idx[domain]) {
      if (path) {
        delete this.idx[domain][path];
      } else {
        delete this.idx[domain];
      }
    }
    return cb(null);
  };
  MemoryCookieStore.prototype.getAllCookies = function(cb) {
    var cookies = [];
    var idx = this.idx;
    var domains = Object.keys(idx);
    domains.forEach(function(domain) {
      var paths = Object.keys(idx[domain]);
      paths.forEach(function(path) {
        var keys = Object.keys(idx[domain][path]);
        keys.forEach(function(key) {
          if (key !== null) {
            cookies.push(idx[domain][path][key]);
          }
        });
      });
    });
    cookies.sort(function(a, b) {
      return (a.creationIndex || 0) - (b.creationIndex || 0);
    });
    cb(null, cookies);
  };
});

// node_modules/tough-cookie/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    author: {
      name: "Jeremy Stashewsky",
      email: "jstash@gmail.com",
      website: "https://github.com/stash"
    },
    contributors: [
      {
        name: "Alexander Savin",
        website: "https://github.com/apsavin"
      },
      {
        name: "Ian Livingstone",
        website: "https://github.com/ianlivingstone"
      },
      {
        name: "Ivan Nikulin",
        website: "https://github.com/inikulin"
      },
      {
        name: "Lalit Kapoor",
        website: "https://github.com/lalitkapoor"
      },
      {
        name: "Sam Thompson",
        website: "https://github.com/sambthompson"
      },
      {
        name: "Sebastian Mayr",
        website: "https://github.com/Sebmaster"
      }
    ],
    license: "BSD-3-Clause",
    name: "tough-cookie",
    description: "RFC6265 Cookies and Cookie Jar for node.js",
    keywords: [
      "HTTP",
      "cookie",
      "cookies",
      "set-cookie",
      "cookiejar",
      "jar",
      "RFC6265",
      "RFC2965"
    ],
    version: "2.4.3",
    homepage: "https://github.com/salesforce/tough-cookie",
    repository: {
      type: "git",
      url: "git://github.com/salesforce/tough-cookie.git"
    },
    bugs: {
      url: "https://github.com/salesforce/tough-cookie/issues"
    },
    main: "./lib/cookie",
    files: [
      "lib"
    ],
    scripts: {
      test: "vows test/*_test.js",
      cover: "nyc --reporter=lcov --reporter=html vows test/*_test.js"
    },
    engines: {
      node: ">=0.8"
    },
    devDependencies: {
      async: "^1.4.2",
      nyc: "^11.6.0",
      "string.prototype.repeat": "^0.2.0",
      vows: "^0.8.1"
    },
    dependencies: {
      psl: "^1.1.24",
      punycode: "^1.4.1"
    }
  };
});

// node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var net2 = require("net");
  var urlParse = require("url").parse;
  var util = require("util");
  var pubsuffix = require_pubsuffix_psl();
  var Store = require_store().Store;
  var MemoryCookieStore = require_memstore().MemoryCookieStore;
  var pathMatch = require_pathMatch().pathMatch;
  var VERSION = require_package().version;
  var punycode;
  try {
    punycode = require("punycode");
  } catch (e) {
    console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
  }
  var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
  var CONTROL_CHARS = /[\x00-\x1F]/;
  var TERMINATORS = ["\n", "\r", "\0"];
  var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
  var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
  var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
  };
  var NUM_TO_MONTH = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var NUM_TO_DAY = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  var MAX_TIME = 2147483647e3;
  var MIN_TIME = 0;
  function parseDigits(token, minDigits, maxDigits, trailingOK) {
    var count = 0;
    while (count < token.length) {
      var c = token.charCodeAt(count);
      if (c <= 47 || c >= 58) {
        break;
      }
      count++;
    }
    if (count < minDigits || count > maxDigits) {
      return null;
    }
    if (!trailingOK && count != token.length) {
      return null;
    }
    return parseInt(token.substr(0, count), 10);
  }
  function parseTime(token) {
    var parts = token.split(":");
    var result = [0, 0, 0];
    if (parts.length !== 3) {
      return null;
    }
    for (var i = 0; i < 3; i++) {
      var trailingOK = i == 2;
      var num = parseDigits(parts[i], 1, 2, trailingOK);
      if (num === null) {
        return null;
      }
      result[i] = num;
    }
    return result;
  }
  function parseMonth(token) {
    token = String(token).substr(0, 3).toLowerCase();
    var num = MONTH_TO_NUM[token];
    return num >= 0 ? num : null;
  }
  function parseDate(str) {
    if (!str) {
      return;
    }
    var tokens = str.split(DATE_DELIM);
    if (!tokens) {
      return;
    }
    var hour = null;
    var minute = null;
    var second = null;
    var dayOfMonth = null;
    var month = null;
    var year = null;
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i].trim();
      if (!token.length) {
        continue;
      }
      var result;
      if (second === null) {
        result = parseTime(token);
        if (result) {
          hour = result[0];
          minute = result[1];
          second = result[2];
          continue;
        }
      }
      if (dayOfMonth === null) {
        result = parseDigits(token, 1, 2, true);
        if (result !== null) {
          dayOfMonth = result;
          continue;
        }
      }
      if (month === null) {
        result = parseMonth(token);
        if (result !== null) {
          month = result;
          continue;
        }
      }
      if (year === null) {
        result = parseDigits(token, 2, 4, true);
        if (result !== null) {
          year = result;
          if (year >= 70 && year <= 99) {
            year += 1900;
          } else if (year >= 0 && year <= 69) {
            year += 2e3;
          }
        }
      }
    }
    if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
      return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
  }
  function formatDate(date) {
    var d = date.getUTCDate();
    d = d >= 10 ? d : "0" + d;
    var h = date.getUTCHours();
    h = h >= 10 ? h : "0" + h;
    var m = date.getUTCMinutes();
    m = m >= 10 ? m : "0" + m;
    var s = date.getUTCSeconds();
    s = s >= 10 ? s : "0" + s;
    return NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT";
  }
  function canonicalDomain(str) {
    if (str == null) {
      return null;
    }
    str = str.trim().replace(/^\./, "");
    if (punycode && /[^\u0001-\u007f]/.test(str)) {
      str = punycode.toASCII(str);
    }
    return str.toLowerCase();
  }
  function domainMatch(str, domStr, canonicalize) {
    if (str == null || domStr == null) {
      return null;
    }
    if (canonicalize !== false) {
      str = canonicalDomain(str);
      domStr = canonicalDomain(domStr);
    }
    if (str == domStr) {
      return true;
    }
    if (net2.isIP(str)) {
      return false;
    }
    var idx = str.indexOf(domStr);
    if (idx <= 0) {
      return false;
    }
    if (str.length !== domStr.length + idx) {
      return false;
    }
    if (str.substr(idx - 1, 1) !== ".") {
      return false;
    }
    return true;
  }
  function defaultPath(path) {
    if (!path || path.substr(0, 1) !== "/") {
      return "/";
    }
    if (path === "/") {
      return path;
    }
    var rightSlash = path.lastIndexOf("/");
    if (rightSlash === 0) {
      return "/";
    }
    return path.slice(0, rightSlash);
  }
  function trimTerminator(str) {
    for (var t = 0; t < TERMINATORS.length; t++) {
      var terminatorIdx = str.indexOf(TERMINATORS[t]);
      if (terminatorIdx !== -1) {
        str = str.substr(0, terminatorIdx);
      }
    }
    return str;
  }
  function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    var firstEq = cookiePair.indexOf("=");
    if (looseMode) {
      if (firstEq === 0) {
        cookiePair = cookiePair.substr(1);
        firstEq = cookiePair.indexOf("=");
      }
    } else {
      if (firstEq <= 0) {
        return;
      }
    }
    var cookieName, cookieValue;
    if (firstEq <= 0) {
      cookieName = "";
      cookieValue = cookiePair.trim();
    } else {
      cookieName = cookiePair.substr(0, firstEq).trim();
      cookieValue = cookiePair.substr(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
      return;
    }
    var c = new Cookie();
    c.key = cookieName;
    c.value = cookieValue;
    return c;
  }
  function parse(str, options) {
    if (!options || typeof options !== "object") {
      options = {};
    }
    str = str.trim();
    var firstSemi = str.indexOf(";");
    var cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
    var c = parseCookiePair(cookiePair, !!options.loose);
    if (!c) {
      return;
    }
    if (firstSemi === -1) {
      return c;
    }
    var unparsed = str.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
      return c;
    }
    var cookie_avs = unparsed.split(";");
    while (cookie_avs.length) {
      var av = cookie_avs.shift().trim();
      if (av.length === 0) {
        continue;
      }
      var av_sep = av.indexOf("=");
      var av_key, av_value;
      if (av_sep === -1) {
        av_key = av;
        av_value = null;
      } else {
        av_key = av.substr(0, av_sep);
        av_value = av.substr(av_sep + 1);
      }
      av_key = av_key.trim().toLowerCase();
      if (av_value) {
        av_value = av_value.trim();
      }
      switch (av_key) {
        case "expires":
          if (av_value) {
            var exp = parseDate(av_value);
            if (exp) {
              c.expires = exp;
            }
          }
          break;
        case "max-age":
          if (av_value) {
            if (/^-?[0-9]+$/.test(av_value)) {
              var delta = parseInt(av_value, 10);
              c.setMaxAge(delta);
            }
          }
          break;
        case "domain":
          if (av_value) {
            var domain = av_value.trim().replace(/^\./, "");
            if (domain) {
              c.domain = domain.toLowerCase();
            }
          }
          break;
        case "path":
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
        case "secure":
          c.secure = true;
          break;
        case "httponly":
          c.httpOnly = true;
          break;
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
      }
    }
    return c;
  }
  function jsonParse(str) {
    var obj;
    try {
      obj = JSON.parse(str);
    } catch (e) {
      return e;
    }
    return obj;
  }
  function fromJSON(str) {
    if (!str) {
      return null;
    }
    var obj;
    if (typeof str === "string") {
      obj = jsonParse(str);
      if (obj instanceof Error) {
        return null;
      }
    } else {
      obj = str;
    }
    var c = new Cookie();
    for (var i = 0; i < Cookie.serializableProperties.length; i++) {
      var prop = Cookie.serializableProperties[i];
      if (obj[prop] === void 0 || obj[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (obj[prop] === null) {
          c[prop] = null;
        } else {
          c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
        }
      } else {
        c[prop] = obj[prop];
      }
    }
    return c;
  }
  function cookieCompare(a, b) {
    var cmp = 0;
    var aPathLen = a.path ? a.path.length : 0;
    var bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
      return cmp;
    }
    var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
    var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = a.creationIndex - b.creationIndex;
    return cmp;
  }
  function permutePath(path) {
    if (path === "/") {
      return ["/"];
    }
    if (path.lastIndexOf("/") === path.length - 1) {
      path = path.substr(0, path.length - 1);
    }
    var permutations = [path];
    while (path.length > 1) {
      var lindex = path.lastIndexOf("/");
      if (lindex === 0) {
        break;
      }
      path = path.substr(0, lindex);
      permutations.push(path);
    }
    permutations.push("/");
    return permutations;
  }
  function getCookieContext(url) {
    if (url instanceof Object) {
      return url;
    }
    try {
      url = decodeURI(url);
    } catch (err) {
    }
    return urlParse(url);
  }
  function Cookie(options) {
    options = options || {};
    Object.keys(options).forEach(function(prop) {
      if (Cookie.prototype.hasOwnProperty(prop) && Cookie.prototype[prop] !== options[prop] && prop.substr(0, 1) !== "_") {
        this[prop] = options[prop];
      }
    }, this);
    this.creation = this.creation || new Date();
    Object.defineProperty(this, "creationIndex", {
      configurable: false,
      enumerable: false,
      writable: true,
      value: ++Cookie.cookiesCreated
    });
  }
  Cookie.cookiesCreated = 0;
  Cookie.parse = parse;
  Cookie.fromJSON = fromJSON;
  Cookie.prototype.key = "";
  Cookie.prototype.value = "";
  Cookie.prototype.expires = "Infinity";
  Cookie.prototype.maxAge = null;
  Cookie.prototype.domain = null;
  Cookie.prototype.path = null;
  Cookie.prototype.secure = false;
  Cookie.prototype.httpOnly = false;
  Cookie.prototype.extensions = null;
  Cookie.prototype.hostOnly = null;
  Cookie.prototype.pathIsDefault = null;
  Cookie.prototype.creation = null;
  Cookie.prototype.lastAccessed = null;
  Object.defineProperty(Cookie.prototype, "creationIndex", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: 0
  });
  Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(function(prop) {
    return !(Cookie.prototype[prop] instanceof Function || prop === "creationIndex" || prop.substr(0, 1) === "_");
  });
  Cookie.prototype.inspect = function inspect() {
    var now = Date.now();
    return 'Cookie="' + this.toString() + "; hostOnly=" + (this.hostOnly != null ? this.hostOnly : "?") + "; aAge=" + (this.lastAccessed ? now - this.lastAccessed.getTime() + "ms" : "?") + "; cAge=" + (this.creation ? now - this.creation.getTime() + "ms" : "?") + '"';
  };
  if (util.inspect.custom) {
    Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;
  }
  Cookie.prototype.toJSON = function() {
    var obj = {};
    var props = Cookie.serializableProperties;
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (this[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (this[prop] === null) {
          obj[prop] = null;
        } else {
          obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
        }
      } else if (prop === "maxAge") {
        if (this[prop] !== null) {
          obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
        }
      } else {
        if (this[prop] !== Cookie.prototype[prop]) {
          obj[prop] = this[prop];
        }
      }
    }
    return obj;
  };
  Cookie.prototype.clone = function() {
    return fromJSON(this.toJSON());
  };
  Cookie.prototype.validate = function validate() {
    if (!COOKIE_OCTETS.test(this.value)) {
      return false;
    }
    if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
      return false;
    }
    if (this.maxAge != null && this.maxAge <= 0) {
      return false;
    }
    if (this.path != null && !PATH_VALUE.test(this.path)) {
      return false;
    }
    var cdomain = this.cdomain();
    if (cdomain) {
      if (cdomain.match(/\.$/)) {
        return false;
      }
      var suffix = pubsuffix.getPublicSuffix(cdomain);
      if (suffix == null) {
        return false;
      }
    }
    return true;
  };
  Cookie.prototype.setExpires = function setExpires(exp) {
    if (exp instanceof Date) {
      this.expires = exp;
    } else {
      this.expires = parseDate(exp) || "Infinity";
    }
  };
  Cookie.prototype.setMaxAge = function setMaxAge(age) {
    if (age === Infinity || age === -Infinity) {
      this.maxAge = age.toString();
    } else {
      this.maxAge = age;
    }
  };
  Cookie.prototype.cookieString = function cookieString() {
    var val = this.value;
    if (val == null) {
      val = "";
    }
    if (this.key === "") {
      return val;
    }
    return this.key + "=" + val;
  };
  Cookie.prototype.toString = function toString() {
    var str = this.cookieString();
    if (this.expires != Infinity) {
      if (this.expires instanceof Date) {
        str += "; Expires=" + formatDate(this.expires);
      } else {
        str += "; Expires=" + this.expires;
      }
    }
    if (this.maxAge != null && this.maxAge != Infinity) {
      str += "; Max-Age=" + this.maxAge;
    }
    if (this.domain && !this.hostOnly) {
      str += "; Domain=" + this.domain;
    }
    if (this.path) {
      str += "; Path=" + this.path;
    }
    if (this.secure) {
      str += "; Secure";
    }
    if (this.httpOnly) {
      str += "; HttpOnly";
    }
    if (this.extensions) {
      this.extensions.forEach(function(ext) {
        str += "; " + ext;
      });
    }
    return str;
  };
  Cookie.prototype.TTL = function TTL(now) {
    if (this.maxAge != null) {
      return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
    }
    var expires = this.expires;
    if (expires != Infinity) {
      if (!(expires instanceof Date)) {
        expires = parseDate(expires) || Infinity;
      }
      if (expires == Infinity) {
        return Infinity;
      }
      return expires.getTime() - (now || Date.now());
    }
    return Infinity;
  };
  Cookie.prototype.expiryTime = function expiryTime(now) {
    if (this.maxAge != null) {
      var relativeTo = now || this.creation || new Date();
      var age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
      return relativeTo.getTime() + age;
    }
    if (this.expires == Infinity) {
      return Infinity;
    }
    return this.expires.getTime();
  };
  Cookie.prototype.expiryDate = function expiryDate(now) {
    var millisec = this.expiryTime(now);
    if (millisec == Infinity) {
      return new Date(MAX_TIME);
    } else if (millisec == -Infinity) {
      return new Date(MIN_TIME);
    } else {
      return new Date(millisec);
    }
  };
  Cookie.prototype.isPersistent = function isPersistent() {
    return this.maxAge != null || this.expires != Infinity;
  };
  Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
    if (this.domain == null) {
      return null;
    }
    return canonicalDomain(this.domain);
  };
  function CookieJar(store, options) {
    if (typeof options === "boolean") {
      options = {rejectPublicSuffixes: options};
    } else if (options == null) {
      options = {};
    }
    if (options.rejectPublicSuffixes != null) {
      this.rejectPublicSuffixes = options.rejectPublicSuffixes;
    }
    if (options.looseMode != null) {
      this.enableLooseMode = options.looseMode;
    }
    if (!store) {
      store = new MemoryCookieStore();
    }
    this.store = store;
  }
  CookieJar.prototype.store = null;
  CookieJar.prototype.rejectPublicSuffixes = true;
  CookieJar.prototype.enableLooseMode = false;
  var CAN_BE_SYNC = [];
  CAN_BE_SYNC.push("setCookie");
  CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
    var err;
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var loose = this.enableLooseMode;
    if (options.loose != null) {
      loose = options.loose;
    }
    if (!(cookie instanceof Cookie)) {
      cookie = Cookie.parse(cookie, {loose});
    }
    if (!cookie) {
      err = new Error("Cookie failed to parse");
      return cb(options.ignoreError ? null : err);
    }
    var now = options.now || new Date();
    if (this.rejectPublicSuffixes && cookie.domain) {
      var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
      if (suffix == null) {
        err = new Error("Cookie has domain set to a public suffix");
        return cb(options.ignoreError ? null : err);
      }
    }
    if (cookie.domain) {
      if (!domainMatch(host, cookie.cdomain(), false)) {
        err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host);
        return cb(options.ignoreError ? null : err);
      }
      if (cookie.hostOnly == null) {
        cookie.hostOnly = false;
      }
    } else {
      cookie.hostOnly = true;
      cookie.domain = host;
    }
    if (!cookie.path || cookie.path[0] !== "/") {
      cookie.path = defaultPath(context.pathname);
      cookie.pathIsDefault = true;
    }
    if (options.http === false && cookie.httpOnly) {
      err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
      return cb(options.ignoreError ? null : err);
    }
    var store = this.store;
    if (!store.updateCookie) {
      store.updateCookie = function(oldCookie, newCookie, cb2) {
        this.putCookie(newCookie, cb2);
      };
    }
    function withCookie(err2, oldCookie) {
      if (err2) {
        return cb(err2);
      }
      var next2 = function(err3) {
        if (err3) {
          return cb(err3);
        } else {
          cb(null, cookie);
        }
      };
      if (oldCookie) {
        if (options.http === false && oldCookie.httpOnly) {
          err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err2);
        }
        cookie.creation = oldCookie.creation;
        cookie.creationIndex = oldCookie.creationIndex;
        cookie.lastAccessed = now;
        store.updateCookie(oldCookie, cookie, next2);
      } else {
        cookie.creation = cookie.lastAccessed = now;
        store.putCookie(cookie, next2);
      }
    }
    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
  };
  CAN_BE_SYNC.push("getCookies");
  CookieJar.prototype.getCookies = function(url, options, cb) {
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var path = context.pathname || "/";
    var secure = options.secure;
    if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
      secure = true;
    }
    var http = options.http;
    if (http == null) {
      http = true;
    }
    var now = options.now || Date.now();
    var expireCheck = options.expire !== false;
    var allPaths = !!options.allPaths;
    var store = this.store;
    function matchingCookie(c) {
      if (c.hostOnly) {
        if (c.domain != host) {
          return false;
        }
      } else {
        if (!domainMatch(host, c.domain, false)) {
          return false;
        }
      }
      if (!allPaths && !pathMatch(path, c.path)) {
        return false;
      }
      if (c.secure && !secure) {
        return false;
      }
      if (c.httpOnly && !http) {
        return false;
      }
      if (expireCheck && c.expiryTime() <= now) {
        store.removeCookie(c.domain, c.path, c.key, function() {
        });
        return false;
      }
      return true;
    }
    store.findCookies(host, allPaths ? null : path, function(err, cookies) {
      if (err) {
        return cb(err);
      }
      cookies = cookies.filter(matchingCookie);
      if (options.sort !== false) {
        cookies = cookies.sort(cookieCompare);
      }
      var now2 = new Date();
      cookies.forEach(function(c) {
        c.lastAccessed = now2;
      });
      cb(null, cookies);
    });
  };
  CAN_BE_SYNC.push("getCookieString");
  CookieJar.prototype.getCookieString = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next2 = function(err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies.sort(cookieCompare).map(function(c) {
          return c.cookieString();
        }).join("; "));
      }
    };
    args.push(next2);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push("getSetCookieStrings");
  CookieJar.prototype.getSetCookieStrings = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next2 = function(err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies.map(function(c) {
          return c.toString();
        }));
      }
    };
    args.push(next2);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push("serialize");
  CookieJar.prototype.serialize = function(cb) {
    var type = this.store.constructor.name;
    if (type === "Object") {
      type = null;
    }
    var serialized = {
      version: "tough-cookie@" + VERSION,
      storeType: type,
      rejectPublicSuffixes: !!this.rejectPublicSuffixes,
      cookies: []
    };
    if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
      return cb(new Error("store does not support getAllCookies and cannot be serialized"));
    }
    this.store.getAllCookies(function(err, cookies) {
      if (err) {
        return cb(err);
      }
      serialized.cookies = cookies.map(function(cookie) {
        cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
        delete cookie.creationIndex;
        return cookie;
      });
      return cb(null, serialized);
    });
  };
  CookieJar.prototype.toJSON = function() {
    return this.serializeSync();
  };
  CAN_BE_SYNC.push("_importCookies");
  CookieJar.prototype._importCookies = function(serialized, cb) {
    var jar = this;
    var cookies = serialized.cookies;
    if (!cookies || !Array.isArray(cookies)) {
      return cb(new Error("serialized jar has no cookies array"));
    }
    cookies = cookies.slice();
    function putNext(err) {
      if (err) {
        return cb(err);
      }
      if (!cookies.length) {
        return cb(err, jar);
      }
      var cookie;
      try {
        cookie = fromJSON(cookies.shift());
      } catch (e) {
        return cb(e);
      }
      if (cookie === null) {
        return putNext(null);
      }
      jar.store.putCookie(cookie, putNext);
    }
    putNext();
  };
  CookieJar.deserialize = function(strOrObj, store, cb) {
    if (arguments.length !== 3) {
      cb = store;
      store = null;
    }
    var serialized;
    if (typeof strOrObj === "string") {
      serialized = jsonParse(strOrObj);
      if (serialized instanceof Error) {
        return cb(serialized);
      }
    } else {
      serialized = strOrObj;
    }
    var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    jar._importCookies(serialized, function(err) {
      if (err) {
        return cb(err);
      }
      cb(null, jar);
    });
  };
  CookieJar.deserializeSync = function(strOrObj, store) {
    var serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
    var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    if (!jar.store.synchronous) {
      throw new Error("CookieJar store is not synchronous; use async API instead.");
    }
    jar._importCookiesSync(serialized);
    return jar;
  };
  CookieJar.fromJSON = CookieJar.deserializeSync;
  CAN_BE_SYNC.push("clone");
  CookieJar.prototype.clone = function(newStore, cb) {
    if (arguments.length === 1) {
      cb = newStore;
      newStore = null;
    }
    this.serialize(function(err, serialized) {
      if (err) {
        return cb(err);
      }
      CookieJar.deserialize(newStore, serialized, cb);
    });
  };
  function syncWrap(method) {
    return function() {
      if (!this.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      var args = Array.prototype.slice.call(arguments);
      var syncErr, syncResult;
      args.push(function syncCb(err, result) {
        syncErr = err;
        syncResult = result;
      });
      this[method].apply(this, args);
      if (syncErr) {
        throw syncErr;
      }
      return syncResult;
    };
  }
  CAN_BE_SYNC.forEach(function(method) {
    CookieJar.prototype[method + "Sync"] = syncWrap(method);
  });
  exports2.CookieJar = CookieJar;
  exports2.Cookie = Cookie;
  exports2.Store = Store;
  exports2.MemoryCookieStore = MemoryCookieStore;
  exports2.parseDate = parseDate;
  exports2.formatDate = formatDate;
  exports2.parse = parse;
  exports2.fromJSON = fromJSON;
  exports2.domainMatch = domainMatch;
  exports2.defaultPath = defaultPath;
  exports2.pathMatch = pathMatch;
  exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
  exports2.cookieCompare = cookieCompare;
  exports2.permuteDomain = require_permuteDomain().permuteDomain;
  exports2.permutePath = permutePath;
  exports2.canonicalDomain = canonicalDomain;
});

// node_modules/request/lib/cookies.js
var require_cookies = __commonJS((exports2) => {
  "use strict";
  var tough = require_cookie();
  var Cookie = tough.Cookie;
  var CookieJar = tough.CookieJar;
  exports2.parse = function(str) {
    if (str && str.uri) {
      str = str.uri;
    }
    if (typeof str !== "string") {
      throw new Error("The cookie function only accepts STRING as param");
    }
    return Cookie.parse(str, {loose: true});
  };
  function RequestJar(store) {
    var self2 = this;
    self2._jar = new CookieJar(store, {looseMode: true});
  }
  RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
    var self2 = this;
    return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
  };
  RequestJar.prototype.getCookieString = function(uri) {
    var self2 = this;
    return self2._jar.getCookieStringSync(uri);
  };
  RequestJar.prototype.getCookies = function(uri) {
    var self2 = this;
    return self2._jar.getCookiesSync(uri);
  };
  exports2.jar = function(store) {
    return new RequestJar(store);
  };
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  exports2 = module2.exports = stringify;
  exports2.getSerialize = serializer;
  function stringify(obj, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
  }
  function serializer(replacer, cycleReplacer) {
    var stack = [], keys = [];
    if (cycleReplacer == null)
      cycleReplacer = function(key, value) {
        if (stack[0] === value)
          return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
    return function(key, value) {
      if (stack.length > 0) {
        var thisPos = stack.indexOf(this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
        if (~stack.indexOf(value))
          value = cycleReplacer.call(this, key, value);
      } else
        stack.push(value);
      return replacer == null ? value : replacer.call(this, key, value);
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/request/lib/helpers.js
var require_helpers = __commonJS((exports2) => {
  "use strict";
  var jsonSafeStringify = require_stringify();
  var crypto = require("crypto");
  var Buffer2 = require_safe_buffer().Buffer;
  var defer = typeof setImmediate === "undefined" ? process.nextTick : setImmediate;
  function paramsHaveRequestBody(params) {
    return params.body || params.requestBodyStream || params.json && typeof params.json !== "boolean" || params.multipart;
  }
  function safeStringify(obj, replacer) {
    var ret;
    try {
      ret = JSON.stringify(obj, replacer);
    } catch (e) {
      ret = jsonSafeStringify(obj, replacer);
    }
    return ret;
  }
  function md5(str) {
    return crypto.createHash("md5").update(str).digest("hex");
  }
  function isReadStream(rs) {
    return rs.readable && rs.path && rs.mode;
  }
  function toBase64(str) {
    return Buffer2.from(str || "", "utf8").toString("base64");
  }
  function copy(obj) {
    var o = {};
    Object.keys(obj).forEach(function(i) {
      o[i] = obj[i];
    });
    return o;
  }
  function version() {
    var numbers = process.version.replace("v", "").split(".");
    return {
      major: parseInt(numbers[0], 10),
      minor: parseInt(numbers[1], 10),
      patch: parseInt(numbers[2], 10)
    };
  }
  exports2.paramsHaveRequestBody = paramsHaveRequestBody;
  exports2.safeStringify = safeStringify;
  exports2.md5 = md5;
  exports2.isReadStream = isReadStream;
  exports2.toBase64 = toBase64;
  exports2.copy = copy;
  exports2.version = version;
  exports2.defer = defer;
});

// node_modules/aws-sign2/index.js
var require_aws_sign2 = __commonJS((exports2, module2) => {
  /*!
   *  Copyright 2010 LearnBoost <dev@learnboost.com>
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var crypto = require("crypto");
  var parse = require("url").parse;
  var keys = [
    "acl",
    "location",
    "logging",
    "notification",
    "partNumber",
    "policy",
    "requestPayment",
    "torrent",
    "uploadId",
    "uploads",
    "versionId",
    "versioning",
    "versions",
    "website"
  ];
  function authorization(options) {
    return "AWS " + options.key + ":" + sign(options);
  }
  module2.exports = authorization;
  module2.exports.authorization = authorization;
  function hmacSha1(options) {
    return crypto.createHmac("sha1", options.secret).update(options.message).digest("base64");
  }
  module2.exports.hmacSha1 = hmacSha1;
  function sign(options) {
    options.message = stringToSign(options);
    return hmacSha1(options);
  }
  module2.exports.sign = sign;
  function signQuery(options) {
    options.message = queryStringToSign(options);
    return hmacSha1(options);
  }
  module2.exports.signQuery = signQuery;
  function stringToSign(options) {
    var headers = options.amazonHeaders || "";
    if (headers)
      headers += "\n";
    var r = [
      options.verb,
      options.md5,
      options.contentType,
      options.date ? options.date.toUTCString() : "",
      headers + options.resource
    ];
    return r.join("\n");
  }
  module2.exports.stringToSign = stringToSign;
  function queryStringToSign(options) {
    return "GET\n\n\n" + options.date + "\n" + options.resource;
  }
  module2.exports.queryStringToSign = queryStringToSign;
  function canonicalizeHeaders(headers) {
    var buf = [], fields = Object.keys(headers);
    for (var i = 0, len = fields.length; i < len; ++i) {
      var field = fields[i], val = headers[field], field = field.toLowerCase();
      if (field.indexOf("x-amz") !== 0)
        continue;
      buf.push(field + ":" + val);
    }
    return buf.sort().join("\n");
  }
  module2.exports.canonicalizeHeaders = canonicalizeHeaders;
  function canonicalizeResource(resource) {
    var url = parse(resource, true), path = url.pathname, buf = [];
    Object.keys(url.query).forEach(function(key) {
      if (!~keys.indexOf(key))
        return;
      var val = url.query[key] == "" ? "" : "=" + encodeURIComponent(url.query[key]);
      buf.push(key + val);
    });
    return path + (buf.length ? "?" + buf.sort().join("&") : "");
  }
  module2.exports.canonicalizeResource = canonicalizeResource;
});

// node_modules/aws4/lru.js
var require_lru = __commonJS((exports2, module2) => {
  module2.exports = function(size) {
    return new LruCache(size);
  };
  function LruCache(size) {
    this.capacity = size | 0;
    this.map = Object.create(null);
    this.list = new DoublyLinkedList();
  }
  LruCache.prototype.get = function(key) {
    var node = this.map[key];
    if (node == null)
      return void 0;
    this.used(node);
    return node.val;
  };
  LruCache.prototype.set = function(key, val) {
    var node = this.map[key];
    if (node != null) {
      node.val = val;
    } else {
      if (!this.capacity)
        this.prune();
      if (!this.capacity)
        return false;
      node = new DoublyLinkedNode(key, val);
      this.map[key] = node;
      this.capacity--;
    }
    this.used(node);
    return true;
  };
  LruCache.prototype.used = function(node) {
    this.list.moveToFront(node);
  };
  LruCache.prototype.prune = function() {
    var node = this.list.pop();
    if (node != null) {
      delete this.map[node.key];
      this.capacity++;
    }
  };
  function DoublyLinkedList() {
    this.firstNode = null;
    this.lastNode = null;
  }
  DoublyLinkedList.prototype.moveToFront = function(node) {
    if (this.firstNode == node)
      return;
    this.remove(node);
    if (this.firstNode == null) {
      this.firstNode = node;
      this.lastNode = node;
      node.prev = null;
      node.next = null;
    } else {
      node.prev = null;
      node.next = this.firstNode;
      node.next.prev = node;
      this.firstNode = node;
    }
  };
  DoublyLinkedList.prototype.pop = function() {
    var lastNode = this.lastNode;
    if (lastNode != null) {
      this.remove(lastNode);
    }
    return lastNode;
  };
  DoublyLinkedList.prototype.remove = function(node) {
    if (this.firstNode == node) {
      this.firstNode = node.next;
    } else if (node.prev != null) {
      node.prev.next = node.next;
    }
    if (this.lastNode == node) {
      this.lastNode = node.prev;
    } else if (node.next != null) {
      node.next.prev = node.prev;
    }
  };
  function DoublyLinkedNode(key, val) {
    this.key = key;
    this.val = val;
    this.prev = null;
    this.next = null;
  }
});

// node_modules/aws4/aws4.js
var require_aws4 = __commonJS((exports2) => {
  var aws4 = exports2;
  var url = require("url");
  var querystring = require("querystring");
  var crypto = require("crypto");
  var lru = require_lru();
  var credentialsCache = lru(1e3);
  function hmac(key, string, encoding) {
    return crypto.createHmac("sha256", key).update(string, "utf8").digest(encoding);
  }
  function hash(string, encoding) {
    return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
  }
  function encodeRfc3986(urlEncodedString) {
    return urlEncodedString.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function RequestSigner(request, credentials) {
    if (typeof request === "string")
      request = url.parse(request);
    var headers = request.headers = request.headers || {}, hostParts = this.matchHost(request.hostname || request.host || headers.Host || headers.host);
    this.request = request;
    this.credentials = credentials || this.defaultCredentials();
    this.service = request.service || hostParts[0] || "";
    this.region = request.region || hostParts[1] || "us-east-1";
    if (this.service === "email")
      this.service = "ses";
    if (!request.method && request.body)
      request.method = "POST";
    if (!headers.Host && !headers.host) {
      headers.Host = request.hostname || request.host || this.createHost();
      if (request.port)
        headers.Host += ":" + request.port;
    }
    if (!request.hostname && !request.host)
      request.hostname = headers.Host || headers.host;
    this.isCodeCommitGit = this.service === "codecommit" && request.method === "GIT";
  }
  RequestSigner.prototype.matchHost = function(host) {
    var match = (host || "").match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/);
    var hostParts = (match || []).slice(1, 3);
    if (hostParts[1] === "es")
      hostParts = hostParts.reverse();
    return hostParts;
  };
  RequestSigner.prototype.isSingleRegion = function() {
    if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1")
      return true;
    return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
  };
  RequestSigner.prototype.createHost = function() {
    var region = this.isSingleRegion() ? "" : (this.service === "s3" && this.region !== "us-east-1" ? "-" : ".") + this.region, service = this.service === "ses" ? "email" : this.service;
    return service + region + ".amazonaws.com";
  };
  RequestSigner.prototype.prepareRequest = function() {
    this.parsePath();
    var request = this.request, headers = request.headers, query;
    if (request.signQuery) {
      this.parsedPath.query = query = this.parsedPath.query || {};
      if (this.credentials.sessionToken)
        query["X-Amz-Security-Token"] = this.credentials.sessionToken;
      if (this.service === "s3" && !query["X-Amz-Expires"])
        query["X-Amz-Expires"] = 86400;
      if (query["X-Amz-Date"])
        this.datetime = query["X-Amz-Date"];
      else
        query["X-Amz-Date"] = this.getDateTime();
      query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
      query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
      query["X-Amz-SignedHeaders"] = this.signedHeaders();
    } else {
      if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
        if (request.body && !headers["Content-Type"] && !headers["content-type"])
          headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
        if (request.body && !headers["Content-Length"] && !headers["content-length"])
          headers["Content-Length"] = Buffer.byteLength(request.body);
        if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
          headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
          headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
        if (headers["X-Amz-Date"] || headers["x-amz-date"])
          this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
        else
          headers["X-Amz-Date"] = this.getDateTime();
      }
      delete headers.Authorization;
      delete headers.authorization;
    }
  };
  RequestSigner.prototype.sign = function() {
    if (!this.parsedPath)
      this.prepareRequest();
    if (this.request.signQuery) {
      this.parsedPath.query["X-Amz-Signature"] = this.signature();
    } else {
      this.request.headers.Authorization = this.authHeader();
    }
    this.request.path = this.formatPath();
    return this.request;
  };
  RequestSigner.prototype.getDateTime = function() {
    if (!this.datetime) {
      var headers = this.request.headers, date = new Date(headers.Date || headers.date || new Date());
      this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
      if (this.isCodeCommitGit)
        this.datetime = this.datetime.slice(0, -1);
    }
    return this.datetime;
  };
  RequestSigner.prototype.getDate = function() {
    return this.getDateTime().substr(0, 8);
  };
  RequestSigner.prototype.authHeader = function() {
    return [
      "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
      "SignedHeaders=" + this.signedHeaders(),
      "Signature=" + this.signature()
    ].join(", ");
  };
  RequestSigner.prototype.signature = function() {
    var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
    if (!kCredentials) {
      kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
      kRegion = hmac(kDate, this.region);
      kService = hmac(kRegion, this.service);
      kCredentials = hmac(kService, "aws4_request");
      credentialsCache.set(cacheKey, kCredentials);
    }
    return hmac(kCredentials, this.stringToSign(), "hex");
  };
  RequestSigner.prototype.stringToSign = function() {
    return [
      "AWS4-HMAC-SHA256",
      this.getDateTime(),
      this.credentialString(),
      hash(this.canonicalString(), "hex")
    ].join("\n");
  };
  RequestSigner.prototype.canonicalString = function() {
    if (!this.parsedPath)
      this.prepareRequest();
    var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
    if (this.service === "s3" && this.request.signQuery) {
      bodyHash = "UNSIGNED-PAYLOAD";
    } else if (this.isCodeCommitGit) {
      bodyHash = "";
    } else {
      bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
    }
    if (query) {
      queryStr = encodeRfc3986(querystring.stringify(Object.keys(query).sort().reduce(function(obj, key) {
        if (!key)
          return obj;
        obj[key] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key].slice().sort();
        return obj;
      }, {})));
    }
    if (pathStr !== "/") {
      if (normalizePath)
        pathStr = pathStr.replace(/\/{2,}/g, "/");
      pathStr = pathStr.split("/").reduce(function(path, piece) {
        if (normalizePath && piece === "..") {
          path.pop();
        } else if (!normalizePath || piece !== ".") {
          if (decodePath)
            piece = decodeURIComponent(piece);
          path.push(encodeRfc3986(encodeURIComponent(piece)));
        }
        return path;
      }, []).join("/");
      if (pathStr[0] !== "/")
        pathStr = "/" + pathStr;
      if (decodeSlashesInPath)
        pathStr = pathStr.replace(/%2F/g, "/");
    }
    return [
      this.request.method || "GET",
      pathStr,
      queryStr,
      this.canonicalHeaders() + "\n",
      this.signedHeaders(),
      bodyHash
    ].join("\n");
  };
  RequestSigner.prototype.canonicalHeaders = function() {
    var headers = this.request.headers;
    function trimAll(header) {
      return header.toString().trim().replace(/\s+/g, " ");
    }
    return Object.keys(headers).sort(function(a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    }).map(function(key) {
      return key.toLowerCase() + ":" + trimAll(headers[key]);
    }).join("\n");
  };
  RequestSigner.prototype.signedHeaders = function() {
    return Object.keys(this.request.headers).map(function(key) {
      return key.toLowerCase();
    }).sort().join(";");
  };
  RequestSigner.prototype.credentialString = function() {
    return [
      this.getDate(),
      this.region,
      this.service,
      "aws4_request"
    ].join("/");
  };
  RequestSigner.prototype.defaultCredentials = function() {
    var env = process.env;
    return {
      accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
      secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
      sessionToken: env.AWS_SESSION_TOKEN
    };
  };
  RequestSigner.prototype.parsePath = function() {
    var path = this.request.path || "/", queryIx = path.indexOf("?"), query = null;
    if (queryIx >= 0) {
      query = querystring.parse(path.slice(queryIx + 1));
      path = path.slice(0, queryIx);
    }
    if (/[^0-9A-Za-z!'()*\-._~%/]/.test(path)) {
      path = path.split("/").map(function(piece) {
        return encodeURIComponent(decodeURIComponent(piece));
      }).join("/");
    }
    this.parsedPath = {
      path,
      query
    };
  };
  RequestSigner.prototype.formatPath = function() {
    var path = this.parsedPath.path, query = this.parsedPath.query;
    if (!query)
      return path;
    if (query[""] != null)
      delete query[""];
    return path + "?" + encodeRfc3986(querystring.stringify(query));
  };
  aws4.RequestSigner = RequestSigner;
  aws4.sign = function(request, credentials) {
    return new RequestSigner(request, credentials).sign();
  };
});

// node_modules/assert-plus/assert.js
var require_assert = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var Stream = require("stream").Stream;
  var util = require("util");
  var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
      message: util.format("%s (%s) is required", name, expected),
      actual: actual === void 0 ? typeof arg : actual(arg),
      expected,
      operator: oper || "===",
      stackStartFunction: _toss.caller
    });
  }
  function _getClass(arg) {
    return Object.prototype.toString.call(arg).slice(8, -1);
  }
  function noop() {
  }
  var types = {
    bool: {
      check: function(arg) {
        return typeof arg === "boolean";
      }
    },
    func: {
      check: function(arg) {
        return typeof arg === "function";
      }
    },
    string: {
      check: function(arg) {
        return typeof arg === "string";
      }
    },
    object: {
      check: function(arg) {
        return typeof arg === "object" && arg !== null;
      }
    },
    number: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg);
      }
    },
    finite: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
      }
    },
    buffer: {
      check: function(arg) {
        return Buffer.isBuffer(arg);
      },
      operator: "Buffer.isBuffer"
    },
    array: {
      check: function(arg) {
        return Array.isArray(arg);
      },
      operator: "Array.isArray"
    },
    stream: {
      check: function(arg) {
        return arg instanceof Stream;
      },
      operator: "instanceof",
      actual: _getClass
    },
    date: {
      check: function(arg) {
        return arg instanceof Date;
      },
      operator: "instanceof",
      actual: _getClass
    },
    regexp: {
      check: function(arg) {
        return arg instanceof RegExp;
      },
      operator: "instanceof",
      actual: _getClass
    },
    uuid: {
      check: function(arg) {
        return typeof arg === "string" && UUID_REGEXP.test(arg);
      },
      operator: "isUUID"
    }
  };
  function _setExports(ndebug) {
    var keys = Object.keys(types);
    var out;
    if (process.env.NODE_NDEBUG) {
      out = noop;
    } else {
      out = function(arg, msg) {
        if (!arg) {
          _toss(msg, "true", arg);
        }
      };
    }
    keys.forEach(function(k) {
      if (ndebug) {
        out[k] = noop;
        return;
      }
      var type = types[k];
      out[k] = function(arg, msg) {
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optional" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      out[name] = function(arg, msg) {
        if (arg === void 0 || arg === null) {
          return;
        }
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "arrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0; i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optionalArrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (arg === void 0 || arg === null) {
          return;
        }
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0; i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    Object.keys(assert).forEach(function(k) {
      if (k === "AssertionError") {
        out[k] = assert[k];
        return;
      }
      if (ndebug) {
        out[k] = noop;
        return;
      }
      out[k] = assert[k];
    });
    out._setExports = _setExports;
    return out;
  }
  module2.exports = _setExports(process.env.NODE_NDEBUG);
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports2, module2) => {
  "use strict";
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module2.exports = safer;
});

// node_modules/sshpk/lib/algs.js
var require_algs = __commonJS((exports2, module2) => {
  var Buffer2 = require_safer().Buffer;
  var algInfo = {
    dsa: {
      parts: ["p", "q", "g", "y"],
      sizePart: "p"
    },
    rsa: {
      parts: ["e", "n"],
      sizePart: "n"
    },
    ecdsa: {
      parts: ["curve", "Q"],
      sizePart: "Q"
    },
    ed25519: {
      parts: ["A"],
      sizePart: "A"
    }
  };
  algInfo["curve25519"] = algInfo["ed25519"];
  var algPrivInfo = {
    dsa: {
      parts: ["p", "q", "g", "y", "x"]
    },
    rsa: {
      parts: ["n", "e", "d", "iqmp", "p", "q"]
    },
    ecdsa: {
      parts: ["curve", "Q", "d"]
    },
    ed25519: {
      parts: ["A", "k"]
    }
  };
  algPrivInfo["curve25519"] = algPrivInfo["ed25519"];
  var hashAlgs = {
    md5: true,
    sha1: true,
    sha256: true,
    sha384: true,
    sha512: true
  };
  var curves = {
    nistp256: {
      size: 256,
      pkcs8oid: "1.2.840.10045.3.1.7",
      p: Buffer2.from("00ffffffff 00000001 00000000 0000000000000000 ffffffff ffffffff ffffffff".replace(/ /g, ""), "hex"),
      a: Buffer2.from("00FFFFFFFF 00000001 00000000 0000000000000000 FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
      b: Buffer2.from("5ac635d8 aa3a93e7 b3ebbd55 769886bc651d06b0 cc53b0f6 3bce3c3e 27d2604b".replace(/ /g, ""), "hex"),
      s: Buffer2.from("00c49d3608 86e70493 6a6678e1 139d26b7819f7e90".replace(/ /g, ""), "hex"),
      n: Buffer2.from("00ffffffff 00000000 ffffffff ffffffffbce6faad a7179e84 f3b9cac2 fc632551".replace(/ /g, ""), "hex"),
      G: Buffer2.from("046b17d1f2 e12c4247 f8bce6e5 63a440f277037d81 2deb33a0 f4a13945 d898c2964fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e162bce3357 6b315ece cbb64068 37bf51f5".replace(/ /g, ""), "hex")
    },
    nistp384: {
      size: 384,
      pkcs8oid: "1.3.132.0.34",
      p: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffeffffffff 00000000 00000000 ffffffff".replace(/ /g, ""), "hex"),
      a: Buffer2.from("00FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFEFFFFFFFF 00000000 00000000 FFFFFFFC".replace(/ /g, ""), "hex"),
      b: Buffer2.from("b3312fa7 e23ee7e4 988e056b e3f82d19181d9c6e fe814112 0314088f 5013875ac656398d 8a2ed19d 2a85c8ed d3ec2aef".replace(/ /g, ""), "hex"),
      s: Buffer2.from("00a335926a a319a27a 1d00896a 6773a4827acdac73".replace(/ /g, ""), "hex"),
      n: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff c7634d81 f4372ddf581a0db2 48b0a77a ecec196a ccc52973".replace(/ /g, ""), "hex"),
      G: Buffer2.from("04aa87ca22 be8b0537 8eb1c71e f320ad746e1d3b62 8ba79b98 59f741e0 82542a385502f25d bf55296c 3a545e38 72760ab73617de4a 96262c6f 5d9e98bf 9292dc29f8f41dbd 289a147c e9da3113 b5f0b8c00a60b1ce 1d7e819d 7a431d7c 90ea0e5f".replace(/ /g, ""), "hex")
    },
    nistp521: {
      size: 521,
      pkcs8oid: "1.3.132.0.35",
      p: Buffer2.from("01ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffff".replace(/ /g, ""), "hex"),
      a: Buffer2.from("01FFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
      b: Buffer2.from("51953eb961 8e1c9a1f 929a21a0 b68540eea2da725b 99b315f3 b8b48991 8ef109e156193951 ec7e937b 1652c0bd 3bb1bf073573df88 3d2c34f1 ef451fd4 6b503f00".replace(/ /g, ""), "hex"),
      s: Buffer2.from("00d09e8800 291cb853 96cc6717 393284aaa0da64ba".replace(/ /g, ""), "hex"),
      n: Buffer2.from("01ffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffa51868783 bf2f966b 7fcc0148 f709a5d03bb5c9b8 899c47ae bb6fb71e 91386409".replace(/ /g, ""), "hex"),
      G: Buffer2.from("0400c6 858e06b7 0404e9cd 9e3ecb66 2395b4429c648139 053fb521 f828af60 6b4d3dbaa14b5e77 efe75928 fe1dc127 a2ffa8de3348b3c1 856a429b f97e7e31 c2e5bd660118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd998f54449 579b4468 17afbd17 273e662c97ee7299 5ef42640 c550b901 3fad0761353c7086 a272c240 88be9476 9fd16650".replace(/ /g, ""), "hex")
    }
  };
  module2.exports = {
    info: algInfo,
    privInfo: algPrivInfo,
    hashAlgs,
    curves
  };
});

// node_modules/sshpk/lib/errors.js
var require_errors = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var util = require("util");
  function FingerprintFormatError(fp, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, FingerprintFormatError);
    this.name = "FingerprintFormatError";
    this.fingerprint = fp;
    this.format = format;
    this.message = "Fingerprint format is not supported, or is invalid: ";
    if (fp !== void 0)
      this.message += " fingerprint = " + fp;
    if (format !== void 0)
      this.message += " format = " + format;
  }
  util.inherits(FingerprintFormatError, Error);
  function InvalidAlgorithmError(alg) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, InvalidAlgorithmError);
    this.name = "InvalidAlgorithmError";
    this.algorithm = alg;
    this.message = 'Algorithm "' + alg + '" is not supported';
  }
  util.inherits(InvalidAlgorithmError, Error);
  function KeyParseError(name, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyParseError);
    this.name = "KeyParseError";
    this.format = format;
    this.keyName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format + " format key: " + innerErr.message;
  }
  util.inherits(KeyParseError, Error);
  function SignatureParseError(type, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, SignatureParseError);
    this.name = "SignatureParseError";
    this.type = type;
    this.format = format;
    this.innerErr = innerErr;
    this.message = "Failed to parse the given data as a " + type + " signature in " + format + " format: " + innerErr.message;
  }
  util.inherits(SignatureParseError, Error);
  function CertificateParseError(name, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, CertificateParseError);
    this.name = "CertificateParseError";
    this.format = format;
    this.certName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format + " format certificate: " + innerErr.message;
  }
  util.inherits(CertificateParseError, Error);
  function KeyEncryptedError(name, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyEncryptedError);
    this.name = "KeyEncryptedError";
    this.format = format;
    this.keyName = name;
    this.message = "The " + format + " format key " + name + " is encrypted (password-protected), and no passphrase was provided in `options`";
  }
  util.inherits(KeyEncryptedError, Error);
  module2.exports = {
    FingerprintFormatError,
    InvalidAlgorithmError,
    KeyParseError,
    SignatureParseError,
    KeyEncryptedError,
    CertificateParseError
  };
});

// node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS((exports2, module2) => {
  module2.exports = {
    newInvalidAsn1Error: function(msg) {
      var e = new Error();
      e.name = "InvalidAsn1Error";
      e.message = msg || "";
      return e;
    }
  };
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS((exports2, module2) => {
  module2.exports = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128
  };
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types();
  var errors = require_errors2();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  function Reader(data) {
    if (!data || !Buffer2.isBuffer(data))
      throw new TypeError("data must be a node Buffer");
    this._buf = data;
    this._size = data.length;
    this._len = 0;
    this._offset = 0;
  }
  Object.defineProperty(Reader.prototype, "length", {
    enumerable: true,
    get: function() {
      return this._len;
    }
  });
  Object.defineProperty(Reader.prototype, "offset", {
    enumerable: true,
    get: function() {
      return this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "remain", {
    get: function() {
      return this._size - this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "buffer", {
    get: function() {
      return this._buf.slice(this._offset);
    }
  });
  Reader.prototype.readByte = function(peek) {
    if (this._size - this._offset < 1)
      return null;
    var b = this._buf[this._offset] & 255;
    if (!peek)
      this._offset += 1;
    return b;
  };
  Reader.prototype.peek = function() {
    return this.readByte(true);
  };
  Reader.prototype.readLength = function(offset) {
    if (offset === void 0)
      offset = this._offset;
    if (offset >= this._size)
      return null;
    var lenB = this._buf[offset++] & 255;
    if (lenB === null)
      return null;
    if ((lenB & 128) === 128) {
      lenB &= 127;
      if (lenB === 0)
        throw newInvalidAsn1Error("Indefinite length not supported");
      if (lenB > 4)
        throw newInvalidAsn1Error("encoding too long");
      if (this._size - offset < lenB)
        return null;
      this._len = 0;
      for (var i = 0; i < lenB; i++)
        this._len = (this._len << 8) + (this._buf[offset++] & 255);
    } else {
      this._len = lenB;
    }
    return offset;
  };
  Reader.prototype.readSequence = function(tag) {
    var seq = this.peek();
    if (seq === null)
      return null;
    if (tag !== void 0 && tag !== seq)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    this._offset = o;
    return seq;
  };
  Reader.prototype.readInt = function() {
    return this._readTag(ASN1.Integer);
  };
  Reader.prototype.readBoolean = function() {
    return this._readTag(ASN1.Boolean) === 0 ? false : true;
  };
  Reader.prototype.readEnumeration = function() {
    return this._readTag(ASN1.Enumeration);
  };
  Reader.prototype.readString = function(tag, retbuf) {
    if (!tag)
      tag = ASN1.OctetString;
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    if (this.length === 0)
      return retbuf ? Buffer2.alloc(0) : "";
    var str = this._buf.slice(this._offset, this._offset + this.length);
    this._offset += this.length;
    return retbuf ? str : str.toString("utf8");
  };
  Reader.prototype.readOID = function(tag) {
    if (!tag)
      tag = ASN1.OID;
    var b = this.readString(tag, true);
    if (b === null)
      return null;
    var values = [];
    var value = 0;
    for (var i = 0; i < b.length; i++) {
      var byte = b[i] & 255;
      value <<= 7;
      value += byte & 127;
      if ((byte & 128) === 0) {
        values.push(value);
        value = 0;
      }
    }
    value = values.shift();
    values.unshift(value % 40);
    values.unshift(value / 40 >> 0);
    return values.join(".");
  };
  Reader.prototype._readTag = function(tag) {
    assert.ok(tag !== void 0);
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > 4)
      throw newInvalidAsn1Error("Integer too long: " + this.length);
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    var fb = this._buf[this._offset];
    var value = 0;
    for (var i = 0; i < this.length; i++) {
      value <<= 8;
      value |= this._buf[this._offset++] & 255;
    }
    if ((fb & 128) === 128 && i !== 4)
      value -= 1 << i * 8;
    return value >> 0;
  };
  module2.exports = Reader;
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types();
  var errors = require_errors2();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  var DEFAULT_OPTS = {
    size: 1024,
    growthFactor: 8
  };
  function merge(from, to) {
    assert.ok(from);
    assert.equal(typeof from, "object");
    assert.ok(to);
    assert.equal(typeof to, "object");
    var keys = Object.getOwnPropertyNames(from);
    keys.forEach(function(key) {
      if (to[key])
        return;
      var value = Object.getOwnPropertyDescriptor(from, key);
      Object.defineProperty(to, key, value);
    });
    return to;
  }
  function Writer(options) {
    options = merge(DEFAULT_OPTS, options || {});
    this._buf = Buffer2.alloc(options.size || 1024);
    this._size = this._buf.length;
    this._offset = 0;
    this._options = options;
    this._seq = [];
  }
  Object.defineProperty(Writer.prototype, "buffer", {
    get: function() {
      if (this._seq.length)
        throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
      return this._buf.slice(0, this._offset);
    }
  });
  Writer.prototype.writeByte = function(b) {
    if (typeof b !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(1);
    this._buf[this._offset++] = b;
  };
  Writer.prototype.writeInt = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Integer;
    var sz = 4;
    while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
      sz--;
      i <<= 8;
    }
    if (sz > 4)
      throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
    this._ensure(2 + sz);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = sz;
    while (sz-- > 0) {
      this._buf[this._offset++] = (i & 4278190080) >>> 24;
      i <<= 8;
    }
  };
  Writer.prototype.writeNull = function() {
    this.writeByte(ASN1.Null);
    this.writeByte(0);
  };
  Writer.prototype.writeEnumeration = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Enumeration;
    return this.writeInt(i, tag);
  };
  Writer.prototype.writeBoolean = function(b, tag) {
    if (typeof b !== "boolean")
      throw new TypeError("argument must be a Boolean");
    if (typeof tag !== "number")
      tag = ASN1.Boolean;
    this._ensure(3);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = 1;
    this._buf[this._offset++] = b ? 255 : 0;
  };
  Writer.prototype.writeString = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string (was: " + typeof s + ")");
    if (typeof tag !== "number")
      tag = ASN1.OctetString;
    var len = Buffer2.byteLength(s);
    this.writeByte(tag);
    this.writeLength(len);
    if (len) {
      this._ensure(len);
      this._buf.write(s, this._offset);
      this._offset += len;
    }
  };
  Writer.prototype.writeBuffer = function(buf, tag) {
    if (typeof tag !== "number")
      throw new TypeError("tag must be a number");
    if (!Buffer2.isBuffer(buf))
      throw new TypeError("argument must be a buffer");
    this.writeByte(tag);
    this.writeLength(buf.length);
    this._ensure(buf.length);
    buf.copy(this._buf, this._offset, 0, buf.length);
    this._offset += buf.length;
  };
  Writer.prototype.writeStringArray = function(strings) {
    if (!strings instanceof Array)
      throw new TypeError("argument must be an Array[String]");
    var self2 = this;
    strings.forEach(function(s) {
      self2.writeString(s);
    });
  };
  Writer.prototype.writeOID = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string");
    if (typeof tag !== "number")
      tag = ASN1.OID;
    if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
      throw new Error("argument is not a valid OID string");
    function encodeOctet(bytes2, octet) {
      if (octet < 128) {
        bytes2.push(octet);
      } else if (octet < 16384) {
        bytes2.push(octet >>> 7 | 128);
        bytes2.push(octet & 127);
      } else if (octet < 2097152) {
        bytes2.push(octet >>> 14 | 128);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else if (octet < 268435456) {
        bytes2.push(octet >>> 21 | 128);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else {
        bytes2.push((octet >>> 28 | 128) & 255);
        bytes2.push((octet >>> 21 | 128) & 255);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      }
    }
    var tmp = s.split(".");
    var bytes = [];
    bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
    tmp.slice(2).forEach(function(b) {
      encodeOctet(bytes, parseInt(b, 10));
    });
    var self2 = this;
    this._ensure(2 + bytes.length);
    this.writeByte(tag);
    this.writeLength(bytes.length);
    bytes.forEach(function(b) {
      self2.writeByte(b);
    });
  };
  Writer.prototype.writeLength = function(len) {
    if (typeof len !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(4);
    if (len <= 127) {
      this._buf[this._offset++] = len;
    } else if (len <= 255) {
      this._buf[this._offset++] = 129;
      this._buf[this._offset++] = len;
    } else if (len <= 65535) {
      this._buf[this._offset++] = 130;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else if (len <= 16777215) {
      this._buf[this._offset++] = 131;
      this._buf[this._offset++] = len >> 16;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else {
      throw newInvalidAsn1Error("Length too long (> 4 bytes)");
    }
  };
  Writer.prototype.startSequence = function(tag) {
    if (typeof tag !== "number")
      tag = ASN1.Sequence | ASN1.Constructor;
    this.writeByte(tag);
    this._seq.push(this._offset);
    this._ensure(3);
    this._offset += 3;
  };
  Writer.prototype.endSequence = function() {
    var seq = this._seq.pop();
    var start = seq + 3;
    var len = this._offset - start;
    if (len <= 127) {
      this._shift(start, len, -2);
      this._buf[seq] = len;
    } else if (len <= 255) {
      this._shift(start, len, -1);
      this._buf[seq] = 129;
      this._buf[seq + 1] = len;
    } else if (len <= 65535) {
      this._buf[seq] = 130;
      this._buf[seq + 1] = len >> 8;
      this._buf[seq + 2] = len;
    } else if (len <= 16777215) {
      this._shift(start, len, 1);
      this._buf[seq] = 131;
      this._buf[seq + 1] = len >> 16;
      this._buf[seq + 2] = len >> 8;
      this._buf[seq + 3] = len;
    } else {
      throw newInvalidAsn1Error("Sequence too long");
    }
  };
  Writer.prototype._shift = function(start, len, shift) {
    assert.ok(start !== void 0);
    assert.ok(len !== void 0);
    assert.ok(shift);
    this._buf.copy(this._buf, start + shift, start, start + len);
    this._offset += shift;
  };
  Writer.prototype._ensure = function(len) {
    assert.ok(len);
    if (this._size - this._offset < len) {
      var sz = this._size * this._options.growthFactor;
      if (sz - this._offset < len)
        sz += len;
      var buf = Buffer2.alloc(sz);
      this._buf.copy(buf, 0, 0, this._offset);
      this._buf = buf;
      this._size = sz;
    }
  };
  module2.exports = Writer;
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS((exports2, module2) => {
  var errors = require_errors2();
  var types = require_types();
  var Reader = require_reader();
  var Writer = require_writer();
  module2.exports = {
    Reader,
    Writer
  };
  for (var t in types) {
    if (types.hasOwnProperty(t))
      module2.exports[t] = types[t];
  }
  for (var e in errors) {
    if (errors.hasOwnProperty(e))
      module2.exports[e] = errors[e];
  }
});

// node_modules/asn1/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  var Ber = require_ber();
  module2.exports = {
    Ber,
    BerReader: Ber.Reader,
    BerWriter: Ber.Writer
  };
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS((exports2, module2) => {
  (function() {
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      if (a != null)
        if (typeof a == "number")
          this.fromNumber(a, b, c);
        else if (b == null && typeof a != "string")
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this[i] & 32767;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this[i] & 16383;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 268435455;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr, vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this[0] = x;
      else if (x < -1)
        this[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x >> this.DB - sh;
        } else
          this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this[i] & (1 << p) - 1) << k - p;
            d |= this[--i] >> (p += this.DB - k);
          } else {
            d = this[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this[i] - a[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t2;
      if ((t2 = x >>> 16) != 0) {
        x = t2;
        r += 16;
      }
      if ((t2 = x >> 8) != 0) {
        x = t2;
        r += 8;
      }
      if ((t2 = x >> 4) != 0) {
        x = t2;
        r += 4;
      }
      if ((t2 = x >> 2) != 0) {
        x = t2;
        r += 2;
      }
      if ((t2 = x >> 1) != 0) {
        x = t2;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r[i + n] = this[i];
      for (i = n - 1; i >= 0; --i)
        r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r[i + ds + 1] = this[i] >> cbs | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0)
        r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r[i++] = this.DV + c;
      else if (c > 0)
        r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < y.t; ++i)
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q2, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q2 != null)
          q2.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t2 = q2 == null ? nbi() : q2;
      y.dlShiftTo(j, t2);
      if (r.compareTo(t2) >= 0) {
        r[r.t++] = 1;
        r.subTo(t2, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t2);
      t2.subTo(y, y);
      while (y.t < ys)
        y[y.t++] = 0;
      while (--j >= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t2);
          r.subTo(t2, r);
          while (r[i] < --qd)
            r.subTo(t2, r);
        }
      }
      if (q2 != null) {
        r.drShiftTo(ys, q2);
        if (ts != ms)
          BigInteger.ZERO.subTo(q2, q2);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z2.mulTo(r2, g, r);
        else {
          var t2 = r;
          r = r2;
          r2 = t2;
        }
      }
      return z2.revert(r);
    }
    function bnModPowInt(e, m) {
      var z2;
      if (e < 256 || m.isEven())
        z2 = new Classic(m);
      else
        z2 = new Montgomery(m);
      return this.exp(e, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t == 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
      this.divRemTo(d, y, z2);
      while (y.signum() > 0) {
        r = (a + z2.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z2);
      }
      return z2.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == "number") {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t2 = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t2 > 0)
          x[0] &= (1 << t2) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this[i] & (1 << p) - 1) << 8 - p;
            d |= this[--i] >> (p += this.DB - 8);
          } else {
            d = this[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r[i] = op(this[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r[i] = op(f, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this[i] != 0)
          return i * this.DB + lbit(this[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r[i++] = c;
      else if (c < -1)
        r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q2 = nbi(), r = nbi();
      this.divRemTo(a, q2, r);
      return new Array(q2, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t)
          this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z2;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z2 = new Classic(m);
      else if (m.isEven())
        z2 = new Barrett(m);
      else
        z2 = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e[j] >> i - k1 & km;
        else {
          w = (e[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z2.sqrTo(r, r2);
          else {
            t2 = r;
            r = r2;
            r2 = t2;
          }
          z2.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & 1 << i) == 0) {
          z2.sqrTo(r, r2);
          t2 = r;
          r = r2;
          r2 = t2;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z2.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t2 = x;
        x = y;
        y = t2;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      t2 = t2 + 1 >> 1;
      if (t2 > lowprimes.length)
        t2 = lowprimes.length;
      var a = nbi();
      for (var i = 0; i < t2; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    BigInteger.prototype.Barrett = Barrett;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= x >> 8 & 255;
      rng_pool[rng_pptr++] ^= x >> 16 & 255;
      rng_pool[rng_pptr++] ^= x >> 24 & 255;
      if (rng_pptr >= rng_psize)
        rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array();
      rng_pptr = 0;
      var t;
      if (typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t = 0; t < 32; ++t)
            rng_pool[rng_pptr++] = ua[t];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var z = window.crypto.random(32);
          for (t = 0; t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i;
      for (i = 0; i < ba.length; ++i)
        ba[i] = rng_get_byte();
    }
    function SecureRandom2() {
    }
    SecureRandom2.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array();
    }
    function ARC4init(key) {
      var i, j, t2;
      for (i = 0; i < 256; ++i)
        this.S[i] = i;
      j = 0;
      for (i = 0; i < 256; ++i) {
        j = j + this.S[i] + key[i % key.length] & 255;
        t2 = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t2;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t2;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      t2 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t2;
      return this.S[t2 + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour();
    }
    var rng_psize = 256;
    BigInteger.SecureRandom = SecureRandom2;
    BigInteger.BigInteger = BigInteger;
    if (typeof exports2 !== "undefined") {
      exports2 = module2.exports = BigInteger;
    } else {
      this.BigInteger = BigInteger;
      this.SecureRandom = SecureRandom2;
    }
  }).call(exports2);
});

// node_modules/ecc-jsbn/lib/ec.js
var require_ec = __commonJS((exports2, module2) => {
  var BigInteger = require_jsbn().BigInteger;
  var Barrett = BigInteger.prototype.Barrett;
  function ECFieldElementFp(q2, x) {
    this.x = x;
    this.q = q2;
  }
  function feFpEquals(other) {
    if (other == this)
      return true;
    return this.q.equals(other.q) && this.x.equals(other.x);
  }
  function feFpToBigInteger() {
    return this.x;
  }
  function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
  }
  function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
  }
  function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
  }
  function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
  }
  function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
  }
  function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
  }
  ECFieldElementFp.prototype.equals = feFpEquals;
  ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
  ECFieldElementFp.prototype.negate = feFpNegate;
  ECFieldElementFp.prototype.add = feFpAdd;
  ECFieldElementFp.prototype.subtract = feFpSubtract;
  ECFieldElementFp.prototype.multiply = feFpMultiply;
  ECFieldElementFp.prototype.square = feFpSquare;
  ECFieldElementFp.prototype.divide = feFpDivide;
  function ECPointFp(curve, x, y, z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    if (z == null) {
      this.z = BigInteger.ONE;
    } else {
      this.z = z;
    }
    this.zinv = null;
  }
  function pointFpGetX() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpGetY() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpEquals(other) {
    if (other == this)
      return true;
    if (this.isInfinity())
      return other.isInfinity();
    if (other.isInfinity())
      return this.isInfinity();
    var u, v;
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if (!u.equals(BigInteger.ZERO))
      return false;
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
  }
  function pointFpIsInfinity() {
    if (this.x == null && this.y == null)
      return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
  }
  function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
  }
  function pointFpAdd(b) {
    if (this.isInfinity())
      return b;
    if (b.isInfinity())
      return this;
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
    if (BigInteger.ZERO.equals(v)) {
      if (BigInteger.ZERO.equals(u)) {
        return this.twice();
      }
      return this.curve.getInfinity();
    }
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var x2 = b.x.toBigInteger();
    var y2 = b.y.toBigInteger();
    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpTwice() {
    if (this.isInfinity())
      return this;
    if (this.y.toBigInteger().signum() == 0)
      return this.curve.getInfinity();
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();
    var w = x1.square().multiply(THREE);
    if (!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpMultiply(k) {
    if (this.isInfinity())
      return this;
    if (k.signum() == 0)
      return this.curve.getInfinity();
    var e = k;
    var h = e.multiply(new BigInteger("3"));
    var neg = this.negate();
    var R = this;
    var i;
    for (i = h.bitLength() - 2; i > 0; --i) {
      R = R.twice();
      var hBit = h.testBit(i);
      var eBit = e.testBit(i);
      if (hBit != eBit) {
        R = R.add(hBit ? this : neg);
      }
    }
    return R;
  }
  function pointFpMultiplyTwo(j, x, k) {
    var i;
    if (j.bitLength() > k.bitLength())
      i = j.bitLength() - 1;
    else
      i = k.bitLength() - 1;
    var R = this.curve.getInfinity();
    var both = this.add(x);
    while (i >= 0) {
      R = R.twice();
      if (j.testBit(i)) {
        if (k.testBit(i)) {
          R = R.add(both);
        } else {
          R = R.add(this);
        }
      } else {
        if (k.testBit(i)) {
          R = R.add(x);
        }
      }
      --i;
    }
    return R;
  }
  ECPointFp.prototype.getX = pointFpGetX;
  ECPointFp.prototype.getY = pointFpGetY;
  ECPointFp.prototype.equals = pointFpEquals;
  ECPointFp.prototype.isInfinity = pointFpIsInfinity;
  ECPointFp.prototype.negate = pointFpNegate;
  ECPointFp.prototype.add = pointFpAdd;
  ECPointFp.prototype.twice = pointFpTwice;
  ECPointFp.prototype.multiply = pointFpMultiply;
  ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
  function ECCurveFp(q2, a, b) {
    this.q = q2;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
  }
  function curveFpGetQ() {
    return this.q;
  }
  function curveFpGetA() {
    return this.a;
  }
  function curveFpGetB() {
    return this.b;
  }
  function curveFpEquals(other) {
    if (other == this)
      return true;
    return this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b);
  }
  function curveFpGetInfinity() {
    return this.infinity;
  }
  function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
  }
  function curveReduce(x) {
    this.reducer.reduce(x);
  }
  function curveFpEncodePointHex(p) {
    if (p.isInfinity())
      return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var yHex = p.getY().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0)
      oLen++;
    while (xHex.length < oLen) {
      xHex = "0" + xHex;
    }
    while (yHex.length < oLen) {
      yHex = "0" + yHex;
    }
    return "04" + xHex + yHex;
  }
  ECCurveFp.prototype.getQ = curveFpGetQ;
  ECCurveFp.prototype.getA = curveFpGetA;
  ECCurveFp.prototype.getB = curveFpGetB;
  ECCurveFp.prototype.equals = curveFpEquals;
  ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
  ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
  ECCurveFp.prototype.reduce = curveReduce;
  ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
  ECCurveFp.prototype.decodePointHex = function(s) {
    var yIsEven;
    switch (parseInt(s.substr(0, 2), 16)) {
      case 0:
        return this.infinity;
      case 2:
        yIsEven = false;
      case 3:
        if (yIsEven == void 0)
          yIsEven = true;
        var len = s.length - 2;
        var xHex = s.substr(2, len);
        var x = this.fromBigInteger(new BigInteger(xHex, 16));
        var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
        var beta = alpha.sqrt();
        if (beta == null)
          throw "Invalid point compression";
        var betaValue = beta.toBigInteger();
        if (betaValue.testBit(0) != yIsEven) {
          beta = this.fromBigInteger(this.getQ().subtract(betaValue));
        }
        return new ECPointFp(this, x, beta);
      case 4:
      case 6:
      case 7:
        var len = (s.length - 2) / 2;
        var xHex = s.substr(2, len);
        var yHex = s.substr(len + 2, len);
        return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));
      default:
        return null;
    }
  };
  ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
    if (p.isInfinity())
      return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0)
      oLen++;
    while (xHex.length < oLen)
      xHex = "0" + xHex;
    var yPrefix;
    if (p.getY().toBigInteger().isEven())
      yPrefix = "02";
    else
      yPrefix = "03";
    return yPrefix + xHex;
  };
  ECFieldElementFp.prototype.getR = function() {
    if (this.r != void 0)
      return this.r;
    this.r = null;
    var bitLength = this.q.bitLength();
    if (bitLength > 128) {
      var firstWord = this.q.shiftRight(bitLength - 64);
      if (firstWord.intValue() == -1) {
        this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
      }
    }
    return this.r;
  };
  ECFieldElementFp.prototype.modMult = function(x1, x2) {
    return this.modReduce(x1.multiply(x2));
  };
  ECFieldElementFp.prototype.modReduce = function(x) {
    if (this.getR() != null) {
      var qLen = q.bitLength();
      while (x.bitLength() > qLen + 1) {
        var u = x.shiftRight(qLen);
        var v = x.subtract(u.shiftLeft(qLen));
        if (!this.getR().equals(BigInteger.ONE)) {
          u = u.multiply(this.getR());
        }
        x = u.add(v);
      }
      while (x.compareTo(q) >= 0) {
        x = x.subtract(q);
      }
    } else {
      x = x.mod(q);
    }
    return x;
  };
  ECFieldElementFp.prototype.sqrt = function() {
    if (!this.q.testBit(0))
      throw "unsupported";
    if (this.q.testBit(1)) {
      var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
      return z.square().equals(this) ? z : null;
    }
    var qMinusOne = this.q.subtract(BigInteger.ONE);
    var legendreExponent = qMinusOne.shiftRight(1);
    if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
      return null;
    }
    var u = qMinusOne.shiftRight(2);
    var k = u.shiftLeft(1).add(BigInteger.ONE);
    var Q = this.x;
    var fourQ = modDouble(modDouble(Q));
    var U, V;
    do {
      var P;
      do {
        P = new BigInteger(this.q.bitLength(), new SecureRandom());
      } while (P.compareTo(this.q) >= 0 || !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne));
      var result = this.lucasSequence(P, Q, k);
      U = result[0];
      V = result[1];
      if (this.modMult(V, V).equals(fourQ)) {
        if (V.testBit(0)) {
          V = V.add(q);
        }
        V = V.shiftRight(1);
        return new ECFieldElementFp(q, V);
      }
    } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
    return null;
  };
  ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
    var n = k.bitLength();
    var s = k.getLowestSetBit();
    var Uh = BigInteger.ONE;
    var Vl = BigInteger.TWO;
    var Vh = P;
    var Ql = BigInteger.ONE;
    var Qh = BigInteger.ONE;
    for (var j = n - 1; j >= s + 1; --j) {
      Ql = this.modMult(Ql, Qh);
      if (k.testBit(j)) {
        Qh = this.modMult(Ql, Q);
        Uh = this.modMult(Uh, Vh);
        Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
      } else {
        Qh = Ql;
        Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
        Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      }
    }
    Ql = this.modMult(Ql, Qh);
    Qh = this.modMult(Ql, Q);
    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
    Ql = this.modMult(Ql, Qh);
    for (var j = 1; j <= s; ++j) {
      Uh = this.modMult(Uh, Vl);
      Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      Ql = this.modMult(Ql, Ql);
    }
    return [Uh, Vl];
  };
  var exports2 = {
    ECCurveFp,
    ECPointFp,
    ECFieldElementFp
  };
  module2.exports = exports2;
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports2, module2) => {
  (function(nacl) {
    "use strict";
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init)
        for (i = 0; i < init.length; i++)
          r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h, l) {
      x[i] = h >> 24 & 255;
      x[i + 1] = h >> 16 & 255;
      x[i + 2] = h >> 8 & 255;
      x[i + 3] = h & 255;
      x[i + 4] = l >> 24 & 255;
      x[i + 5] = l >> 16 & 255;
      x[i + 6] = l >> 8 & 255;
      x[i + 7] = l & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; i++)
        d |= x[xi + i] ^ y[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++)
        z[i] = 0;
      for (i = 0; i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++)
        z[i] = 0;
      for (i = 0; i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++)
          c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1; i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32)
        return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32)
        return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0; i < 32; i++)
        m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q2, b) {
      var t, c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q2[i]);
        p[i] ^= t;
        q2[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function crypto_scalarmult(q2, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (i = 0; i < 31; i++)
        z[i] = n[i];
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254; i >= 0; --i) {
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0; j < 16; j++) {
              h = wh[j];
              l = wl[j];
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0; i < n; i++)
        x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q2) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q2[1], q2[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q2[0], q2[1]);
      M(b, b, t);
      M(c, p[3], q2[3]);
      M(c, c, D2);
      M(d, p[2], q2[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q2, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p[i], q2[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q2, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q2, b);
        add(q2, p);
        add(p, p);
        cswap(p, q2, b);
      }
    }
    function scalarbase(p, s) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X);
      set25519(q2[1], Y);
      set25519(q2[2], gf1);
      M(q2[3], X, Y);
      scalarmult(p, q2, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0; i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++)
        x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce2(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++)
        x[i] = r[i];
      for (i = 0; i < 64; i++)
        r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++)
        sm[64 + i] = m[i];
      for (i = 0; i < 32; i++)
        sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce2(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32; i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce2(h);
      for (i = 0; i < 64; i++)
        x[i] = 0;
      for (i = 0; i < 32; i++)
        x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p[31] >> 7)
        Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64)
        return -1;
      if (unpackneg(q2, pk))
        return -1;
      for (i = 0; i < n; i++)
        m[i] = sm[i];
      for (i = 0; i < 32; i++)
        m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce2(h);
      scalarmult(p, q2, h);
      scalarbase(q2, sm.subarray(32));
      add(p, q2);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++)
          m[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++)
        m[i] = sm[i + 64];
      mlen = n;
      return mlen;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      var t, i;
      for (i = 0; i < arguments.length; i++) {
        if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
          throw new TypeError("unexpected type " + t + ", use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++)
        arr[i] = 0;
    }
    if (!nacl.util) {
      nacl.util = {};
      nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
        throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
      };
    }
    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32)
        return false;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
        return false;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p);
      return q2;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      if (arguments.length !== 2)
        throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++)
        m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0; i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return {publicKey: pk, secretKey: sk};
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0)
        return false;
      if (x.length !== y.length)
        return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto && crypto.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++)
            x[i] = v[i];
          cleanup(v);
        });
      } else if (true) {
        crypto = require("crypto");
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto.randomBytes(n);
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
});

// node_modules/sshpk/lib/utils.js
var require_utils = __commonJS((exports2, module2) => {
  module2.exports = {
    bufferSplit,
    addRSAMissing,
    calculateDSAPublic,
    calculateED25519Public,
    calculateX25519Public,
    mpNormalize,
    mpDenormalize,
    ecNormalize,
    countZeros,
    assertCompatible,
    isCompatible,
    opensslKeyDeriv,
    opensshCipherInfo,
    publicFromPrivateECDSA,
    zeroPadToLength,
    writeBitString,
    readBitString,
    pbkdf2
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var PrivateKey = require_private_key();
  var Key = require_key();
  var crypto = require("crypto");
  var algs = require_algs();
  var asn1 = require_lib();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  var nacl = require_nacl_fast();
  var MAX_CLASS_DEPTH = 3;
  function isCompatible(obj, klass, needVer) {
    if (obj === null || typeof obj !== "object")
      return false;
    if (needVer === void 0)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return true;
    var proto = Object.getPrototypeOf(obj);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      if (!proto || ++depth > MAX_CLASS_DEPTH)
        return false;
    }
    if (proto.constructor.name !== klass.name)
      return false;
    var ver = proto._sshpkApiVersion;
    if (ver === void 0)
      ver = klass._oldVersionDetect(obj);
    if (ver[0] != needVer[0] || ver[1] < needVer[1])
      return false;
    return true;
  }
  function assertCompatible(obj, klass, needVer, name) {
    if (name === void 0)
      name = "object";
    assert.ok(obj, name + " must not be null");
    assert.object(obj, name + " must be an object");
    if (needVer === void 0)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return;
    var proto = Object.getPrototypeOf(obj);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      assert.ok(proto && ++depth <= MAX_CLASS_DEPTH, name + " must be a " + klass.name + " instance");
    }
    assert.strictEqual(proto.constructor.name, klass.name, name + " must be a " + klass.name + " instance");
    var ver = proto._sshpkApiVersion;
    if (ver === void 0)
      ver = klass._oldVersionDetect(obj);
    assert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1], name + " must be compatible with " + klass.name + " klass version " + needVer[0] + "." + needVer[1]);
  }
  var CIPHER_LEN = {
    "des-ede3-cbc": {key: 24, iv: 8},
    "aes-128-cbc": {key: 16, iv: 16},
    "aes-256-cbc": {key: 32, iv: 16}
  };
  var PKCS5_SALT_LEN = 8;
  function opensslKeyDeriv(cipher, salt, passphrase, count) {
    assert.buffer(salt, "salt");
    assert.buffer(passphrase, "passphrase");
    assert.number(count, "iteration count");
    var clen = CIPHER_LEN[cipher];
    assert.object(clen, "supported cipher");
    salt = salt.slice(0, PKCS5_SALT_LEN);
    var D, D_prev, bufs;
    var material = Buffer2.alloc(0);
    while (material.length < clen.key + clen.iv) {
      bufs = [];
      if (D_prev)
        bufs.push(D_prev);
      bufs.push(passphrase);
      bufs.push(salt);
      D = Buffer2.concat(bufs);
      for (var j = 0; j < count; ++j)
        D = crypto.createHash("md5").update(D).digest();
      material = Buffer2.concat([material, D]);
      D_prev = D;
    }
    return {
      key: material.slice(0, clen.key),
      iv: material.slice(clen.key, clen.key + clen.iv)
    };
  }
  function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
    var hkey = Buffer2.alloc(salt.length + 4);
    salt.copy(hkey);
    var gen = 0, ts = [];
    var i = 1;
    while (gen < size) {
      var t = T(i++);
      gen += t.length;
      ts.push(t);
    }
    return Buffer2.concat(ts).slice(0, size);
    function T(I) {
      hkey.writeUInt32BE(I, hkey.length - 4);
      var hmac = crypto.createHmac(hashAlg, passphrase);
      hmac.update(hkey);
      var Ti = hmac.digest();
      var Uc = Ti;
      var c = 1;
      while (c++ < iterations) {
        hmac = crypto.createHmac(hashAlg, passphrase);
        hmac.update(Uc);
        Uc = hmac.digest();
        for (var x = 0; x < Ti.length; ++x)
          Ti[x] ^= Uc[x];
      }
      return Ti;
    }
  }
  function countZeros(buf) {
    var o = 0, obit = 8;
    while (o < buf.length) {
      var mask = 1 << obit;
      if ((buf[o] & mask) === mask)
        break;
      obit--;
      if (obit < 0) {
        o++;
        obit = 8;
      }
    }
    return o * 8 + (8 - obit) - 1;
  }
  function bufferSplit(buf, chr) {
    assert.buffer(buf);
    assert.string(chr);
    var parts = [];
    var lastPart = 0;
    var matches = 0;
    for (var i = 0; i < buf.length; ++i) {
      if (buf[i] === chr.charCodeAt(matches))
        ++matches;
      else if (buf[i] === chr.charCodeAt(0))
        matches = 1;
      else
        matches = 0;
      if (matches >= chr.length) {
        var newPart = i + 1;
        parts.push(buf.slice(lastPart, newPart - matches));
        lastPart = newPart;
        matches = 0;
      }
    }
    if (lastPart <= buf.length)
      parts.push(buf.slice(lastPart, buf.length));
    return parts;
  }
  function ecNormalize(buf, addZero) {
    assert.buffer(buf);
    if (buf[0] === 0 && buf[1] === 4) {
      if (addZero)
        return buf;
      return buf.slice(1);
    } else if (buf[0] === 4) {
      if (!addZero)
        return buf;
    } else {
      while (buf[0] === 0)
        buf = buf.slice(1);
      if (buf[0] === 2 || buf[0] === 3)
        throw new Error("Compressed elliptic curve points are not supported");
      if (buf[0] !== 4)
        throw new Error("Not a valid elliptic curve point");
      if (!addZero)
        return buf;
    }
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    return b;
  }
  function readBitString(der, tag) {
    if (tag === void 0)
      tag = asn1.Ber.BitString;
    var buf = der.readString(tag, true);
    assert.strictEqual(buf[0], 0, "bit strings with unused bits are not supported (0x" + buf[0].toString(16) + ")");
    return buf.slice(1);
  }
  function writeBitString(der, buf, tag) {
    if (tag === void 0)
      tag = asn1.Ber.BitString;
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    der.writeBuffer(b, tag);
  }
  function mpNormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
      buf = buf.slice(1);
    if ((buf[0] & 128) === 128) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function mpDenormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0)
      buf = buf.slice(1);
    return buf;
  }
  function zeroPadToLength(buf, len) {
    assert.buffer(buf);
    assert.number(len);
    while (buf.length > len) {
      assert.equal(buf[0], 0);
      buf = buf.slice(1);
    }
    while (buf.length < len) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function bigintToMpBuf(bigint) {
    var buf = Buffer2.from(bigint.toByteArray());
    buf = mpNormalize(buf);
    return buf;
  }
  function calculateDSAPublic(g, p, x) {
    assert.buffer(g);
    assert.buffer(p);
    assert.buffer(x);
    g = new jsbn(g);
    p = new jsbn(p);
    x = new jsbn(x);
    var y = g.modPow(x, p);
    var ybuf = bigintToMpBuf(y);
    return ybuf;
  }
  function calculateED25519Public(k) {
    assert.buffer(k);
    var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function calculateX25519Public(k) {
    assert.buffer(k);
    var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function addRSAMissing(key) {
    assert.object(key);
    assertCompatible(key, PrivateKey, [1, 1]);
    var d = new jsbn(key.part.d.data);
    var buf;
    if (!key.part.dmodp) {
      var p = new jsbn(key.part.p.data);
      var dmodp = d.mod(p.subtract(1));
      buf = bigintToMpBuf(dmodp);
      key.part.dmodp = {name: "dmodp", data: buf};
      key.parts.push(key.part.dmodp);
    }
    if (!key.part.dmodq) {
      var q2 = new jsbn(key.part.q.data);
      var dmodq = d.mod(q2.subtract(1));
      buf = bigintToMpBuf(dmodq);
      key.part.dmodq = {name: "dmodq", data: buf};
      key.parts.push(key.part.dmodq);
    }
  }
  function publicFromPrivateECDSA(curveName, priv) {
    assert.string(curveName, "curveName");
    assert.buffer(priv);
    var params = algs.curves[curveName];
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    var d = new jsbn(mpNormalize(priv));
    var pub = G.multiply(d);
    pub = Buffer2.from(curve.encodePointHex(pub), "hex");
    var parts = [];
    parts.push({name: "curve", data: Buffer2.from(curveName)});
    parts.push({name: "Q", data: pub});
    var key = new Key({type: "ecdsa", curve, parts});
    return key;
  }
  function opensshCipherInfo(cipher) {
    var inf = {};
    switch (cipher) {
      case "3des-cbc":
        inf.keySize = 24;
        inf.blockSize = 8;
        inf.opensslName = "des-ede3-cbc";
        break;
      case "blowfish-cbc":
        inf.keySize = 16;
        inf.blockSize = 8;
        inf.opensslName = "bf-cbc";
        break;
      case "aes128-cbc":
      case "aes128-ctr":
      case "aes128-gcm@openssh.com":
        inf.keySize = 16;
        inf.blockSize = 16;
        inf.opensslName = "aes-128-" + cipher.slice(7, 10);
        break;
      case "aes192-cbc":
      case "aes192-ctr":
      case "aes192-gcm@openssh.com":
        inf.keySize = 24;
        inf.blockSize = 16;
        inf.opensslName = "aes-192-" + cipher.slice(7, 10);
        break;
      case "aes256-cbc":
      case "aes256-ctr":
      case "aes256-gcm@openssh.com":
        inf.keySize = 32;
        inf.blockSize = 16;
        inf.opensslName = "aes-256-" + cipher.slice(7, 10);
        break;
      default:
        throw new Error('Unsupported openssl cipher "' + cipher + '"');
    }
    return inf;
  }
});

// node_modules/sshpk/lib/ssh-buffer.js
var require_ssh_buffer = __commonJS((exports2, module2) => {
  module2.exports = SSHBuffer;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  function SSHBuffer(opts) {
    assert.object(opts, "options");
    if (opts.buffer !== void 0)
      assert.buffer(opts.buffer, "options.buffer");
    this._size = opts.buffer ? opts.buffer.length : 1024;
    this._buffer = opts.buffer || Buffer2.alloc(this._size);
    this._offset = 0;
  }
  SSHBuffer.prototype.toBuffer = function() {
    return this._buffer.slice(0, this._offset);
  };
  SSHBuffer.prototype.atEnd = function() {
    return this._offset >= this._buffer.length;
  };
  SSHBuffer.prototype.remainder = function() {
    return this._buffer.slice(this._offset);
  };
  SSHBuffer.prototype.skip = function(n) {
    this._offset += n;
  };
  SSHBuffer.prototype.expand = function() {
    this._size *= 2;
    var buf = Buffer2.alloc(this._size);
    this._buffer.copy(buf, 0);
    this._buffer = buf;
  };
  SSHBuffer.prototype.readPart = function() {
    return {data: this.readBuffer()};
  };
  SSHBuffer.prototype.readBuffer = function() {
    var len = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    assert.ok(this._offset + len <= this._buffer.length, "length out of bounds at +0x" + this._offset.toString(16) + " (data truncated?)");
    var buf = this._buffer.slice(this._offset, this._offset + len);
    this._offset += len;
    return buf;
  };
  SSHBuffer.prototype.readString = function() {
    return this.readBuffer().toString();
  };
  SSHBuffer.prototype.readCString = function() {
    var offset = this._offset;
    while (offset < this._buffer.length && this._buffer[offset] !== 0)
      offset++;
    assert.ok(offset < this._buffer.length, "c string does not terminate");
    var str = this._buffer.slice(this._offset, offset).toString();
    this._offset = offset + 1;
    return str;
  };
  SSHBuffer.prototype.readInt = function() {
    var v = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    return v;
  };
  SSHBuffer.prototype.readInt64 = function() {
    assert.ok(this._offset + 8 < this._buffer.length, "buffer not long enough to read Int64");
    var v = this._buffer.slice(this._offset, this._offset + 8);
    this._offset += 8;
    return v;
  };
  SSHBuffer.prototype.readChar = function() {
    var v = this._buffer[this._offset++];
    return v;
  };
  SSHBuffer.prototype.writeBuffer = function(buf) {
    while (this._offset + 4 + buf.length > this._size)
      this.expand();
    this._buffer.writeUInt32BE(buf.length, this._offset);
    this._offset += 4;
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
  SSHBuffer.prototype.writeString = function(str) {
    this.writeBuffer(Buffer2.from(str, "utf8"));
  };
  SSHBuffer.prototype.writeCString = function(str) {
    while (this._offset + 1 + str.length > this._size)
      this.expand();
    this._buffer.write(str, this._offset);
    this._offset += str.length;
    this._buffer[this._offset++] = 0;
  };
  SSHBuffer.prototype.writeInt = function(v) {
    while (this._offset + 4 > this._size)
      this.expand();
    this._buffer.writeUInt32BE(v, this._offset);
    this._offset += 4;
  };
  SSHBuffer.prototype.writeInt64 = function(v) {
    assert.buffer(v, "value");
    if (v.length > 8) {
      var lead = v.slice(0, v.length - 8);
      for (var i = 0; i < lead.length; ++i) {
        assert.strictEqual(lead[i], 0, "must fit in 64 bits of precision");
      }
      v = v.slice(v.length - 8, v.length);
    }
    while (this._offset + 8 > this._size)
      this.expand();
    v.copy(this._buffer, this._offset);
    this._offset += 8;
  };
  SSHBuffer.prototype.writeChar = function(v) {
    while (this._offset + 1 > this._size)
      this.expand();
    this._buffer[this._offset++] = v;
  };
  SSHBuffer.prototype.writePart = function(p) {
    this.writeBuffer(p.data);
  };
  SSHBuffer.prototype.write = function(buf) {
    while (this._offset + buf.length > this._size)
      this.expand();
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
});

// node_modules/sshpk/lib/signature.js
var require_signature = __commonJS((exports2, module2) => {
  module2.exports = Signature;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require("crypto");
  var errs = require_errors();
  var utils = require_utils();
  var asn1 = require_lib();
  var SSHBuffer = require_ssh_buffer();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var SignatureParseError = errs.SignatureParseError;
  function Signature(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    var partLookup = {};
    for (var i = 0; i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.hashAlgorithm = opts.hashAlgo;
    this.curve = opts.curve;
    this.parts = opts.parts;
    this.part = partLookup;
  }
  Signature.prototype.toBuffer = function(format) {
    if (format === void 0)
      format = "asn1";
    assert.string(format, "format");
    var buf;
    var stype = "ssh-" + this.type;
    switch (this.type) {
      case "rsa":
        switch (this.hashAlgorithm) {
          case "sha256":
            stype = "rsa-sha2-256";
            break;
          case "sha512":
            stype = "rsa-sha2-512";
            break;
          case "sha1":
          case void 0:
            break;
          default:
            throw new Error("SSH signature format does not support hash algorithm " + this.hashAlgorithm);
        }
        if (format === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case "ed25519":
        if (format === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case "dsa":
      case "ecdsa":
        var r, s;
        if (format === "asn1") {
          var der = new asn1.BerWriter();
          der.startSequence();
          r = utils.mpNormalize(this.part.r.data);
          s = utils.mpNormalize(this.part.s.data);
          der.writeBuffer(r, asn1.Ber.Integer);
          der.writeBuffer(s, asn1.Ber.Integer);
          der.endSequence();
          return der.buffer;
        } else if (format === "ssh" && this.type === "dsa") {
          buf = new SSHBuffer({});
          buf.writeString("ssh-dss");
          r = this.part.r.data;
          if (r.length > 20 && r[0] === 0)
            r = r.slice(1);
          s = this.part.s.data;
          if (s.length > 20 && s[0] === 0)
            s = s.slice(1);
          if (this.hashAlgorithm && this.hashAlgorithm !== "sha1" || r.length + s.length !== 40) {
            throw new Error("OpenSSH only supports DSA signatures with SHA1 hash");
          }
          buf.writeBuffer(Buffer2.concat([r, s]));
          return buf.toBuffer();
        } else if (format === "ssh" && this.type === "ecdsa") {
          var inner = new SSHBuffer({});
          r = this.part.r.data;
          inner.writeBuffer(r);
          inner.writePart(this.part.s);
          buf = new SSHBuffer({});
          var curve;
          if (r[0] === 0)
            r = r.slice(1);
          var sz = r.length * 8;
          if (sz === 256)
            curve = "nistp256";
          else if (sz === 384)
            curve = "nistp384";
          else if (sz === 528)
            curve = "nistp521";
          buf.writeString("ecdsa-sha2-" + curve);
          buf.writeBuffer(inner.toBuffer());
          return buf.toBuffer();
        }
        throw new Error("Invalid signature format");
      default:
        throw new Error("Invalid signature data");
    }
  };
  Signature.prototype.toString = function(format) {
    assert.optionalString(format, "format");
    return this.toBuffer(format).toString("base64");
  };
  Signature.parse = function(data, type, format) {
    if (typeof data === "string")
      data = Buffer2.from(data, "base64");
    assert.buffer(data, "data");
    assert.string(format, "format");
    assert.string(type, "type");
    var opts = {};
    opts.type = type.toLowerCase();
    opts.parts = [];
    try {
      assert.ok(data.length > 0, "signature must not be empty");
      switch (opts.type) {
        case "rsa":
          return parseOneNum(data, type, format, opts);
        case "ed25519":
          return parseOneNum(data, type, format, opts);
        case "dsa":
        case "ecdsa":
          if (format === "asn1")
            return parseDSAasn1(data, type, format, opts);
          else if (opts.type === "dsa")
            return parseDSA(data, type, format, opts);
          else
            return parseECDSA(data, type, format, opts);
        default:
          throw new InvalidAlgorithmError(type);
      }
    } catch (e) {
      if (e instanceof InvalidAlgorithmError)
        throw e;
      throw new SignatureParseError(type, format, e);
    }
  };
  function parseOneNum(data, type, format, opts) {
    if (format === "ssh") {
      try {
        var buf = new SSHBuffer({buffer: data});
        var head = buf.readString();
      } catch (e) {
      }
      if (buf !== void 0) {
        var msg = "SSH signature does not match expected type (expected " + type + ", got " + head + ")";
        switch (head) {
          case "ssh-rsa":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha1";
            break;
          case "rsa-sha2-256":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha256";
            break;
          case "rsa-sha2-512":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha512";
            break;
          case "ssh-ed25519":
            assert.strictEqual(type, "ed25519", msg);
            opts.hashAlgo = "sha512";
            break;
          default:
            throw new Error("Unknown SSH signature type: " + head);
        }
        var sig = buf.readPart();
        assert.ok(buf.atEnd(), "extra trailing bytes");
        sig.name = "sig";
        opts.parts.push(sig);
        return new Signature(opts);
      }
    }
    opts.parts.push({name: "sig", data});
    return new Signature(opts);
  }
  function parseDSAasn1(data, type, format, opts) {
    var der = new asn1.BerReader(data);
    der.readSequence();
    var r = der.readString(asn1.Ber.Integer, true);
    var s = der.readString(asn1.Ber.Integer, true);
    opts.parts.push({name: "r", data: utils.mpNormalize(r)});
    opts.parts.push({name: "s", data: utils.mpNormalize(s)});
    return new Signature(opts);
  }
  function parseDSA(data, type, format, opts) {
    if (data.length != 40) {
      var buf = new SSHBuffer({buffer: data});
      var d = buf.readBuffer();
      if (d.toString("ascii") === "ssh-dss")
        d = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes");
      assert.strictEqual(d.length, 40, "invalid inner length");
      data = d;
    }
    opts.parts.push({name: "r", data: data.slice(0, 20)});
    opts.parts.push({name: "s", data: data.slice(20, 40)});
    return new Signature(opts);
  }
  function parseECDSA(data, type, format, opts) {
    var buf = new SSHBuffer({buffer: data});
    var r, s;
    var inner = buf.readBuffer();
    var stype = inner.toString("ascii");
    if (stype.slice(0, 6) === "ecdsa-") {
      var parts = stype.split("-");
      assert.strictEqual(parts[0], "ecdsa");
      assert.strictEqual(parts[1], "sha2");
      opts.curve = parts[2];
      switch (opts.curve) {
        case "nistp256":
          opts.hashAlgo = "sha256";
          break;
        case "nistp384":
          opts.hashAlgo = "sha384";
          break;
        case "nistp521":
          opts.hashAlgo = "sha512";
          break;
        default:
          throw new Error("Unsupported ECDSA curve: " + opts.curve);
      }
      inner = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes on outer");
      buf = new SSHBuffer({buffer: inner});
      r = buf.readPart();
    } else {
      r = {data: inner};
    }
    s = buf.readPart();
    assert.ok(buf.atEnd(), "extra trailing bytes");
    r.name = "r";
    s.name = "s";
    opts.parts.push(r);
    opts.parts.push(s);
    return new Signature(opts);
  }
  Signature.isSignature = function(obj, ver) {
    return utils.isCompatible(obj, Signature, ver);
  };
  Signature.prototype._sshpkApiVersion = [2, 1];
  Signature._oldVersionDetect = function(obj) {
    assert.func(obj.toBuffer);
    if (obj.hasOwnProperty("hashAlgorithm"))
      return [2, 0];
    return [1, 0];
  };
});

// node_modules/ecc-jsbn/lib/sec.js
var require_sec = __commonJS((exports2, module2) => {
  var BigInteger = require_jsbn().BigInteger;
  var ECCurveFp = require_ec().ECCurveFp;
  function X9ECParameters(curve, g, n, h) {
    this.curve = curve;
    this.g = g;
    this.n = n;
    this.h = h;
  }
  function x9getCurve() {
    return this.curve;
  }
  function x9getG() {
    return this.g;
  }
  function x9getN() {
    return this.n;
  }
  function x9getH() {
    return this.h;
  }
  X9ECParameters.prototype.getCurve = x9getCurve;
  X9ECParameters.prototype.getG = x9getG;
  X9ECParameters.prototype.getN = x9getN;
  X9ECParameters.prototype.getH = x9getH;
  function fromHex(s) {
    return new BigInteger(s, 16);
  }
  function secp128r1() {
    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
    var a = BigInteger.ZERO;
    var b = fromHex("7");
    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
    var a = BigInteger.ZERO;
    var b = fromHex("3");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp224r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp256r1() {
    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
    return new X9ECParameters(curve, G, n, h);
  }
  module2.exports = {
    secp128r1,
    secp160k1,
    secp160r1,
    secp192k1,
    secp192r1,
    secp224r1,
    secp256r1
  };
});

// node_modules/ecc-jsbn/index.js
var require_ecc_jsbn = __commonJS((exports2) => {
  var crypto = require("crypto");
  var BigInteger = require_jsbn().BigInteger;
  var ECPointFp = require_ec().ECPointFp;
  var Buffer2 = require_safer().Buffer;
  exports2.ECCurves = require_sec();
  function unstupid(hex, len) {
    return hex.length >= len ? hex : unstupid("0" + hex, len);
  }
  exports2.ECKey = function(curve, key, isPublic) {
    var priv;
    var c = curve();
    var n = c.getN();
    var bytes = Math.floor(n.bitLength() / 8);
    if (key) {
      if (isPublic) {
        var curve = c.getCurve();
        this.P = curve.decodePointHex(key.toString("hex"));
      } else {
        if (key.length != bytes)
          return false;
        priv = new BigInteger(key.toString("hex"), 16);
      }
    } else {
      var n1 = n.subtract(BigInteger.ONE);
      var r = new BigInteger(crypto.randomBytes(n.bitLength()));
      priv = r.mod(n1).add(BigInteger.ONE);
      this.P = c.getG().multiply(priv);
    }
    if (this.P) {
      this.PublicKey = Buffer2.from(c.getCurve().encodeCompressedPointHex(this.P), "hex");
    }
    if (priv) {
      this.PrivateKey = Buffer2.from(unstupid(priv.toString(16), bytes * 2), "hex");
      this.deriveSharedSecret = function(key2) {
        if (!key2 || !key2.P)
          return false;
        var S = key2.P.multiply(priv);
        return Buffer2.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
      };
    }
  };
});

// node_modules/sshpk/lib/dhe.js
var require_dhe = __commonJS((exports2, module2) => {
  module2.exports = {
    DiffieHellman,
    generateECDSA,
    generateED25519
  };
  var assert = require_assert();
  var crypto = require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var CRYPTO_HAVE_ECDH = crypto.createECDH !== void 0;
  var ecdh = require_ecc_jsbn();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  function DiffieHellman(key) {
    utils.assertCompatible(key, Key, [1, 4], "key");
    this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
    this._algo = key.type;
    this._curve = key.curve;
    this._key = key;
    if (key.type === "dsa") {
      if (!CRYPTO_HAVE_ECDH) {
        throw new Error("Due to bugs in the node 0.10 crypto API, node 0.12.x or later is required to use DH");
      }
      this._dh = crypto.createDiffieHellman(key.part.p.data, void 0, key.part.g.data, void 0);
      this._p = key.part.p;
      this._g = key.part.g;
      if (this._isPriv)
        this._dh.setPrivateKey(key.part.x.data);
      this._dh.setPublicKey(key.part.y.data);
    } else if (key.type === "ecdsa") {
      if (!CRYPTO_HAVE_ECDH) {
        this._ecParams = new X9ECParameters(this._curve);
        if (this._isPriv) {
          this._priv = new ECPrivate(this._ecParams, key.part.d.data);
        }
        return;
      }
      var curve = {
        nistp256: "prime256v1",
        nistp384: "secp384r1",
        nistp521: "secp521r1"
      }[key.curve];
      this._dh = crypto.createECDH(curve);
      if (typeof this._dh !== "object" || typeof this._dh.setPrivateKey !== "function") {
        CRYPTO_HAVE_ECDH = false;
        DiffieHellman.call(this, key);
        return;
      }
      if (this._isPriv)
        this._dh.setPrivateKey(key.part.d.data);
      this._dh.setPublicKey(key.part.Q.data);
    } else if (key.type === "curve25519") {
      if (this._isPriv) {
        utils.assertCompatible(key, PrivateKey, [1, 5], "key");
        this._priv = key.part.k.data;
      }
    } else {
      throw new Error("DH not supported for " + key.type + " keys");
    }
  }
  DiffieHellman.prototype.getPublicKey = function() {
    if (this._isPriv)
      return this._key.toPublic();
    return this._key;
  };
  DiffieHellman.prototype.getPrivateKey = function() {
    if (this._isPriv)
      return this._key;
    else
      return void 0;
  };
  DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
  DiffieHellman.prototype._keyCheck = function(pk, isPub) {
    assert.object(pk, "key");
    if (!isPub)
      utils.assertCompatible(pk, PrivateKey, [1, 3], "key");
    utils.assertCompatible(pk, Key, [1, 4], "key");
    if (pk.type !== this._algo) {
      throw new Error("A " + pk.type + " key cannot be used in " + this._algo + " Diffie-Hellman");
    }
    if (pk.curve !== this._curve) {
      throw new Error("A key from the " + pk.curve + " curve cannot be used with a " + this._curve + " Diffie-Hellman");
    }
    if (pk.type === "dsa") {
      assert.deepEqual(pk.part.p, this._p, "DSA key prime does not match");
      assert.deepEqual(pk.part.g, this._g, "DSA key generator does not match");
    }
  };
  DiffieHellman.prototype.setKey = function(pk) {
    this._keyCheck(pk);
    if (pk.type === "dsa") {
      this._dh.setPrivateKey(pk.part.x.data);
      this._dh.setPublicKey(pk.part.y.data);
    } else if (pk.type === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.setPrivateKey(pk.part.d.data);
        this._dh.setPublicKey(pk.part.Q.data);
      } else {
        this._priv = new ECPrivate(this._ecParams, pk.part.d.data);
      }
    } else if (pk.type === "curve25519") {
      var k = pk.part.k;
      if (!pk.part.k)
        k = pk.part.r;
      this._priv = k.data;
      if (this._priv[0] === 0)
        this._priv = this._priv.slice(1);
      this._priv = this._priv.slice(0, 32);
    }
    this._key = pk;
    this._isPriv = true;
  };
  DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
  DiffieHellman.prototype.computeSecret = function(otherpk) {
    this._keyCheck(otherpk, true);
    if (!this._isPriv)
      throw new Error("DH exchange has not been initialized with a private key yet");
    var pub;
    if (this._algo === "dsa") {
      return this._dh.computeSecret(otherpk.part.y.data);
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        return this._dh.computeSecret(otherpk.part.Q.data);
      } else {
        pub = new ECPublic(this._ecParams, otherpk.part.Q.data);
        return this._priv.deriveSharedSecret(pub);
      }
    } else if (this._algo === "curve25519") {
      pub = otherpk.part.A.data;
      while (pub[0] === 0 && pub.length > 32)
        pub = pub.slice(1);
      var priv = this._priv;
      assert.strictEqual(pub.length, 32);
      assert.strictEqual(priv.length, 32);
      var secret = nacl.box.before(new Uint8Array(pub), new Uint8Array(priv));
      return Buffer2.from(secret);
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKey = function() {
    var parts = [];
    var priv, pub;
    if (this._algo === "dsa") {
      this._dh.generateKeys();
      parts.push({name: "p", data: this._p.data});
      parts.push({name: "q", data: this._key.part.q.data});
      parts.push({name: "g", data: this._g.data});
      parts.push({name: "y", data: this._dh.getPublicKey()});
      parts.push({name: "x", data: this._dh.getPrivateKey()});
      this._key = new PrivateKey({
        type: "dsa",
        parts
      });
      this._isPriv = true;
      return this._key;
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.generateKeys();
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({name: "Q", data: this._dh.getPublicKey()});
        parts.push({name: "d", data: this._dh.getPrivateKey()});
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      } else {
        var n = this._ecParams.getN();
        var r = new jsbn(crypto.randomBytes(n.bitLength()));
        var n1 = n.subtract(jsbn.ONE);
        priv = r.mod(n1).add(jsbn.ONE);
        pub = this._ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(this._ecParams.getCurve().encodePointHex(pub), "hex");
        this._priv = new ECPrivate(this._ecParams, priv);
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({name: "Q", data: pub});
        parts.push({name: "d", data: priv});
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      }
    } else if (this._algo === "curve25519") {
      var pair = nacl.box.keyPair();
      priv = Buffer2.from(pair.secretKey);
      pub = Buffer2.from(pair.publicKey);
      priv = Buffer2.concat([priv, pub]);
      assert.strictEqual(priv.length, 64);
      assert.strictEqual(pub.length, 32);
      parts.push({name: "A", data: pub});
      parts.push({name: "k", data: priv});
      this._key = new PrivateKey({
        type: "curve25519",
        parts
      });
      this._isPriv = true;
      return this._key;
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
  function X9ECParameters(name) {
    var params = algs.curves[name];
    assert.object(params);
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var n = new jsbn(params.n);
    var h = jsbn.ONE;
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    this.curve = curve;
    this.g = G;
    this.n = n;
    this.h = h;
  }
  X9ECParameters.prototype.getCurve = function() {
    return this.curve;
  };
  X9ECParameters.prototype.getG = function() {
    return this.g;
  };
  X9ECParameters.prototype.getN = function() {
    return this.n;
  };
  X9ECParameters.prototype.getH = function() {
    return this.h;
  };
  function ECPublic(params, buffer) {
    this._params = params;
    if (buffer[0] === 0)
      buffer = buffer.slice(1);
    this._pub = params.getCurve().decodePointHex(buffer.toString("hex"));
  }
  function ECPrivate(params, buffer) {
    this._params = params;
    this._priv = new jsbn(utils.mpNormalize(buffer));
  }
  ECPrivate.prototype.deriveSharedSecret = function(pubKey) {
    assert.ok(pubKey instanceof ECPublic);
    var S = pubKey._pub.multiply(this._priv);
    return Buffer2.from(S.getX().toBigInteger().toByteArray());
  };
  function generateED25519() {
    var pair = nacl.sign.keyPair();
    var priv = Buffer2.from(pair.secretKey);
    var pub = Buffer2.from(pair.publicKey);
    assert.strictEqual(priv.length, 64);
    assert.strictEqual(pub.length, 32);
    var parts = [];
    parts.push({name: "A", data: pub});
    parts.push({name: "k", data: priv.slice(0, 32)});
    var key = new PrivateKey({
      type: "ed25519",
      parts
    });
    return key;
  }
  function generateECDSA(curve) {
    var parts = [];
    var key;
    if (CRYPTO_HAVE_ECDH) {
      var osCurve = {
        nistp256: "prime256v1",
        nistp384: "secp384r1",
        nistp521: "secp521r1"
      }[curve];
      var dh = crypto.createECDH(osCurve);
      dh.generateKeys();
      parts.push({
        name: "curve",
        data: Buffer2.from(curve)
      });
      parts.push({name: "Q", data: dh.getPublicKey()});
      parts.push({name: "d", data: dh.getPrivateKey()});
      key = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key;
    } else {
      var ecParams = new X9ECParameters(curve);
      var n = ecParams.getN();
      var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
      var c = new jsbn(crypto.randomBytes(cByteLen));
      var n1 = n.subtract(jsbn.ONE);
      var priv = c.mod(n1).add(jsbn.ONE);
      var pub = ecParams.getG().multiply(priv);
      priv = Buffer2.from(priv.toByteArray());
      pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), "hex");
      parts.push({name: "curve", data: Buffer2.from(curve)});
      parts.push({name: "Q", data: pub});
      parts.push({name: "d", data: priv});
      key = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key;
    }
  }
});

// node_modules/sshpk/lib/ed-compat.js
var require_ed_compat = __commonJS((exports2, module2) => {
  module2.exports = {
    Verifier,
    Signer
  };
  var nacl = require_nacl_fast();
  var stream = require("stream");
  var util = require("util");
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Signature = require_signature();
  function Verifier(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of SHA-512 hashes");
    this.key = key;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util.inherits(Verifier, stream.Writable);
  Verifier.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Verifier.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Verifier.prototype.verify = function(signature, fmt) {
    var sig;
    if (Signature.isSignature(signature, [2, 0])) {
      if (signature.type !== "ed25519")
        return false;
      sig = signature.toBuffer("raw");
    } else if (typeof signature === "string") {
      sig = Buffer2.from(signature, "base64");
    } else if (Signature.isSignature(signature, [1, 0])) {
      throw new Error("signature was created by too old a version of sshpk and cannot be verified");
    }
    assert.buffer(sig);
    return nacl.sign.detached.verify(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(sig), new Uint8Array(this.key.part.A.data));
  };
  function Signer(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of SHA-512 hashes");
    this.key = key;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util.inherits(Signer, stream.Writable);
  Signer.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Signer.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Signer.prototype.sign = function() {
    var sig = nacl.sign.detached(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(Buffer2.concat([
      this.key.part.k.data,
      this.key.part.A.data
    ])));
    var sigBuf = Buffer2.from(sig);
    var sigObj = Signature.parse(sigBuf, "ed25519", "raw");
    sigObj.hashAlgorithm = "sha512";
    return sigObj;
  };
});

// node_modules/sshpk/lib/formats/pkcs8.js
var require_pkcs8 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readPkcs8,
    write,
    writePkcs8,
    pkcs8ToBuffer,
    readECDSACurve,
    writeECDSACurve
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  function read(buf, options) {
    return pem.read(buf, options, "pkcs8");
  }
  function write(key, options) {
    return pem.write(key, options, "pkcs8");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs8(alg, type, der) {
    if (der.peek() === asn1.Ber.Integer) {
      assert.strictEqual(type, "private", "unexpected Integer at start of public key");
      der.readString(asn1.Ber.Integer, true);
    }
    der.readSequence();
    var next2 = der.offset + der.length;
    var oid = der.readOID();
    switch (oid) {
      case "1.2.840.113549.1.1.1":
        der._offset = next2;
        if (type === "public")
          return readPkcs8RSAPublic(der);
        else
          return readPkcs8RSAPrivate(der);
      case "1.2.840.10040.4.1":
        if (type === "public")
          return readPkcs8DSAPublic(der);
        else
          return readPkcs8DSAPrivate(der);
      case "1.2.840.10045.2.1":
        if (type === "public")
          return readPkcs8ECDSAPublic(der);
        else
          return readPkcs8ECDSAPrivate(der);
      case "1.3.101.112":
        if (type === "public") {
          return readPkcs8EdDSAPublic(der);
        } else {
          return readPkcs8EdDSAPrivate(der);
        }
      case "1.3.101.110":
        if (type === "public") {
          return readPkcs8X25519Public(der);
        } else {
          return readPkcs8X25519Private(der);
        }
      default:
        throw new Error("Unknown key type OID " + oid);
    }
  }
  function readPkcs8RSAPublic(der) {
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    der.readSequence();
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key = {
      type: "rsa",
      source: der.originalInput,
      parts: [
        {name: "e", data: e},
        {name: "n", data: n}
      ]
    };
    return new Key(key);
  }
  function readPkcs8RSAPrivate(der) {
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var ver = readMPInt(der, "version");
    assert.equal(ver[0], 0, "unknown RSA private key version");
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key = {
      type: "rsa",
      parts: [
        {name: "n", data: n},
        {name: "e", data: e},
        {name: "d", data: d},
        {name: "iqmp", data: iqmp},
        {name: "p", data: p},
        {name: "q", data: q2},
        {name: "dmodp", data: dmodp},
        {name: "dmodq", data: dmodq}
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8DSAPublic(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    var y = readMPInt(der, "y");
    var key = {
      type: "dsa",
      parts: [
        {name: "p", data: p},
        {name: "q", data: q2},
        {name: "g", data: g},
        {name: "y", data: y}
      ]
    };
    return new Key(key);
  }
  function readPkcs8DSAPrivate(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.OctetString);
    var x = readMPInt(der, "x");
    var y = utils.calculateDSAPublic(g, p, x);
    var key = {
      type: "dsa",
      parts: [
        {name: "p", data: p},
        {name: "q", data: q2},
        {name: "g", data: g},
        {name: "y", data: y},
        {name: "x", data: x}
      ]
    };
    return new PrivateKey(key);
  }
  function readECDSACurve(der) {
    var curveName, curveNames;
    var j, c, cd;
    if (der.peek() === asn1.Ber.OID) {
      var oid = der.readOID();
      curveNames = Object.keys(algs.curves);
      for (j = 0; j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        if (cd.pkcs8oid === oid) {
          curveName = c;
          break;
        }
      }
    } else {
      der.readSequence();
      var version = der.readString(asn1.Ber.Integer, true);
      assert.strictEqual(version[0], 1, "ECDSA key not version 1");
      var curve = {};
      der.readSequence();
      var fieldTypeOid = der.readOID();
      assert.strictEqual(fieldTypeOid, "1.2.840.10045.1.1", "ECDSA key is not from a prime-field");
      var p = curve.p = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      curve.size = p.length * 8 - utils.countZeros(p);
      der.readSequence();
      curve.a = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      curve.b = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      if (der.peek() === asn1.Ber.BitString)
        curve.s = der.readString(asn1.Ber.BitString, true);
      curve.G = der.readString(asn1.Ber.OctetString, true);
      assert.strictEqual(curve.G[0], 4, "uncompressed G is required");
      curve.n = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      curve.h = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      assert.strictEqual(curve.h[0], 1, "a cofactor=1 curve is required");
      curveNames = Object.keys(algs.curves);
      var ks = Object.keys(curve);
      for (j = 0; j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        var equal = true;
        for (var i = 0; i < ks.length; ++i) {
          var k = ks[i];
          if (cd[k] === void 0)
            continue;
          if (typeof cd[k] === "object" && cd[k].equals !== void 0) {
            if (!cd[k].equals(curve[k])) {
              equal = false;
              break;
            }
          } else if (Buffer2.isBuffer(cd[k])) {
            if (cd[k].toString("binary") !== curve[k].toString("binary")) {
              equal = false;
              break;
            }
          } else {
            if (cd[k] !== curve[k]) {
              equal = false;
              break;
            }
          }
        }
        if (equal) {
          curveName = c;
          break;
        }
      }
    }
    return curveName;
  }
  function readPkcs8ECDSAPrivate(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var version = readMPInt(der, "version");
    assert.equal(version[0], 1, "unknown version of ECDSA key");
    var d = der.readString(asn1.Ber.OctetString, true);
    var Q;
    if (der.peek() == 160) {
      der.readSequence(160);
      der._offset += der.length;
    }
    if (der.peek() == 161) {
      der.readSequence(161);
      Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
    }
    if (Q === void 0) {
      var pub = utils.publicFromPrivateECDSA(curveName, d);
      Q = pub.part.Q.data;
    }
    var key = {
      type: "ecdsa",
      parts: [
        {name: "curve", data: Buffer2.from(curveName)},
        {name: "Q", data: Q},
        {name: "d", data: d}
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8ECDSAPublic(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        {name: "curve", data: Buffer2.from(curveName)},
        {name: "Q", data: Q}
      ]
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPublic(der) {
    if (der.peek() === 0)
      der.readByte();
    var A = utils.readBitString(der);
    var key = {
      type: "ed25519",
      parts: [
        {name: "A", data: utils.zeroPadToLength(A, 32)}
      ]
    };
    return new Key(key);
  }
  function readPkcs8X25519Public(der) {
    var A = utils.readBitString(der);
    var key = {
      type: "curve25519",
      parts: [
        {name: "A", data: utils.zeroPadToLength(A, 32)}
      ]
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPrivate(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A;
    if (der.peek() === asn1.Ber.BitString) {
      A = utils.readBitString(der);
      A = utils.zeroPadToLength(A, 32);
    } else {
      A = utils.calculateED25519Public(k);
    }
    var key = {
      type: "ed25519",
      parts: [
        {name: "A", data: utils.zeroPadToLength(A, 32)},
        {name: "k", data: utils.zeroPadToLength(k, 32)}
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8X25519Private(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A = utils.calculateX25519Public(k);
    var key = {
      type: "curve25519",
      parts: [
        {name: "A", data: utils.zeroPadToLength(A, 32)},
        {name: "k", data: utils.zeroPadToLength(k, 32)}
      ]
    };
    return new PrivateKey(key);
  }
  function pkcs8ToBuffer(key) {
    var der = new asn1.BerWriter();
    writePkcs8(der, key);
    return der.buffer;
  }
  function writePkcs8(der, key) {
    der.startSequence();
    if (PrivateKey.isPrivateKey(key)) {
      var sillyInt = Buffer2.from([0]);
      der.writeBuffer(sillyInt, asn1.Ber.Integer);
    }
    der.startSequence();
    switch (key.type) {
      case "rsa":
        der.writeOID("1.2.840.113549.1.1.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8RSAPrivate(key, der);
        else
          writePkcs8RSAPublic(key, der);
        break;
      case "dsa":
        der.writeOID("1.2.840.10040.4.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8DSAPrivate(key, der);
        else
          writePkcs8DSAPublic(key, der);
        break;
      case "ecdsa":
        der.writeOID("1.2.840.10045.2.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8ECDSAPrivate(key, der);
        else
          writePkcs8ECDSAPublic(key, der);
        break;
      case "ed25519":
        der.writeOID("1.3.101.112");
        if (PrivateKey.isPrivateKey(key))
          throw new Error("Ed25519 private keys in pkcs8 format are not supported");
        writePkcs8EdDSAPublic(key, der);
        break;
      default:
        throw new Error("Unsupported key type: " + key.type);
    }
    der.endSequence();
  }
  function writePkcs8RSAPrivate(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([0]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq)
      utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8RSAPublic(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.startSequence();
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8DSAPrivate(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writePkcs8DSAPublic(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writeECDSACurve(key, der) {
    var curve = algs.curves[key.curve];
    if (curve.pkcs8oid) {
      der.writeOID(curve.pkcs8oid);
    } else {
      der.startSequence();
      var version = Buffer2.from([1]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.startSequence();
      der.writeOID("1.2.840.10045.1.1");
      der.writeBuffer(curve.p, asn1.Ber.Integer);
      der.endSequence();
      der.startSequence();
      var a = curve.p;
      if (a[0] === 0)
        a = a.slice(1);
      der.writeBuffer(a, asn1.Ber.OctetString);
      der.writeBuffer(curve.b, asn1.Ber.OctetString);
      der.writeBuffer(curve.s, asn1.Ber.BitString);
      der.endSequence();
      der.writeBuffer(curve.G, asn1.Ber.OctetString);
      der.writeBuffer(curve.n, asn1.Ber.Integer);
      var h = curve.h;
      if (!h) {
        h = Buffer2.from([1]);
      }
      der.writeBuffer(h, asn1.Ber.Integer);
      der.endSequence();
    }
  }
  function writePkcs8ECDSAPublic(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs8ECDSAPrivate(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([1]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8EdDSAPublic(key, der) {
    der.endSequence();
    utils.writeBitString(der, key.part.A.data);
  }
});

// node_modules/sshpk/lib/formats/pkcs1.js
var require_pkcs1 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readPkcs1,
    write,
    writePkcs1
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var pkcs8 = require_pkcs8();
  var readECDSACurve = pkcs8.readECDSACurve;
  function read(buf, options) {
    return pem.read(buf, options, "pkcs1");
  }
  function write(key, options) {
    return pem.write(key, options, "pkcs1");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs1(alg, type, der) {
    switch (alg) {
      case "RSA":
        if (type === "public")
          return readPkcs1RSAPublic(der);
        else if (type === "private")
          return readPkcs1RSAPrivate(der);
        throw new Error("Unknown key type: " + type);
      case "DSA":
        if (type === "public")
          return readPkcs1DSAPublic(der);
        else if (type === "private")
          return readPkcs1DSAPrivate(der);
        throw new Error("Unknown key type: " + type);
      case "EC":
      case "ECDSA":
        if (type === "private")
          return readPkcs1ECDSAPrivate(der);
        else if (type === "public")
          return readPkcs1ECDSAPublic(der);
        throw new Error("Unknown key type: " + type);
      case "EDDSA":
      case "EdDSA":
        if (type === "private")
          return readPkcs1EdDSAPrivate(der);
        throw new Error(type + " keys not supported with EdDSA");
      default:
        throw new Error("Unknown key algo: " + alg);
    }
  }
  function readPkcs1RSAPublic(der) {
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key = {
      type: "rsa",
      parts: [
        {name: "e", data: e},
        {name: "n", data: n}
      ]
    };
    return new Key(key);
  }
  function readPkcs1RSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version[0], 0);
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key = {
      type: "rsa",
      parts: [
        {name: "n", data: n},
        {name: "e", data: e},
        {name: "d", data: d},
        {name: "iqmp", data: iqmp},
        {name: "p", data: p},
        {name: "q", data: q2},
        {name: "dmodp", data: dmodp},
        {name: "dmodq", data: dmodq}
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 0);
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var y = readMPInt(der, "y");
    var x = readMPInt(der, "x");
    var key = {
      type: "dsa",
      parts: [
        {name: "p", data: p},
        {name: "q", data: q2},
        {name: "g", data: g},
        {name: "y", data: y},
        {name: "x", data: x}
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1EdDSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 1);
    var k = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var oid = der.readOID();
    assert.strictEqual(oid, "1.3.101.112", "the ed25519 curve identifier");
    der.readSequence(161);
    var A = utils.readBitString(der);
    var key = {
      type: "ed25519",
      parts: [
        {name: "A", data: utils.zeroPadToLength(A, 32)},
        {name: "k", data: k}
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPublic(der) {
    var y = readMPInt(der, "y");
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var key = {
      type: "dsa",
      parts: [
        {name: "y", data: y},
        {name: "p", data: p},
        {name: "q", data: q2},
        {name: "g", data: g}
      ]
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPublic(der) {
    der.readSequence();
    var oid = der.readOID();
    assert.strictEqual(oid, "1.2.840.10045.2.1", "must be ecPublicKey");
    var curveOid = der.readOID();
    var curve;
    var curves = Object.keys(algs.curves);
    for (var j = 0; j < curves.length; ++j) {
      var c = curves[j];
      var cd = algs.curves[c];
      if (cd.pkcs8oid === curveOid) {
        curve = c;
        break;
      }
    }
    assert.string(curve, "a known ECDSA named curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        {name: "curve", data: Buffer2.from(curve)},
        {name: "Q", data: Q}
      ]
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 1);
    var d = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var curve = readECDSACurve(der);
    assert.string(curve, "a known elliptic curve");
    der.readSequence(161);
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        {name: "curve", data: Buffer2.from(curve)},
        {name: "Q", data: Q},
        {name: "d", data: d}
      ]
    };
    return new PrivateKey(key);
  }
  function writePkcs1(der, key) {
    der.startSequence();
    switch (key.type) {
      case "rsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1RSAPrivate(der, key);
        else
          writePkcs1RSAPublic(der, key);
        break;
      case "dsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1DSAPrivate(der, key);
        else
          writePkcs1DSAPublic(der, key);
        break;
      case "ecdsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1ECDSAPrivate(der, key);
        else
          writePkcs1ECDSAPublic(der, key);
        break;
      case "ed25519":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1EdDSAPrivate(der, key);
        else
          writePkcs1EdDSAPublic(der, key);
        break;
      default:
        throw new Error("Unknown key algo: " + key.type);
    }
    der.endSequence();
  }
  function writePkcs1RSAPublic(der, key) {
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
  }
  function writePkcs1RSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq)
      utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPublic(der, key) {
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
  }
  function writePkcs1ECDSAPublic(der, key) {
    der.startSequence();
    der.writeOID("1.2.840.10045.2.1");
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs1ECDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(160);
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
  }
  function writePkcs1EdDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);
    der.startSequence(160);
    der.writeOID("1.3.101.112");
    der.endSequence();
    der.startSequence(161);
    utils.writeBitString(der, key.part.A.data);
    der.endSequence();
  }
  function writePkcs1EdDSAPublic(der, key) {
    throw new Error("Public keys are not supported for EdDSA PKCS#1");
  }
});

// node_modules/sshpk/lib/formats/rfc4253.js
var require_rfc4253 = __commonJS((exports2, module2) => {
  module2.exports = {
    read: read.bind(void 0, false, void 0),
    readType: read.bind(void 0, false),
    write,
    readPartial: read.bind(void 0, true),
    readInternal: read,
    keyTypeToAlg,
    algToKeyType
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var SSHBuffer = require_ssh_buffer();
  function algToKeyType(alg) {
    assert.string(alg);
    if (alg === "ssh-dss")
      return "dsa";
    else if (alg === "ssh-rsa")
      return "rsa";
    else if (alg === "ssh-ed25519")
      return "ed25519";
    else if (alg === "ssh-curve25519")
      return "curve25519";
    else if (alg.match(/^ecdsa-sha2-/))
      return "ecdsa";
    else
      throw new Error("Unknown algorithm " + alg);
  }
  function keyTypeToAlg(key) {
    assert.object(key);
    if (key.type === "dsa")
      return "ssh-dss";
    else if (key.type === "rsa")
      return "ssh-rsa";
    else if (key.type === "ed25519")
      return "ssh-ed25519";
    else if (key.type === "curve25519")
      return "ssh-curve25519";
    else if (key.type === "ecdsa")
      return "ecdsa-sha2-" + key.part.curve.data.toString();
    else
      throw new Error("Unknown key type " + key.type);
  }
  function read(partial, type, buf, options) {
    if (typeof buf === "string")
      buf = Buffer2.from(buf);
    assert.buffer(buf, "buf");
    var key = {};
    var parts = key.parts = [];
    var sshbuf = new SSHBuffer({buffer: buf});
    var alg = sshbuf.readString();
    assert.ok(!sshbuf.atEnd(), "key must have at least one part");
    key.type = algToKeyType(alg);
    var partCount = algs.info[key.type].parts.length;
    if (type && type === "private")
      partCount = algs.privInfo[key.type].parts.length;
    while (!sshbuf.atEnd() && parts.length < partCount)
      parts.push(sshbuf.readPart());
    while (!partial && !sshbuf.atEnd())
      parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, "key must have at least one part");
    assert.ok(partial || sshbuf.atEnd(), "leftover bytes at end of key");
    var Constructor = Key;
    var algInfo = algs.info[key.type];
    if (type === "private" || algInfo.parts.length !== parts.length) {
      algInfo = algs.privInfo[key.type];
      Constructor = PrivateKey;
    }
    assert.strictEqual(algInfo.parts.length, parts.length);
    if (key.type === "ecdsa") {
      var res = /^ecdsa-sha2-(.+)$/.exec(alg);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    var normalized = true;
    for (var i = 0; i < algInfo.parts.length; ++i) {
      var p = parts[i];
      p.name = algInfo.parts[i];
      if (key.type === "ed25519" && p.name === "k")
        p.data = p.data.slice(0, 32);
      if (p.name !== "curve" && algInfo.normalize !== false) {
        var nd;
        if (key.type === "ed25519") {
          nd = utils.zeroPadToLength(p.data, 32);
        } else {
          nd = utils.mpNormalize(p.data);
        }
        if (nd.toString("binary") !== p.data.toString("binary")) {
          p.data = nd;
          normalized = false;
        }
      }
    }
    if (normalized)
      key._rfc4253Cache = sshbuf.toBuffer();
    if (partial && typeof partial === "object") {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Constructor(key);
  }
  function write(key, options) {
    assert.object(key);
    var alg = keyTypeToAlg(key);
    var i;
    var algInfo = algs.info[key.type];
    if (PrivateKey.isPrivateKey(key))
      algInfo = algs.privInfo[key.type];
    var parts = algInfo.parts;
    var buf = new SSHBuffer({});
    buf.writeString(alg);
    for (i = 0; i < parts.length; ++i) {
      var data = key.part[parts[i]].data;
      if (algInfo.normalize !== false) {
        if (key.type === "ed25519")
          data = utils.zeroPadToLength(data, 32);
        else
          data = utils.mpNormalize(data);
      }
      if (key.type === "ed25519" && parts[i] === "k")
        data = Buffer2.concat([data, key.part.A.data]);
      buf.writeBuffer(data);
    }
    return buf.toBuffer();
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS((exports2, module2) => {
  "use strict";
  var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
  var BLF_J = 0;
  var Blowfish = function() {
    this.S = [
      new Uint32Array([
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946
      ]),
      new Uint32Array([
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055
      ]),
      new Uint32Array([
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504
      ]),
      new Uint32Array([
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ])
    ];
    this.P = new Uint32Array([
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ]);
  };
  function F(S, x8, i) {
    return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
  }
  Blowfish.prototype.encipher = function(x, x8) {
    if (x8 === void 0) {
      x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
    }
    x[0] ^= this.P[0];
    for (var i = 1; i < 16; i += 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[17];
    x[1] = t;
  };
  Blowfish.prototype.decipher = function(x) {
    var x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0)
      x8 = x8.subarray(x.byteOffset);
    x[0] ^= this.P[17];
    for (var i = 16; i > 0; i -= 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[0];
    x[1] = t;
  };
  function stream2word(data, databytes) {
    var i, temp = 0;
    for (i = 0; i < 4; i++, BLF_J++) {
      if (BLF_J >= databytes)
        BLF_J = 0;
      temp = temp << 8 | data[BLF_J];
    }
    return temp;
  }
  Blowfish.prototype.expand0state = function(key, keybytes) {
    var d = new Uint32Array(2), i, k;
    var d8 = new Uint8Array(d.buffer);
    for (i = 0, BLF_J = 0; i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    BLF_J = 0;
    for (i = 0; i < 18; i += 2) {
      this.encipher(d, d8);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0; i < 4; i++) {
      for (k = 0; k < 256; k += 2) {
        this.encipher(d, d8);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
  };
  Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
    var d = new Uint32Array(2), i, k;
    for (i = 0, BLF_J = 0; i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    for (i = 0, BLF_J = 0; i < 18; i += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0; i < 4; i++) {
      for (k = 0; k < 256; k += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
    BLF_J = 0;
  };
  Blowfish.prototype.enc = function(data, blocks) {
    for (var i = 0; i < blocks; i++) {
      this.encipher(data.subarray(i * 2));
    }
  };
  Blowfish.prototype.dec = function(data, blocks) {
    for (var i = 0; i < blocks; i++) {
      this.decipher(data.subarray(i * 2));
    }
  };
  var BCRYPT_BLOCKS = 8;
  var BCRYPT_HASHSIZE = 32;
  function bcrypt_hash(sha2pass, sha2salt, out) {
    var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
      79,
      120,
      121,
      99,
      104,
      114,
      111,
      109,
      97,
      116,
      105,
      99,
      66,
      108,
      111,
      119,
      102,
      105,
      115,
      104,
      83,
      119,
      97,
      116,
      68,
      121,
      110,
      97,
      109,
      105,
      116,
      101
    ]);
    state.expandstate(sha2salt, 64, sha2pass, 64);
    for (i = 0; i < 64; i++) {
      state.expand0state(sha2salt, 64);
      state.expand0state(sha2pass, 64);
    }
    for (i = 0; i < BCRYPT_BLOCKS; i++)
      cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
    for (i = 0; i < 64; i++)
      state.enc(cdata, cdata.byteLength / 8);
    for (i = 0; i < BCRYPT_BLOCKS; i++) {
      out[4 * i + 3] = cdata[i] >>> 24;
      out[4 * i + 2] = cdata[i] >>> 16;
      out[4 * i + 1] = cdata[i] >>> 8;
      out[4 * i + 0] = cdata[i];
    }
  }
  function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
    var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
    if (rounds < 1)
      return -1;
    if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
      return -1;
    stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
    amt = Math.floor((keylen + stride - 1) / stride);
    for (i = 0; i < saltlen; i++)
      countsalt[i] = salt[i];
    crypto_hash_sha512(sha2pass, pass, passlen);
    for (count = 1; keylen > 0; count++) {
      countsalt[saltlen + 0] = count >>> 24;
      countsalt[saltlen + 1] = count >>> 16;
      countsalt[saltlen + 2] = count >>> 8;
      countsalt[saltlen + 3] = count;
      crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (i = out.byteLength; i--; )
        out[i] = tmpout[i];
      for (i = 1; i < rounds; i++) {
        crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (j = 0; j < out.byteLength; j++)
          out[j] ^= tmpout[j];
      }
      amt = Math.min(amt, keylen);
      for (i = 0; i < amt; i++) {
        dest = i * stride + (count - 1);
        if (dest >= origkeylen)
          break;
        key[dest] = out[i];
      }
      keylen -= i;
    }
    return 0;
  }
  module2.exports = {
    BLOCKS: BCRYPT_BLOCKS,
    HASHSIZE: BCRYPT_HASHSIZE,
    hash: bcrypt_hash,
    pbkdf: bcrypt_pbkdf
  };
});

// node_modules/sshpk/lib/formats/ssh-private.js
var require_ssh_private = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readSSHPrivate,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var crypto = require("crypto");
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var rfc4253 = require_rfc4253();
  var SSHBuffer = require_ssh_buffer();
  var errors = require_errors();
  var bcrypt;
  function read(buf, options) {
    return pem.read(buf, options);
  }
  var MAGIC = "openssh-key-v1";
  function readSSHPrivate(type, buf, options) {
    buf = new SSHBuffer({buffer: buf});
    var magic = buf.readCString();
    assert.strictEqual(magic, MAGIC, "bad magic string");
    var cipher = buf.readString();
    var kdf = buf.readString();
    var kdfOpts = buf.readBuffer();
    var nkeys = buf.readInt();
    if (nkeys !== 1) {
      throw new Error("OpenSSH-format key file contains multiple keys: this is unsupported.");
    }
    var pubKey = buf.readBuffer();
    if (type === "public") {
      assert.ok(buf.atEnd(), "excess bytes left after key");
      return rfc4253.read(pubKey);
    }
    var privKeyBlob = buf.readBuffer();
    assert.ok(buf.atEnd(), "excess bytes left after key");
    var kdfOptsBuf = new SSHBuffer({buffer: kdfOpts});
    switch (kdf) {
      case "none":
        if (cipher !== "none") {
          throw new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"');
        }
        break;
      case "bcrypt":
        var salt = kdfOptsBuf.readBuffer();
        var rounds = kdfOptsBuf.readInt();
        var cinf = utils.opensshCipherInfo(cipher);
        if (bcrypt === void 0) {
          bcrypt = require_bcrypt_pbkdf();
        }
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "OpenSSH");
        }
        var pass = new Uint8Array(options.passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createDecipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          if (e.toString().indexOf("bad decrypt") !== -1) {
            throw new Error("Incorrect passphrase supplied, could not decrypt key");
          }
          throw e;
        });
        cipherStream.write(privKeyBlob);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privKeyBlob = Buffer2.concat(chunks);
        break;
      default:
        throw new Error('OpenSSH-format key uses unknown KDF "' + kdf + '"');
    }
    buf = new SSHBuffer({buffer: privKeyBlob});
    var checkInt1 = buf.readInt();
    var checkInt2 = buf.readInt();
    if (checkInt1 !== checkInt2) {
      throw new Error("Incorrect passphrase supplied, could not decrypt key");
    }
    var ret = {};
    var key = rfc4253.readInternal(ret, "private", buf.remainder());
    buf.skip(ret.consumed);
    var comment = buf.readString();
    key.comment = comment;
    return key;
  }
  function write(key, options) {
    var pubKey;
    if (PrivateKey.isPrivateKey(key))
      pubKey = key.toPublic();
    else
      pubKey = key;
    var cipher = "none";
    var kdf = "none";
    var kdfopts = Buffer2.alloc(0);
    var cinf = {blockSize: 8};
    var passphrase;
    if (options !== void 0) {
      passphrase = options.passphrase;
      if (typeof passphrase === "string")
        passphrase = Buffer2.from(passphrase, "utf-8");
      if (passphrase !== void 0) {
        assert.buffer(passphrase, "options.passphrase");
        assert.optionalString(options.cipher, "options.cipher");
        cipher = options.cipher;
        if (cipher === void 0)
          cipher = "aes128-ctr";
        cinf = utils.opensshCipherInfo(cipher);
        kdf = "bcrypt";
      }
    }
    var privBuf;
    if (PrivateKey.isPrivateKey(key)) {
      privBuf = new SSHBuffer({});
      var checkInt = crypto.randomBytes(4).readUInt32BE(0);
      privBuf.writeInt(checkInt);
      privBuf.writeInt(checkInt);
      privBuf.write(key.toBuffer("rfc4253"));
      privBuf.writeString(key.comment || "");
      var n = 1;
      while (privBuf._offset % cinf.blockSize !== 0)
        privBuf.writeChar(n++);
      privBuf = privBuf.toBuffer();
    }
    switch (kdf) {
      case "none":
        break;
      case "bcrypt":
        var salt = crypto.randomBytes(16);
        var rounds = 16;
        var kdfssh = new SSHBuffer({});
        kdfssh.writeBuffer(salt);
        kdfssh.writeInt(rounds);
        kdfopts = kdfssh.toBuffer();
        if (bcrypt === void 0) {
          bcrypt = require_bcrypt_pbkdf();
        }
        var pass = new Uint8Array(passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createCipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          throw e;
        });
        cipherStream.write(privBuf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privBuf = Buffer2.concat(chunks);
        break;
      default:
        throw new Error("Unsupported kdf " + kdf);
    }
    var buf = new SSHBuffer({});
    buf.writeCString(MAGIC);
    buf.writeString(cipher);
    buf.writeString(kdf);
    buf.writeBuffer(kdfopts);
    buf.writeInt(1);
    buf.writeBuffer(pubKey.toBuffer("rfc4253"));
    if (privBuf)
      buf.writeBuffer(privBuf);
    buf = buf.toBuffer();
    var header;
    if (PrivateKey.isPrivateKey(key))
      header = "OPENSSH PRIVATE KEY";
    else
      header = "OPENSSH PUBLIC KEY";
    var tmp = buf.toString("base64");
    var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
    buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + "-----\n", o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 70;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + "-----\n", o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/formats/pem.js
var require_pem = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var crypto = require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pkcs1 = require_pkcs1();
  var pkcs8 = require_pkcs8();
  var sshpriv = require_ssh_private();
  var rfc4253 = require_rfc4253();
  var errors = require_errors();
  var OID_PBES2 = "1.2.840.113549.1.5.13";
  var OID_PBKDF2 = "1.2.840.113549.1.5.12";
  var OID_TO_CIPHER = {
    "1.2.840.113549.3.7": "3des-cbc",
    "2.16.840.1.101.3.4.1.2": "aes128-cbc",
    "2.16.840.1.101.3.4.1.42": "aes256-cbc"
  };
  var CIPHER_TO_OID = {};
  Object.keys(OID_TO_CIPHER).forEach(function(k) {
    CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
  });
  var OID_TO_HASH = {
    "1.2.840.113549.2.7": "sha1",
    "1.2.840.113549.2.9": "sha256",
    "1.2.840.113549.2.11": "sha512"
  };
  var HASH_TO_OID = {};
  Object.keys(OID_TO_HASH).forEach(function(k) {
    HASH_TO_OID[OID_TO_HASH[k]] = k;
  });
  function read(buf, options, forceType) {
    var input = buf;
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(/[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(/[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
    }
    assert.ok(m2, "invalid PEM footer");
    assert.equal(m[2], m2[2]);
    var type = m[2].toLowerCase();
    var alg;
    if (m[1]) {
      assert.equal(m[1], m2[1], "PEM header and footer mismatch");
      alg = m[1].trim();
    }
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    var cipher, key, iv;
    if (headers["proc-type"]) {
      var parts = headers["proc-type"].split(",");
      if (parts[0] === "4" && parts[1] === "ENCRYPTED") {
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "PEM");
        } else {
          parts = headers["dek-info"].split(",");
          assert.ok(parts.length === 2);
          cipher = parts[0].toLowerCase();
          iv = Buffer2.from(parts[1], "hex");
          key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;
        }
      }
    }
    if (alg && alg.toLowerCase() === "encrypted") {
      var eder = new asn1.BerReader(buf);
      var pbesEnd;
      eder.readSequence();
      eder.readSequence();
      pbesEnd = eder.offset + eder.length;
      var method = eder.readOID();
      if (method !== OID_PBES2) {
        throw new Error("Unsupported PEM/PKCS8 encryption scheme: " + method);
      }
      eder.readSequence();
      eder.readSequence();
      var kdfEnd = eder.offset + eder.length;
      var kdfOid = eder.readOID();
      if (kdfOid !== OID_PBKDF2)
        throw new Error("Unsupported PBES2 KDF: " + kdfOid);
      eder.readSequence();
      var salt = eder.readString(asn1.Ber.OctetString, true);
      var iterations = eder.readInt();
      var hashAlg = "sha1";
      if (eder.offset < kdfEnd) {
        eder.readSequence();
        var hashAlgOid = eder.readOID();
        hashAlg = OID_TO_HASH[hashAlgOid];
        if (hashAlg === void 0) {
          throw new Error("Unsupported PBKDF2 hash: " + hashAlgOid);
        }
      }
      eder._offset = kdfEnd;
      eder.readSequence();
      var cipherOid = eder.readOID();
      cipher = OID_TO_CIPHER[cipherOid];
      if (cipher === void 0) {
        throw new Error("Unsupported PBES2 cipher: " + cipherOid);
      }
      iv = eder.readString(asn1.Ber.OctetString, true);
      eder._offset = pbesEnd;
      buf = eder.readString(asn1.Ber.OctetString, true);
      if (typeof options.passphrase === "string") {
        options.passphrase = Buffer2.from(options.passphrase, "utf-8");
      }
      if (!Buffer2.isBuffer(options.passphrase)) {
        throw new errors.KeyEncryptedError(options.filename, "PEM");
      }
      var cinfo = utils.opensshCipherInfo(cipher);
      cipher = cinfo.opensslName;
      key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize, options.passphrase);
      alg = void 0;
    }
    if (cipher && key && iv) {
      var cipherStream = crypto.createDecipheriv(cipher, key, iv);
      var chunk, chunks = [];
      cipherStream.once("error", function(e) {
        if (e.toString().indexOf("bad decrypt") !== -1) {
          throw new Error("Incorrect passphrase supplied, could not decrypt key");
        }
        throw e;
      });
      cipherStream.write(buf);
      cipherStream.end();
      while ((chunk = cipherStream.read()) !== null)
        chunks.push(chunk);
      buf = Buffer2.concat(chunks);
    }
    if (alg && alg.toLowerCase() === "openssh")
      return sshpriv.readSSHPrivate(type, buf, options);
    if (alg && alg.toLowerCase() === "ssh2")
      return rfc4253.readType(type, buf, options);
    var der = new asn1.BerReader(buf);
    der.originalInput = input;
    der.readSequence();
    if (alg) {
      if (forceType)
        assert.strictEqual(forceType, "pkcs1");
      return pkcs1.readPkcs1(alg, type, der);
    } else {
      if (forceType)
        assert.strictEqual(forceType, "pkcs8");
      return pkcs8.readPkcs8(alg, type, der);
    }
  }
  function write(key, options, type) {
    assert.object(key);
    var alg = {
      ecdsa: "EC",
      rsa: "RSA",
      dsa: "DSA",
      ed25519: "EdDSA"
    }[key.type];
    var header;
    var der = new asn1.BerWriter();
    if (PrivateKey.isPrivateKey(key)) {
      if (type && type === "pkcs8") {
        header = "PRIVATE KEY";
        pkcs8.writePkcs8(der, key);
      } else {
        if (type)
          assert.strictEqual(type, "pkcs1");
        header = alg + " PRIVATE KEY";
        pkcs1.writePkcs1(der, key);
      }
    } else if (Key.isKey(key)) {
      if (type && type === "pkcs1") {
        header = alg + " PUBLIC KEY";
        pkcs1.writePkcs1(der, key);
      } else {
        if (type)
          assert.strictEqual(type, "pkcs8");
        header = "PUBLIC KEY";
        pkcs8.writePkcs8(der, key);
      }
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
    var tmp = der.buffer.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + "-----\n", o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + "-----\n", o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/formats/ssh.js
var require_ssh = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var sshpriv = require_ssh_private();
  var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
  var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var trimmed = buf.trim().replace(/[\\\r]/g, "");
    var m = trimmed.match(SSHKEY_RE);
    if (!m)
      m = trimmed.match(SSHKEY_RE2);
    assert.ok(m, "key must match regex");
    var type = rfc4253.algToKeyType(m[1]);
    var kbuf = Buffer2.from(m[2], "base64");
    var key;
    var ret = {};
    if (m[4]) {
      try {
        key = rfc4253.read(kbuf);
      } catch (e) {
        m = trimmed.match(SSHKEY_RE2);
        assert.ok(m, "key must match regex");
        kbuf = Buffer2.from(m[2], "base64");
        key = rfc4253.readInternal(ret, "public", kbuf);
      }
    } else {
      key = rfc4253.readInternal(ret, "public", kbuf);
    }
    assert.strictEqual(type, key.type);
    if (m[4] && m[4].length > 0) {
      key.comment = m[4];
    } else if (ret.consumed) {
      var data = m[2] + (m[3] ? m[3] : "");
      var realOffset = Math.ceil(ret.consumed / 3) * 4;
      data = data.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, "") + data.slice(realOffset - 2);
      var padding = ret.consumed % 3;
      if (padding > 0 && data.slice(realOffset - 1, realOffset) !== "=")
        realOffset--;
      while (data.slice(realOffset, realOffset + 1) === "=")
        realOffset++;
      var trailer = data.slice(realOffset);
      trailer = trailer.replace(/[\r\n]/g, " ").replace(/^\s+/, "");
      if (trailer.match(/^[a-zA-Z0-9]/))
        key.comment = trailer;
    }
    return key;
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key))
      throw new Error("Must be a public key");
    var parts = [];
    var alg = rfc4253.keyTypeToAlg(key);
    parts.push(alg);
    var buf = rfc4253.write(key);
    parts.push(buf.toString("base64"));
    if (key.comment)
      parts.push(key.comment);
    return Buffer2.from(parts.join(" "));
  }
});

// node_modules/sshpk/lib/formats/dnssec.js
var require_dnssec = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Key = require_key();
  var PrivateKey = require_private_key();
  var utils = require_utils();
  var SSHBuffer = require_ssh_buffer();
  var Dhe = require_dhe();
  var supportedAlgos = {
    "rsa-sha1": 5,
    "rsa-sha256": 8,
    "rsa-sha512": 10,
    "ecdsa-p256-sha256": 13,
    "ecdsa-p384-sha384": 14
  };
  var supportedAlgosById = {};
  Object.keys(supportedAlgos).forEach(function(k) {
    supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
  });
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.split("\n");
    if (lines[0].match(/^Private-key-format\: v1/)) {
      var algElems = lines[1].split(" ");
      var algoNum = parseInt(algElems[1], 10);
      var algoName = algElems[2];
      if (!supportedAlgosById[algoNum])
        throw new Error("Unsupported algorithm: " + algoName);
      return readDNSSECPrivateKey(algoNum, lines.slice(2));
    }
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0) {
      return readRFC3110(lines[line]);
    }
    throw new Error("Cannot parse dnssec key");
  }
  function readRFC3110(keyString) {
    var elems = keyString.split(" ");
    var algorithm = parseInt(elems[5], 10);
    if (!supportedAlgosById[algorithm])
      throw new Error("Unsupported algorithm: " + algorithm);
    var base64key = elems.slice(6, elems.length).join();
    var keyBuffer = Buffer2.from(base64key, "base64");
    if (supportedAlgosById[algorithm].match(/^RSA-/)) {
      var publicExponentLen = keyBuffer.readUInt8(0);
      if (publicExponentLen != 3 && publicExponentLen != 1)
        throw new Error("Cannot parse dnssec key: unsupported exponent length");
      var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
      publicExponent = utils.mpNormalize(publicExponent);
      var modulus = keyBuffer.slice(1 + publicExponentLen);
      modulus = utils.mpNormalize(modulus);
      var rsaKey = {
        type: "rsa",
        parts: []
      };
      rsaKey.parts.push({name: "e", data: publicExponent});
      rsaKey.parts.push({name: "n", data: modulus});
      return new Key(rsaKey);
    }
    if (supportedAlgosById[algorithm] === "ECDSA-P384-SHA384" || supportedAlgosById[algorithm] === "ECDSA-P256-SHA256") {
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
        curve = "nistp256";
        size = 256;
      }
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          {name: "curve", data: Buffer2.from(curve)},
          {name: "Q", data: utils.ecNormalize(keyBuffer)}
        ]
      };
      return new Key(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[algorithm]);
  }
  function elementToBuf(e) {
    return Buffer2.from(e.split(" ")[1], "base64");
  }
  function readDNSSECRSAPrivateKey(elements) {
    var rsaParams = {};
    elements.forEach(function(element) {
      if (element.split(" ")[0] === "Modulus:")
        rsaParams["n"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PublicExponent:")
        rsaParams["e"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PrivateExponent:")
        rsaParams["d"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime1:")
        rsaParams["p"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime2:")
        rsaParams["q"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent1:")
        rsaParams["dmodp"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent2:")
        rsaParams["dmodq"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Coefficient:")
        rsaParams["iqmp"] = elementToBuf(element);
    });
    var key = {
      type: "rsa",
      parts: [
        {name: "e", data: utils.mpNormalize(rsaParams["e"])},
        {name: "n", data: utils.mpNormalize(rsaParams["n"])},
        {name: "d", data: utils.mpNormalize(rsaParams["d"])},
        {name: "p", data: utils.mpNormalize(rsaParams["p"])},
        {name: "q", data: utils.mpNormalize(rsaParams["q"])},
        {
          name: "dmodp",
          data: utils.mpNormalize(rsaParams["dmodp"])
        },
        {
          name: "dmodq",
          data: utils.mpNormalize(rsaParams["dmodq"])
        },
        {
          name: "iqmp",
          data: utils.mpNormalize(rsaParams["iqmp"])
        }
      ]
    };
    return new PrivateKey(key);
  }
  function readDNSSECPrivateKey(alg, elements) {
    if (supportedAlgosById[alg].match(/^RSA-/)) {
      return readDNSSECRSAPrivateKey(elements);
    }
    if (supportedAlgosById[alg] === "ECDSA-P384-SHA384" || supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
      var d = Buffer2.from(elements[0].split(" ")[1], "base64");
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
        curve = "nistp256";
        size = 256;
      }
      var publicKey = utils.publicFromPrivateECDSA(curve, d);
      var Q = publicKey.part["Q"].data;
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          {name: "curve", data: Buffer2.from(curve)},
          {name: "d", data: d},
          {name: "Q", data: Q}
        ]
      };
      return new PrivateKey(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[alg]);
  }
  function dnssecTimestamp(date) {
    var year = date.getFullYear() + "";
    var month = date.getMonth() + 1;
    var timestampStr = year + month + date.getUTCDate();
    timestampStr += "" + date.getUTCHours() + date.getUTCMinutes();
    timestampStr += date.getUTCSeconds();
    return timestampStr;
  }
  function rsaAlgFromOptions(opts) {
    if (!opts || !opts.hashAlgo || opts.hashAlgo === "sha1")
      return "5 (RSASHA1)";
    else if (opts.hashAlgo === "sha256")
      return "8 (RSASHA256)";
    else if (opts.hashAlgo === "sha512")
      return "10 (RSASHA512)";
    else
      throw new Error("Unknown or unsupported hash: " + opts.hashAlgo);
  }
  function writeRSA(key, options) {
    if (!key.part.dmodp || !key.part.dmodq) {
      utils.addRSAMissing(key);
    }
    var out = "";
    out += "Private-key-format: v1.3\n";
    out += "Algorithm: " + rsaAlgFromOptions(options) + "\n";
    var n = utils.mpDenormalize(key.part["n"].data);
    out += "Modulus: " + n.toString("base64") + "\n";
    var e = utils.mpDenormalize(key.part["e"].data);
    out += "PublicExponent: " + e.toString("base64") + "\n";
    var d = utils.mpDenormalize(key.part["d"].data);
    out += "PrivateExponent: " + d.toString("base64") + "\n";
    var p = utils.mpDenormalize(key.part["p"].data);
    out += "Prime1: " + p.toString("base64") + "\n";
    var q2 = utils.mpDenormalize(key.part["q"].data);
    out += "Prime2: " + q2.toString("base64") + "\n";
    var dmodp = utils.mpDenormalize(key.part["dmodp"].data);
    out += "Exponent1: " + dmodp.toString("base64") + "\n";
    var dmodq = utils.mpDenormalize(key.part["dmodq"].data);
    out += "Exponent2: " + dmodq.toString("base64") + "\n";
    var iqmp = utils.mpDenormalize(key.part["iqmp"].data);
    out += "Coefficient: " + iqmp.toString("base64") + "\n";
    var timestamp = new Date();
    out += "Created: " + dnssecTimestamp(timestamp) + "\n";
    out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
    out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
    return Buffer2.from(out, "ascii");
  }
  function writeECDSA(key, options) {
    var out = "";
    out += "Private-key-format: v1.3\n";
    if (key.curve === "nistp256") {
      out += "Algorithm: 13 (ECDSAP256SHA256)\n";
    } else if (key.curve === "nistp384") {
      out += "Algorithm: 14 (ECDSAP384SHA384)\n";
    } else {
      throw new Error("Unsupported curve");
    }
    var base64Key = key.part["d"].data.toString("base64");
    out += "PrivateKey: " + base64Key + "\n";
    var timestamp = new Date();
    out += "Created: " + dnssecTimestamp(timestamp) + "\n";
    out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
    out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
    return Buffer2.from(out, "ascii");
  }
  function write(key, options) {
    if (PrivateKey.isPrivateKey(key)) {
      if (key.type === "rsa") {
        return writeRSA(key, options);
      } else if (key.type === "ecdsa") {
        return writeECDSA(key, options);
      } else {
        throw new Error("Unsupported algorithm: " + key.type);
      }
    } else if (Key.isKey(key)) {
      throw new Error('Format "dnssec" only supports writing private keys');
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
  }
});

// node_modules/sshpk/lib/formats/putty.js
var require_putty = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var Key = require_key();
  var errors = require_errors();
  function read(buf, options) {
    var lines = buf.toString("ascii").split(/[\r\n]+/);
    var found = false;
    var parts;
    var si = 0;
    while (si < lines.length) {
      parts = splitHeader(lines[si++]);
      if (parts && parts[0].toLowerCase() === "putty-user-key-file-2") {
        found = true;
        break;
      }
    }
    if (!found) {
      throw new Error("No PuTTY format first line found");
    }
    var alg = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "encryption");
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "comment");
    var comment = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "public-lines");
    var publicLines = parseInt(parts[1], 10);
    if (!isFinite(publicLines) || publicLines < 0 || publicLines > lines.length) {
      throw new Error("Invalid public-lines count");
    }
    var publicBuf = Buffer2.from(lines.slice(si, si + publicLines).join(""), "base64");
    var keyType = rfc4253.algToKeyType(alg);
    var key = rfc4253.read(publicBuf);
    if (key.type !== keyType) {
      throw new Error("Outer key algorithm mismatch");
    }
    key.comment = comment;
    return key;
  }
  function splitHeader(line) {
    var idx = line.indexOf(":");
    if (idx === -1)
      return null;
    var header = line.slice(0, idx);
    ++idx;
    while (line[idx] === " ")
      ++idx;
    var rest = line.slice(idx);
    return [header, rest];
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key))
      throw new Error("Must be a public key");
    var alg = rfc4253.keyTypeToAlg(key);
    var buf = rfc4253.write(key);
    var comment = key.comment || "";
    var b64 = buf.toString("base64");
    var lines = wrap(b64, 64);
    lines.unshift("Public-Lines: " + lines.length);
    lines.unshift("Comment: " + comment);
    lines.unshift("Encryption: none");
    lines.unshift("PuTTY-User-Key-File-2: " + alg);
    return Buffer2.from(lines.join("\n") + "\n");
  }
  function wrap(txt, len) {
    var lines = [];
    var pos = 0;
    while (pos < txt.length) {
      lines.push(txt.slice(pos, pos + 64));
      pos += 64;
    }
    return lines;
  }
});

// node_modules/sshpk/lib/formats/auto.js
var require_auto = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var ssh = require_ssh();
  var rfc4253 = require_rfc4253();
  var dnssec = require_dnssec();
  var putty = require_putty();
  var DNSSEC_PRIVKEY_HEADER_PREFIX = "Private-key-format: v1";
  function read(buf, options) {
    if (typeof buf === "string") {
      if (buf.trim().match(/^[-]+[ ]*BEGIN/))
        return pem.read(buf, options);
      if (buf.match(/^\s*ssh-[a-z]/))
        return ssh.read(buf, options);
      if (buf.match(/^\s*ecdsa-/))
        return ssh.read(buf, options);
      if (buf.match(/^putty-user-key-file-2:/i))
        return putty.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec.read(buf, options);
      buf = Buffer2.from(buf, "binary");
    } else {
      assert.buffer(buf);
      if (findPEMHeader(buf))
        return pem.read(buf, options);
      if (findSSHHeader(buf))
        return ssh.read(buf, options);
      if (findPuTTYHeader(buf))
        return putty.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec.read(buf, options);
    }
    if (buf.readUInt32BE(0) < buf.length)
      return rfc4253.read(buf, options);
    throw new Error("Failed to auto-detect format of key");
  }
  function findPuTTYHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 22 <= buf.length && buf.slice(offset, offset + 22).toString("ascii").toLowerCase() === "putty-user-key-file-2:")
      return true;
    return false;
  }
  function findSSHHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString("ascii") === "ssh-")
      return true;
    if (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString("ascii") === "ecdsa-")
      return true;
    return false;
  }
  function findPEMHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
      ++offset;
    if (buf[offset] !== 45)
      return false;
    while (offset < buf.length && buf[offset] === 45)
      ++offset;
    while (offset < buf.length && buf[offset] === 32)
      ++offset;
    if (offset + 5 > buf.length || buf.slice(offset, offset + 5).toString("ascii") !== "BEGIN")
      return false;
    return true;
  }
  function findDNSSECHeader(buf) {
    if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
      return false;
    var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
    if (headerCheck.toString("ascii") === DNSSEC_PRIVKEY_HEADER_PREFIX)
      return true;
    if (typeof buf !== "string") {
      buf = buf.toString("ascii");
    }
    var lines = buf.split("\n");
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if (lines[line].toString("ascii").match(/\. IN KEY /))
      return true;
    if (lines[line].toString("ascii").match(/\. IN DNSKEY /))
      return true;
    return false;
  }
  function write(key, options) {
    throw new Error('"auto" format cannot be used for writing');
  }
});

// node_modules/sshpk/lib/private-key.js
var require_private_key = __commonJS((exports2, module2) => {
  module2.exports = PrivateKey;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = require("util");
  var utils = require_utils();
  var dhe = require_dhe();
  var generateECDSA = dhe.generateECDSA;
  var generateED25519 = dhe.generateED25519;
  var edCompat = require_ed_compat();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var KeyEncryptedError = errs.KeyEncryptedError;
  var formats = {};
  formats["auto"] = require_auto();
  formats["pem"] = require_pem();
  formats["pkcs1"] = require_pkcs1();
  formats["pkcs8"] = require_pkcs8();
  formats["rfc4253"] = require_rfc4253();
  formats["ssh-private"] = require_ssh_private();
  formats["openssh"] = formats["ssh-private"];
  formats["ssh"] = formats["ssh-private"];
  formats["dnssec"] = require_dnssec();
  function PrivateKey(opts) {
    assert.object(opts, "options");
    Key.call(this, opts);
    this._pubCache = void 0;
  }
  util.inherits(PrivateKey, Key);
  PrivateKey.formats = formats;
  PrivateKey.prototype.toBuffer = function(format, options) {
    if (format === void 0)
      format = "pkcs1";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    return formats[format].write(this, options);
  };
  PrivateKey.prototype.hash = function(algo, type) {
    return this.toPublic().hash(algo, type);
  };
  PrivateKey.prototype.fingerprint = function(algo, type) {
    return this.toPublic().fingerprint(algo, type);
  };
  PrivateKey.prototype.toPublic = function() {
    if (this._pubCache)
      return this._pubCache;
    var algInfo = algs.info[this.type];
    var pubParts = [];
    for (var i = 0; i < algInfo.parts.length; ++i) {
      var p = algInfo.parts[i];
      pubParts.push(this.part[p]);
    }
    this._pubCache = new Key({
      type: this.type,
      source: this,
      parts: pubParts
    });
    if (this.comment)
      this._pubCache.comment = this.comment;
    return this._pubCache;
  };
  PrivateKey.prototype.derive = function(newType) {
    assert.string(newType, "type");
    var priv, pub, pair;
    if (this.type === "ed25519" && newType === "curve25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "curve25519",
        parts: [
          {name: "A", data: utils.mpNormalize(pub)},
          {name: "k", data: utils.mpNormalize(priv)}
        ]
      });
    } else if (this.type === "curve25519" && newType === "ed25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "ed25519",
        parts: [
          {name: "A", data: utils.mpNormalize(pub)},
          {name: "k", data: utils.mpNormalize(priv)}
        ]
      });
    }
    throw new Error("Key derivation not supported from " + this.type + " to " + newType);
  };
  PrivateKey.prototype.createVerify = function(hashAlgo) {
    return this.toPublic().createVerify(hashAlgo);
  };
  PrivateKey.prototype.createSign = function(hashAlgo) {
    if (hashAlgo === void 0)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat !== void 0)
      return new edCompat.Signer(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    } catch (e) {
      err = e;
    }
    if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldSign = v.sign.bind(v);
    var key = this.toBuffer("pkcs1");
    var type = this.type;
    var curve = this.curve;
    v.sign = function() {
      var sig = oldSign(key);
      if (typeof sig === "string")
        sig = Buffer2.from(sig, "binary");
      sig = Signature.parse(sig, type, "asn1");
      sig.hashAlgorithm = hashAlgo;
      sig.curve = curve;
      return sig;
    };
    return v;
  };
  PrivateKey.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === void 0)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = {filename: options};
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === void 0)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      assert.ok(k instanceof PrivateKey, "key is not a private key");
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  PrivateKey.isPrivateKey = function(obj, ver) {
    return utils.isCompatible(obj, PrivateKey, ver);
  };
  PrivateKey.generate = function(type, options) {
    if (options === void 0)
      options = {};
    assert.object(options, "options");
    switch (type) {
      case "ecdsa":
        if (options.curve === void 0)
          options.curve = "nistp256";
        assert.string(options.curve, "options.curve");
        return generateECDSA(options.curve);
      case "ed25519":
        return generateED25519();
      default:
        throw new Error('Key generation not supported with key type "' + type + '"');
    }
  };
  PrivateKey.prototype._sshpkApiVersion = [1, 6];
  PrivateKey._oldVersionDetect = function(obj) {
    assert.func(obj.toPublic);
    assert.func(obj.createSign);
    if (obj.derive)
      return [1, 3];
    if (obj.defaultHashAlgorithm)
      return [1, 2];
    if (obj.formats["auto"])
      return [1, 1];
    return [1, 0];
  };
});

// node_modules/sshpk/lib/identity.js
var require_identity = __commonJS((exports2, module2) => {
  module2.exports = Identity;
  var assert = require_assert();
  var algs = require_algs();
  var crypto = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = require("util");
  var utils = require_utils();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
  var oids = {};
  oids.cn = "2.5.4.3";
  oids.o = "2.5.4.10";
  oids.ou = "2.5.4.11";
  oids.l = "2.5.4.7";
  oids.s = "2.5.4.8";
  oids.c = "2.5.4.6";
  oids.sn = "2.5.4.4";
  oids.postalCode = "2.5.4.17";
  oids.serialNumber = "2.5.4.5";
  oids.street = "2.5.4.9";
  oids.x500UniqueIdentifier = "2.5.4.45";
  oids.role = "2.5.4.72";
  oids.telephoneNumber = "2.5.4.20";
  oids.description = "2.5.4.13";
  oids.dc = "0.9.2342.19200300.100.1.25";
  oids.uid = "0.9.2342.19200300.100.1.1";
  oids.mail = "0.9.2342.19200300.100.1.3";
  oids.title = "2.5.4.12";
  oids.gn = "2.5.4.42";
  oids.initials = "2.5.4.43";
  oids.pseudonym = "2.5.4.65";
  oids.emailAddress = "1.2.840.113549.1.9.1";
  var unoids = {};
  Object.keys(oids).forEach(function(k) {
    unoids[oids[k]] = k;
  });
  function Identity(opts) {
    var self2 = this;
    assert.object(opts, "options");
    assert.arrayOfObject(opts.components, "options.components");
    this.components = opts.components;
    this.componentLookup = {};
    this.components.forEach(function(c) {
      if (c.name && !c.oid)
        c.oid = oids[c.name];
      if (c.oid && !c.name)
        c.name = unoids[c.oid];
      if (self2.componentLookup[c.name] === void 0)
        self2.componentLookup[c.name] = [];
      self2.componentLookup[c.name].push(c);
    });
    if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
      this.cn = this.componentLookup.cn[0].value;
    }
    assert.optionalString(opts.type, "options.type");
    if (opts.type === void 0) {
      if (this.components.length === 1 && this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
        this.type = "host";
        this.hostname = this.componentLookup.dc.map(function(c) {
          return c.value;
        }).join(".");
      } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
        this.type = "email";
        this.email = this.componentLookup.mail[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.cn[0].value;
      } else {
        this.type = "unknown";
      }
    } else {
      this.type = opts.type;
      if (this.type === "host")
        this.hostname = opts.hostname;
      else if (this.type === "user")
        this.uid = opts.uid;
      else if (this.type === "email")
        this.email = opts.email;
      else
        throw new Error("Unknown type " + this.type);
    }
  }
  Identity.prototype.toString = function() {
    return this.components.map(function(c) {
      var n = c.name.toUpperCase();
      n = n.replace(/=/g, "\\=");
      var v = c.value;
      v = v.replace(/,/g, "\\,");
      return n + "=" + v;
    }).join(", ");
  };
  Identity.prototype.get = function(name, asArray) {
    assert.string(name, "name");
    var arr = this.componentLookup[name];
    if (arr === void 0 || arr.length === 0)
      return void 0;
    if (!asArray && arr.length > 1)
      throw new Error("Multiple values for attribute " + name);
    if (!asArray)
      return arr[0].value;
    return arr.map(function(c) {
      return c.value;
    });
  };
  Identity.prototype.toArray = function(idx) {
    return this.components.map(function(c) {
      return {
        name: c.name,
        value: c.value
      };
    });
  };
  var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
  var NOT_IA5 = /[^\x00-\x7f]/;
  Identity.prototype.toAsn1 = function(der, tag) {
    der.startSequence(tag);
    this.components.forEach(function(c) {
      der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      der.startSequence();
      der.writeOID(c.oid);
      if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
        var v = Buffer2.from(c.value, "utf8");
        der.writeBuffer(v, asn1.Ber.Utf8String);
      } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE)) {
        der.writeString(c.value, asn1.Ber.IA5String);
      } else {
        var type = asn1.Ber.PrintableString;
        if (c.asn1type !== void 0)
          type = c.asn1type;
        der.writeString(c.value, type);
      }
      der.endSequence();
      der.endSequence();
    });
    der.endSequence();
  };
  function globMatch(a, b) {
    if (a === "**" || b === "**")
      return true;
    var aParts = a.split(".");
    var bParts = b.split(".");
    if (aParts.length !== bParts.length)
      return false;
    for (var i = 0; i < aParts.length; ++i) {
      if (aParts[i] === "*" || bParts[i] === "*")
        continue;
      if (aParts[i] !== bParts[i])
        return false;
    }
    return true;
  }
  Identity.prototype.equals = function(other) {
    if (!Identity.isIdentity(other, [1, 0]))
      return false;
    if (other.components.length !== this.components.length)
      return false;
    for (var i = 0; i < this.components.length; ++i) {
      if (this.components[i].oid !== other.components[i].oid)
        return false;
      if (!globMatch(this.components[i].value, other.components[i].value)) {
        return false;
      }
    }
    return true;
  };
  Identity.forHost = function(hostname) {
    assert.string(hostname, "hostname");
    return new Identity({
      type: "host",
      hostname,
      components: [{name: "cn", value: hostname}]
    });
  };
  Identity.forUser = function(uid) {
    assert.string(uid, "uid");
    return new Identity({
      type: "user",
      uid,
      components: [{name: "uid", value: uid}]
    });
  };
  Identity.forEmail = function(email) {
    assert.string(email, "email");
    return new Identity({
      type: "email",
      email,
      components: [{name: "mail", value: email}]
    });
  };
  Identity.parseDN = function(dn) {
    assert.string(dn, "dn");
    var parts = [""];
    var idx = 0;
    var rem = dn;
    while (rem.length > 0) {
      var m;
      if ((m = /^,/.exec(rem)) !== null) {
        parts[++idx] = "";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\,/.exec(rem)) !== null) {
        parts[idx] += ",";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\./.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else {
        throw new Error("Failed to parse DN");
      }
    }
    var cmps = parts.map(function(c) {
      c = c.trim();
      var eqPos = c.indexOf("=");
      while (eqPos > 0 && c.charAt(eqPos - 1) === "\\")
        eqPos = c.indexOf("=", eqPos + 1);
      if (eqPos === -1) {
        throw new Error("Failed to parse DN");
      }
      var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, "=");
      var value = c.slice(eqPos + 1);
      return {name, value};
    });
    return new Identity({components: cmps});
  };
  Identity.fromArray = function(components) {
    assert.arrayOfObject(components, "components");
    components.forEach(function(cmp) {
      assert.object(cmp, "component");
      assert.string(cmp.name, "component.name");
      if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === "string")) {
        throw new Error("Invalid component value");
      }
    });
    return new Identity({components});
  };
  Identity.parseAsn1 = function(der, top) {
    var components = [];
    der.readSequence(top);
    var end = der.offset + der.length;
    while (der.offset < end) {
      der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      var after = der.offset + der.length;
      der.readSequence();
      var oid = der.readOID();
      var type = der.peek();
      var value;
      switch (type) {
        case asn1.Ber.PrintableString:
        case asn1.Ber.IA5String:
        case asn1.Ber.OctetString:
        case asn1.Ber.T61String:
          value = der.readString(type);
          break;
        case asn1.Ber.Utf8String:
          value = der.readString(type, true);
          value = value.toString("utf8");
          break;
        case asn1.Ber.CharacterString:
        case asn1.Ber.BMPString:
          value = der.readString(type, true);
          value = value.toString("utf16le");
          break;
        default:
          throw new Error("Unknown asn1 type " + type);
      }
      components.push({oid, asn1type: type, value});
      der._offset = after;
    }
    der._offset = end;
    return new Identity({
      components
    });
  };
  Identity.isIdentity = function(obj, ver) {
    return utils.isCompatible(obj, Identity, ver);
  };
  Identity.prototype._sshpkApiVersion = [1, 0];
  Identity._oldVersionDetect = function(obj) {
    return [1, 0];
  };
});

// node_modules/sshpk/lib/formats/openssh-cert.js
var require_openssh_cert = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    verify,
    sign,
    signAsync,
    write,
    fromBuffer,
    toBuffer
  };
  var assert = require_assert();
  var SSHBuffer = require_ssh_buffer();
  var crypto = require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var rfc4253 = require_rfc4253();
  var Signature = require_signature();
  var utils = require_utils();
  var Certificate = require_certificate();
  function verify(cert, key) {
    return false;
  }
  var TYPES = {
    user: 1,
    host: 2
  };
  Object.keys(TYPES).forEach(function(k) {
    TYPES[TYPES[k]] = k;
  });
  var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
  function read(buf, options) {
    if (Buffer2.isBuffer(buf))
      buf = buf.toString("ascii");
    var parts = buf.trim().split(/[ \t\n]+/g);
    if (parts.length < 2 || parts.length > 3)
      throw new Error("Not a valid SSH certificate line");
    var algo = parts[0];
    var data = parts[1];
    data = Buffer2.from(data, "base64");
    return fromBuffer(data, algo);
  }
  function fromBuffer(data, algo, partial) {
    var sshbuf = new SSHBuffer({buffer: data});
    var innerAlgo = sshbuf.readString();
    if (algo !== void 0 && innerAlgo !== algo)
      throw new Error("SSH certificate algorithm mismatch");
    if (algo === void 0)
      algo = innerAlgo;
    var cert = {};
    cert.signatures = {};
    cert.signatures.openssh = {};
    cert.signatures.openssh.nonce = sshbuf.readBuffer();
    var key = {};
    var parts = key.parts = [];
    key.type = getAlg(algo);
    var partCount = algs.info[key.type].parts.length;
    while (parts.length < partCount)
      parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, "key must have at least one part");
    var algInfo = algs.info[key.type];
    if (key.type === "ecdsa") {
      var res = ECDSA_ALGO.exec(algo);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    for (var i = 0; i < algInfo.parts.length; ++i) {
      parts[i].name = algInfo.parts[i];
      if (parts[i].name !== "curve" && algInfo.normalize !== false) {
        var p = parts[i];
        p.data = utils.mpNormalize(p.data);
      }
    }
    cert.subjectKey = new Key(key);
    cert.serial = sshbuf.readInt64();
    var type = TYPES[sshbuf.readInt()];
    assert.string(type, "valid cert type");
    cert.signatures.openssh.keyId = sshbuf.readString();
    var principals = [];
    var pbuf = sshbuf.readBuffer();
    var psshbuf = new SSHBuffer({buffer: pbuf});
    while (!psshbuf.atEnd())
      principals.push(psshbuf.readString());
    if (principals.length === 0)
      principals = ["*"];
    cert.subjects = principals.map(function(pr) {
      if (type === "user")
        return Identity.forUser(pr);
      else if (type === "host")
        return Identity.forHost(pr);
      throw new Error("Unknown identity type " + type);
    });
    cert.validFrom = int64ToDate(sshbuf.readInt64());
    cert.validUntil = int64ToDate(sshbuf.readInt64());
    var exts = [];
    var extbuf = new SSHBuffer({buffer: sshbuf.readBuffer()});
    var ext;
    while (!extbuf.atEnd()) {
      ext = {critical: true};
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    extbuf = new SSHBuffer({buffer: sshbuf.readBuffer()});
    while (!extbuf.atEnd()) {
      ext = {critical: false};
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    cert.signatures.openssh.exts = exts;
    sshbuf.readBuffer();
    var signingKeyBuf = sshbuf.readBuffer();
    cert.issuerKey = rfc4253.read(signingKeyBuf);
    cert.issuer = Identity.forHost("**");
    var sigBuf = sshbuf.readBuffer();
    cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh");
    if (partial !== void 0) {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Certificate(cert);
  }
  function int64ToDate(buf) {
    var i = buf.readUInt32BE(0) * 4294967296;
    i += buf.readUInt32BE(4);
    var d = new Date();
    d.setTime(i * 1e3);
    d.sourceInt64 = buf;
    return d;
  }
  function dateToInt64(date) {
    if (date.sourceInt64 !== void 0)
      return date.sourceInt64;
    var i = Math.round(date.getTime() / 1e3);
    var upper = Math.floor(i / 4294967296);
    var lower = Math.floor(i % 4294967296);
    var buf = Buffer2.alloc(8);
    buf.writeUInt32BE(upper, 0);
    buf.writeUInt32BE(lower, 4);
    return buf;
  }
  function sign(cert, key) {
    if (cert.signatures.openssh === void 0)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      return false;
    }
    var sig = cert.signatures.openssh;
    var hashAlgo = void 0;
    if (key.type === "rsa" || key.type === "dsa")
      hashAlgo = "sha1";
    var signer = key.createSign(hashAlgo);
    signer.write(blob);
    sig.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.openssh === void 0)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      done(e);
      return;
    }
    var sig = cert.signatures.openssh;
    signer(blob, function(err, signature) {
      if (err) {
        done(err);
        return;
      }
      try {
        signature.toBuffer("ssh");
      } catch (e) {
        done(e);
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    if (options === void 0)
      options = {};
    var blob = toBuffer(cert);
    var out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
    if (options.comment)
      out = out + " " + options.comment;
    return out;
  }
  function toBuffer(cert, noSig) {
    assert.object(cert.signatures.openssh, "signature for openssh format");
    var sig = cert.signatures.openssh;
    if (sig.nonce === void 0)
      sig.nonce = crypto.randomBytes(16);
    var buf = new SSHBuffer({});
    buf.writeString(getCertType(cert.subjectKey));
    buf.writeBuffer(sig.nonce);
    var key = cert.subjectKey;
    var algInfo = algs.info[key.type];
    algInfo.parts.forEach(function(part) {
      buf.writePart(key.part[part]);
    });
    buf.writeInt64(cert.serial);
    var type = cert.subjects[0].type;
    assert.notStrictEqual(type, "unknown");
    cert.subjects.forEach(function(id) {
      assert.strictEqual(id.type, type);
    });
    type = TYPES[type];
    buf.writeInt(type);
    if (sig.keyId === void 0) {
      sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname);
    }
    buf.writeString(sig.keyId);
    var sub = new SSHBuffer({});
    cert.subjects.forEach(function(id) {
      if (type === TYPES.host)
        sub.writeString(id.hostname);
      else if (type === TYPES.user)
        sub.writeString(id.uid);
    });
    buf.writeBuffer(sub.toBuffer());
    buf.writeInt64(dateToInt64(cert.validFrom));
    buf.writeInt64(dateToInt64(cert.validUntil));
    var exts = sig.exts;
    if (exts === void 0)
      exts = [];
    var extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical !== true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical === true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    buf.writeBuffer(Buffer2.alloc(0));
    sub = rfc4253.write(cert.issuerKey);
    buf.writeBuffer(sub);
    if (!noSig)
      buf.writeBuffer(sig.signature.toBuffer("ssh"));
    return buf.toBuffer();
  }
  function getAlg(certType) {
    if (certType === "ssh-rsa-cert-v01@openssh.com")
      return "rsa";
    if (certType === "ssh-dss-cert-v01@openssh.com")
      return "dsa";
    if (certType.match(ECDSA_ALGO))
      return "ecdsa";
    if (certType === "ssh-ed25519-cert-v01@openssh.com")
      return "ed25519";
    throw new Error("Unsupported cert type " + certType);
  }
  function getCertType(key) {
    if (key.type === "rsa")
      return "ssh-rsa-cert-v01@openssh.com";
    if (key.type === "dsa")
      return "ssh-dss-cert-v01@openssh.com";
    if (key.type === "ecdsa")
      return "ecdsa-sha2-" + key.curve + "-cert-v01@openssh.com";
    if (key.type === "ed25519")
      return "ssh-ed25519-cert-v01@openssh.com";
    throw new Error("Unsupported key type " + key.type);
  }
});

// node_modules/sshpk/lib/formats/x509.js
var require_x509 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    verify,
    sign,
    signAsync,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  var pkcs8 = require_pkcs8();
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function verify(cert, key) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var algParts = sig.algo.split("-");
    if (algParts[0] !== key.type)
      return false;
    var blob = sig.cache;
    if (blob === void 0) {
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      blob = der.buffer;
    }
    var verifier = key.createVerify(algParts[1]);
    verifier.write(blob);
    return verifier.verify(sig.signature);
  }
  function Local(i) {
    return asn1.Ber.Context | asn1.Ber.Constructor | i;
  }
  function Context(i) {
    return asn1.Ber.Context | i;
  }
  var SIGN_ALGS = {
    "rsa-md5": "1.2.840.113549.1.1.4",
    "rsa-sha1": "1.2.840.113549.1.1.5",
    "rsa-sha256": "1.2.840.113549.1.1.11",
    "rsa-sha384": "1.2.840.113549.1.1.12",
    "rsa-sha512": "1.2.840.113549.1.1.13",
    "dsa-sha1": "1.2.840.10040.4.3",
    "dsa-sha256": "2.16.840.1.101.3.4.3.2",
    "ecdsa-sha1": "1.2.840.10045.4.1",
    "ecdsa-sha256": "1.2.840.10045.4.3.2",
    "ecdsa-sha384": "1.2.840.10045.4.3.3",
    "ecdsa-sha512": "1.2.840.10045.4.3.4",
    "ed25519-sha512": "1.3.101.112"
  };
  Object.keys(SIGN_ALGS).forEach(function(k) {
    SIGN_ALGS[SIGN_ALGS[k]] = k;
  });
  SIGN_ALGS["1.3.14.3.2.3"] = "rsa-md5";
  SIGN_ALGS["1.3.14.3.2.29"] = "rsa-sha1";
  var EXTS = {
    issuerKeyId: "2.5.29.35",
    altName: "2.5.29.17",
    basicConstraints: "2.5.29.19",
    keyUsage: "2.5.29.15",
    extKeyUsage: "2.5.29.37"
  };
  function read(buf, options) {
    if (typeof buf === "string") {
      buf = Buffer2.from(buf, "binary");
    }
    assert.buffer(buf, "buf");
    var der = new asn1.BerReader(buf);
    der.readSequence();
    if (Math.abs(der.length - der.remain) > 1) {
      throw new Error("DER sequence does not contain whole byte stream");
    }
    var tbsStart = der.offset;
    der.readSequence();
    var sigOffset = der.offset + der.length;
    var tbsEnd = sigOffset;
    if (der.peek() === Local(0)) {
      der.readSequence(Local(0));
      var version = der.readInt();
      assert.ok(version <= 3, "only x.509 versions up to v3 supported");
    }
    var cert = {};
    cert.signatures = {};
    var sig = cert.signatures.x509 = {};
    sig.extras = {};
    cert.serial = readMPInt(der, "serial");
    der.readSequence();
    var after = der.offset + der.length;
    var certAlgOid = der.readOID();
    var certAlg = SIGN_ALGS[certAlgOid];
    if (certAlg === void 0)
      throw new Error("unknown signature algorithm " + certAlgOid);
    der._offset = after;
    cert.issuer = Identity.parseAsn1(der);
    der.readSequence();
    cert.validFrom = readDate(der);
    cert.validUntil = readDate(der);
    cert.subjects = [Identity.parseAsn1(der)];
    der.readSequence();
    after = der.offset + der.length;
    cert.subjectKey = pkcs8.readPkcs8(void 0, "public", der);
    der._offset = after;
    if (der.peek() === Local(1)) {
      der.readSequence(Local(1));
      sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(2)) {
      der.readSequence(Local(2));
      sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(3)) {
      der.readSequence(Local(3));
      var extEnd = der.offset + der.length;
      der.readSequence();
      while (der.offset < extEnd)
        readExtension(cert, buf, der);
      assert.strictEqual(der.offset, extEnd);
    }
    assert.strictEqual(der.offset, sigOffset);
    der.readSequence();
    after = der.offset + der.length;
    var sigAlgOid = der.readOID();
    var sigAlg = SIGN_ALGS[sigAlgOid];
    if (sigAlg === void 0)
      throw new Error("unknown signature algorithm " + sigAlgOid);
    der._offset = after;
    var sigData = der.readString(asn1.Ber.BitString, true);
    if (sigData[0] === 0)
      sigData = sigData.slice(1);
    var algParts = sigAlg.split("-");
    sig.signature = Signature.parse(sigData, algParts[0], "asn1");
    sig.signature.hashAlgorithm = algParts[1];
    sig.algo = sigAlg;
    sig.cache = buf.slice(tbsStart, tbsEnd);
    return new Certificate(cert);
  }
  function readDate(der) {
    if (der.peek() === asn1.Ber.UTCTime) {
      return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
    } else if (der.peek() === asn1.Ber.GeneralizedTime) {
      return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
    } else {
      throw new Error("Unsupported date format");
    }
  }
  function writeDate(der, date) {
    if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
      der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
    } else {
      der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
    }
  }
  var ALTNAME = {
    OtherName: Local(0),
    RFC822Name: Context(1),
    DNSName: Context(2),
    X400Address: Local(3),
    DirectoryName: Local(4),
    EDIPartyName: Local(5),
    URI: Context(6),
    IPAddress: Context(7),
    OID: Context(8)
  };
  var EXTPURPOSE = {
    serverAuth: "1.3.6.1.5.5.7.3.1",
    clientAuth: "1.3.6.1.5.5.7.3.2",
    codeSigning: "1.3.6.1.5.5.7.3.3",
    joyentDocker: "1.3.6.1.4.1.38678.1.4.1",
    joyentCmon: "1.3.6.1.4.1.38678.1.4.2"
  };
  var EXTPURPOSE_REV = {};
  Object.keys(EXTPURPOSE).forEach(function(k) {
    EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
  });
  var KEYUSEBITS = [
    "signature",
    "identity",
    "keyEncryption",
    "encryption",
    "keyAgreement",
    "ca",
    "crl"
  ];
  function readExtension(cert, buf, der) {
    der.readSequence();
    var after = der.offset + der.length;
    var extId = der.readOID();
    var id;
    var sig = cert.signatures.x509;
    if (!sig.extras.exts)
      sig.extras.exts = [];
    var critical;
    if (der.peek() === asn1.Ber.Boolean)
      critical = der.readBoolean();
    switch (extId) {
      case EXTS.basicConstraints:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var bcEnd = der.offset + der.length;
        var ca = false;
        if (der.peek() === asn1.Ber.Boolean)
          ca = der.readBoolean();
        if (cert.purposes === void 0)
          cert.purposes = [];
        if (ca === true)
          cert.purposes.push("ca");
        var bc = {oid: extId, critical};
        if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
          bc.pathLen = der.readInt();
        sig.extras.exts.push(bc);
        break;
      case EXTS.extKeyUsage:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        if (cert.purposes === void 0)
          cert.purposes = [];
        var ekEnd = der.offset + der.length;
        while (der.offset < ekEnd) {
          var oid = der.readOID();
          cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
        }
        if (cert.purposes.indexOf("serverAuth") !== -1 && cert.purposes.indexOf("clientAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "host") {
              ide.type = "host";
              ide.hostname = ide.uid || ide.email || ide.components[0].value;
            }
          });
        } else if (cert.purposes.indexOf("clientAuth") !== -1 && cert.purposes.indexOf("serverAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "user") {
              ide.type = "user";
              ide.uid = ide.hostname || ide.email || ide.components[0].value;
            }
          });
        }
        sig.extras.exts.push({oid: extId, critical});
        break;
      case EXTS.keyUsage:
        der.readSequence(asn1.Ber.OctetString);
        var bits = der.readString(asn1.Ber.BitString, true);
        var setBits = readBitField(bits, KEYUSEBITS);
        setBits.forEach(function(bit) {
          if (cert.purposes === void 0)
            cert.purposes = [];
          if (cert.purposes.indexOf(bit) === -1)
            cert.purposes.push(bit);
        });
        sig.extras.exts.push({
          oid: extId,
          critical,
          bits
        });
        break;
      case EXTS.altName:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var aeEnd = der.offset + der.length;
        while (der.offset < aeEnd) {
          switch (der.peek()) {
            case ALTNAME.OtherName:
            case ALTNAME.EDIPartyName:
              der.readSequence();
              der._offset += der.length;
              break;
            case ALTNAME.OID:
              der.readOID(ALTNAME.OID);
              break;
            case ALTNAME.RFC822Name:
              var email = der.readString(ALTNAME.RFC822Name);
              id = Identity.forEmail(email);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DirectoryName:
              der.readSequence(ALTNAME.DirectoryName);
              id = Identity.parseAsn1(der);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DNSName:
              var host = der.readString(ALTNAME.DNSName);
              id = Identity.forHost(host);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            default:
              der.readString(der.peek());
              break;
          }
        }
        sig.extras.exts.push({oid: extId, critical});
        break;
      default:
        sig.extras.exts.push({
          oid: extId,
          critical,
          data: der.readString(asn1.Ber.OctetString, true)
        });
        break;
    }
    der._offset = after;
  }
  var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function utcTimeToDate(t) {
    var m = t.match(UTCTIME_RE);
    assert.ok(m, "timestamps must be in UTC");
    var d = new Date();
    var thisYear = d.getUTCFullYear();
    var century = Math.floor(thisYear / 100) * 100;
    var year = parseInt(m[1], 10);
    if (thisYear % 100 < 50 && year >= 60)
      year += century - 1;
    else
      year += century;
    d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function gTimeToDate(t) {
    var m = t.match(GTIME_RE);
    assert.ok(m);
    var d = new Date();
    d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  function zeroPad(n, m) {
    if (m === void 0)
      m = 2;
    var s = "" + n;
    while (s.length < m)
      s = "0" + s;
    return s;
  }
  function dateToUTCTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear() % 100);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function dateToGTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear(), 4);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function sign(cert, key) {
    if (cert.signatures.x509 === void 0)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    sig.algo = key.type + "-" + key.defaultHashAlgorithm();
    if (SIGN_ALGS[sig.algo] === void 0)
      return false;
    var der = new asn1.BerWriter();
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    var signer = key.createSign();
    signer.write(blob);
    cert.signatures.x509.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.x509 === void 0)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    var der = new asn1.BerWriter();
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    signer(blob, function(err, signature) {
      if (err) {
        done(err);
        return;
      }
      sig.algo = signature.type + "-" + signature.hashAlgorithm;
      if (SIGN_ALGS[sig.algo] === void 0) {
        done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var der = new asn1.BerWriter();
    der.startSequence();
    if (sig.cache) {
      der._ensure(sig.cache.length);
      sig.cache.copy(der._buf, der._offset);
      der._offset += sig.cache.length;
    } else {
      writeTBSCert(cert, der);
    }
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    var sigData = sig.signature.toBuffer("asn1");
    var data = Buffer2.alloc(sigData.length + 1);
    data[0] = 0;
    sigData.copy(data, 1);
    der.writeBuffer(data, asn1.Ber.BitString);
    der.endSequence();
    return der.buffer;
  }
  function writeTBSCert(cert, der) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    der.startSequence();
    der.startSequence(Local(0));
    der.writeInt(2);
    der.endSequence();
    der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    cert.issuer.toAsn1(der);
    der.startSequence();
    writeDate(der, cert.validFrom);
    writeDate(der, cert.validUntil);
    der.endSequence();
    var subject = cert.subjects[0];
    var altNames = cert.subjects.slice(1);
    subject.toAsn1(der);
    pkcs8.writePkcs8(der, cert.subjectKey);
    if (sig.extras && sig.extras.issuerUniqueID) {
      der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
    }
    if (sig.extras && sig.extras.subjectUniqueID) {
      der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
    }
    if (altNames.length > 0 || subject.type === "host" || cert.purposes !== void 0 && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {
      der.startSequence(Local(3));
      der.startSequence();
      var exts = [];
      if (cert.purposes !== void 0 && cert.purposes.length > 0) {
        exts.push({
          oid: EXTS.basicConstraints,
          critical: true
        });
        exts.push({
          oid: EXTS.keyUsage,
          critical: true
        });
        exts.push({
          oid: EXTS.extKeyUsage,
          critical: true
        });
      }
      exts.push({oid: EXTS.altName});
      if (sig.extras && sig.extras.exts)
        exts = sig.extras.exts;
      for (var i = 0; i < exts.length; ++i) {
        der.startSequence();
        der.writeOID(exts[i].oid);
        if (exts[i].critical !== void 0)
          der.writeBoolean(exts[i].critical);
        if (exts[i].oid === EXTS.altName) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          if (subject.type === "host") {
            der.writeString(subject.hostname, Context(2));
          }
          for (var j = 0; j < altNames.length; ++j) {
            if (altNames[j].type === "host") {
              der.writeString(altNames[j].hostname, ALTNAME.DNSName);
            } else if (altNames[j].type === "email") {
              der.writeString(altNames[j].email, ALTNAME.RFC822Name);
            } else {
              der.startSequence(ALTNAME.DirectoryName);
              altNames[j].toAsn1(der);
              der.endSequence();
            }
          }
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.basicConstraints) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          var ca = cert.purposes.indexOf("ca") !== -1;
          var pathLen = exts[i].pathLen;
          der.writeBoolean(ca);
          if (pathLen !== void 0)
            der.writeInt(pathLen);
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.extKeyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          cert.purposes.forEach(function(purpose) {
            if (purpose === "ca")
              return;
            if (KEYUSEBITS.indexOf(purpose) !== -1)
              return;
            var oid = purpose;
            if (EXTPURPOSE[purpose] !== void 0)
              oid = EXTPURPOSE[purpose];
            der.writeOID(oid);
          });
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.keyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          if (exts[i].bits !== void 0) {
            der.writeBuffer(exts[i].bits, asn1.Ber.BitString);
          } else {
            var bits = writeBitField(cert.purposes, KEYUSEBITS);
            der.writeBuffer(bits, asn1.Ber.BitString);
          }
          der.endSequence();
        } else {
          der.writeBuffer(exts[i].data, asn1.Ber.OctetString);
        }
        der.endSequence();
      }
      der.endSequence();
      der.endSequence();
    }
    der.endSequence();
  }
  function readBitField(bits, bitIndex) {
    var bitLen = 8 * (bits.length - 1) - bits[0];
    var setBits = {};
    for (var i = 0; i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var bitVal = (bits[byteN] & mask) !== 0;
      var name = bitIndex[i];
      if (bitVal && typeof name === "string") {
        setBits[name] = true;
      }
    }
    return Object.keys(setBits);
  }
  function writeBitField(setBits, bitIndex) {
    var bitLen = bitIndex.length;
    var blen = Math.ceil(bitLen / 8);
    var unused = blen * 8 - bitLen;
    var bits = Buffer2.alloc(1 + blen);
    bits[0] = unused;
    for (var i = 0; i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var name = bitIndex[i];
      if (name === void 0)
        continue;
      var bitVal = setBits.indexOf(name) !== -1;
      if (bitVal) {
        bits[byteN] |= mask;
      }
    }
    return bits;
  }
});

// node_modules/sshpk/lib/formats/x509-pem.js
var require_x509_pem = __commonJS((exports2, module2) => {
  var x509 = require_x509();
  module2.exports = {
    read,
    verify: x509.verify,
    sign: x509.sign,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m2, "invalid PEM footer");
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    return x509.read(buf, options);
  }
  function write(cert, options) {
    var dbuf = x509.write(cert, options);
    var header = "CERTIFICATE";
    var tmp = dbuf.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + "-----\n", o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + "-----\n", o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/certificate.js
var require_certificate = __commonJS((exports2, module2) => {
  module2.exports = Certificate;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = require("util");
  var utils = require_utils();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var formats = {};
  formats["openssh"] = require_openssh_cert();
  formats["x509"] = require_x509();
  formats["pem"] = require_x509_pem();
  var CertificateParseError = errs.CertificateParseError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Certificate(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.subjects, "options.subjects");
    utils.assertCompatible(opts.subjects[0], Identity, [1, 0], "options.subjects");
    utils.assertCompatible(opts.subjectKey, Key, [1, 0], "options.subjectKey");
    utils.assertCompatible(opts.issuer, Identity, [1, 0], "options.issuer");
    if (opts.issuerKey !== void 0) {
      utils.assertCompatible(opts.issuerKey, Key, [1, 0], "options.issuerKey");
    }
    assert.object(opts.signatures, "options.signatures");
    assert.buffer(opts.serial, "options.serial");
    assert.date(opts.validFrom, "options.validFrom");
    assert.date(opts.validUntil, "optons.validUntil");
    assert.optionalArrayOfString(opts.purposes, "options.purposes");
    this._hashCache = {};
    this.subjects = opts.subjects;
    this.issuer = opts.issuer;
    this.subjectKey = opts.subjectKey;
    this.issuerKey = opts.issuerKey;
    this.signatures = opts.signatures;
    this.serial = opts.serial;
    this.validFrom = opts.validFrom;
    this.validUntil = opts.validUntil;
    this.purposes = opts.purposes;
  }
  Certificate.formats = formats;
  Certificate.prototype.toBuffer = function(format, options) {
    if (format === void 0)
      format = "x509";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    return formats[format].write(this, options);
  };
  Certificate.prototype.toString = function(format, options) {
    if (format === void 0)
      format = "pem";
    return this.toBuffer(format, options).toString();
  };
  Certificate.prototype.fingerprint = function(algo) {
    if (algo === void 0)
      algo = "sha256";
    assert.string(algo, "algorithm");
    var opts = {
      type: "certificate",
      hash: this.hash(algo),
      algorithm: algo
    };
    return new Fingerprint(opts);
  };
  Certificate.prototype.hash = function(algo) {
    assert.string(algo, "algorithm");
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === void 0)
      throw new InvalidAlgorithmError(algo);
    if (this._hashCache[algo])
      return this._hashCache[algo];
    var hash = crypto.createHash(algo).update(this.toBuffer("x509")).digest();
    this._hashCache[algo] = hash;
    return hash;
  };
  Certificate.prototype.isExpired = function(when) {
    if (when === void 0)
      when = new Date();
    return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
  };
  Certificate.prototype.isSignedBy = function(issuerCert) {
    utils.assertCompatible(issuerCert, Certificate, [1, 0], "issuer");
    if (!this.issuer.equals(issuerCert.subjects[0]))
      return false;
    if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf("ca") === -1) {
      return false;
    }
    return this.isSignedByKey(issuerCert.subjectKey);
  };
  Certificate.prototype.getExtension = function(keyOrOid) {
    assert.string(keyOrOid, "keyOrOid");
    var ext = this.getExtensions().filter(function(maybeExt) {
      if (maybeExt.format === "x509")
        return maybeExt.oid === keyOrOid;
      if (maybeExt.format === "openssh")
        return maybeExt.name === keyOrOid;
      return false;
    })[0];
    return ext;
  };
  Certificate.prototype.getExtensions = function() {
    var exts = [];
    var x509 = this.signatures.x509;
    if (x509 && x509.extras && x509.extras.exts) {
      x509.extras.exts.forEach(function(ext) {
        ext.format = "x509";
        exts.push(ext);
      });
    }
    var openssh = this.signatures.openssh;
    if (openssh && openssh.exts) {
      openssh.exts.forEach(function(ext) {
        ext.format = "openssh";
        exts.push(ext);
      });
    }
    return exts;
  };
  Certificate.prototype.isSignedByKey = function(issuerKey) {
    utils.assertCompatible(issuerKey, Key, [1, 2], "issuerKey");
    if (this.issuerKey !== void 0) {
      return this.issuerKey.fingerprint("sha512").matches(issuerKey);
    }
    var fmt = Object.keys(this.signatures)[0];
    var valid = formats[fmt].verify(this, issuerKey);
    if (valid)
      this.issuerKey = issuerKey;
    return valid;
  };
  Certificate.prototype.signWith = function(key) {
    utils.assertCompatible(key, PrivateKey, [1, 2], "key");
    var fmts = Object.keys(formats);
    var didOne = false;
    for (var i = 0; i < fmts.length; ++i) {
      if (fmts[i] !== "pem") {
        var ret = formats[fmts[i]].sign(this, key);
        if (ret === true)
          didOne = true;
      }
    }
    if (!didOne) {
      throw new Error("Failed to sign the certificate for any available certificate formats");
    }
  };
  Certificate.createSelfSigned = function(subjectOrSubjects, key, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils.assertCompatible(key, PrivateKey, [1, 2], "private key");
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === void 0)
      validFrom = new Date();
    if (validUntil === void 0) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === void 0)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date();
      validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === void 0)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === void 0)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (purposes.indexOf("ca") === -1)
      purposes.push("ca");
    if (purposes.indexOf("crl") === -1)
      purposes.push("crl");
    if (purposes.length <= 3) {
      var hostSubjects = subjects.filter(function(subject) {
        return subject.type === "host";
      });
      var userSubjects = subjects.filter(function(subject) {
        return subject.type === "user";
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf("serverAuth") === -1)
          purposes.push("serverAuth");
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf("clientAuth") === -1)
          purposes.push("clientAuth");
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf("keyAgreement") === -1)
          purposes.push("keyAgreement");
        if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
          purposes.push("encryption");
      }
    }
    var cert = new Certificate({
      subjects,
      issuer: subjects[0],
      subjectKey: key.toPublic(),
      issuerKey: key.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(key);
    return cert;
  };
  Certificate.create = function(subjectOrSubjects, key, issuer, issuerKey, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils.assertCompatible(key, Key, [1, 0], "key");
    if (PrivateKey.isPrivateKey(key))
      key = key.toPublic();
    utils.assertCompatible(issuer, Identity, [1, 0], "issuer");
    utils.assertCompatible(issuerKey, PrivateKey, [1, 2], "issuer key");
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === void 0)
      validFrom = new Date();
    if (validUntil === void 0) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === void 0)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date();
      validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === void 0)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === void 0)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (options.ca === true) {
      if (purposes.indexOf("ca") === -1)
        purposes.push("ca");
      if (purposes.indexOf("crl") === -1)
        purposes.push("crl");
    }
    var hostSubjects = subjects.filter(function(subject) {
      return subject.type === "host";
    });
    var userSubjects = subjects.filter(function(subject) {
      return subject.type === "user";
    });
    if (hostSubjects.length > 0) {
      if (purposes.indexOf("serverAuth") === -1)
        purposes.push("serverAuth");
    }
    if (userSubjects.length > 0) {
      if (purposes.indexOf("clientAuth") === -1)
        purposes.push("clientAuth");
    }
    if (userSubjects.length > 0 || hostSubjects.length > 0) {
      if (purposes.indexOf("keyAgreement") === -1)
        purposes.push("keyAgreement");
      if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
        purposes.push("encryption");
    }
    var cert = new Certificate({
      subjects,
      issuer,
      subjectKey: key,
      issuerKey: issuerKey.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(issuerKey);
    return cert;
  };
  Certificate.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === void 0)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = {filename: options};
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === void 0)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      return k;
    } catch (e) {
      throw new CertificateParseError(options.filename, format, e);
    }
  };
  Certificate.isCertificate = function(obj, ver) {
    return utils.isCompatible(obj, Certificate, ver);
  };
  Certificate.prototype._sshpkApiVersion = [1, 1];
  Certificate._oldVersionDetect = function(obj) {
    return [1, 0];
  };
});

// node_modules/sshpk/lib/fingerprint.js
var require_fingerprint = __commonJS((exports2, module2) => {
  module2.exports = Fingerprint;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require("crypto");
  var errs = require_errors();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var utils = require_utils();
  var FingerprintFormatError = errs.FingerprintFormatError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Fingerprint(opts) {
    assert.object(opts, "options");
    assert.string(opts.type, "options.type");
    assert.buffer(opts.hash, "options.hash");
    assert.string(opts.algorithm, "options.algorithm");
    this.algorithm = opts.algorithm.toLowerCase();
    if (algs.hashAlgs[this.algorithm] !== true)
      throw new InvalidAlgorithmError(this.algorithm);
    this.hash = opts.hash;
    this.type = opts.type;
    this.hashType = opts.hashType;
  }
  Fingerprint.prototype.toString = function(format) {
    if (format === void 0) {
      if (this.algorithm === "md5" || this.hashType === "spki")
        format = "hex";
      else
        format = "base64";
    }
    assert.string(format);
    switch (format) {
      case "hex":
        if (this.hashType === "spki")
          return this.hash.toString("hex");
        return addColons(this.hash.toString("hex"));
      case "base64":
        if (this.hashType === "spki")
          return this.hash.toString("base64");
        return sshBase64Format(this.algorithm, this.hash.toString("base64"));
      default:
        throw new FingerprintFormatError(void 0, format);
    }
  };
  Fingerprint.prototype.matches = function(other) {
    assert.object(other, "key or certificate");
    if (this.type === "key" && this.hashType !== "ssh") {
      utils.assertCompatible(other, Key, [1, 7], "key with spki");
      if (PrivateKey.isPrivateKey(other)) {
        utils.assertCompatible(other, PrivateKey, [1, 6], "privatekey with spki support");
      }
    } else if (this.type === "key") {
      utils.assertCompatible(other, Key, [1, 0], "key");
    } else {
      utils.assertCompatible(other, Certificate, [1, 0], "certificate");
    }
    var theirHash = other.hash(this.algorithm, this.hashType);
    var theirHash2 = crypto.createHash(this.algorithm).update(theirHash).digest("base64");
    if (this.hash2 === void 0)
      this.hash2 = crypto.createHash(this.algorithm).update(this.hash).digest("base64");
    return this.hash2 === theirHash2;
  };
  var base64RE = /^[A-Za-z0-9+\/=]+$/;
  var hexRE = /^[a-fA-F0-9]+$/;
  Fingerprint.parse = function(fp, options) {
    assert.string(fp, "fingerprint");
    var alg, hash, enAlgs;
    if (Array.isArray(options)) {
      enAlgs = options;
      options = {};
    }
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    if (options.enAlgs !== void 0)
      enAlgs = options.enAlgs;
    if (options.algorithms !== void 0)
      enAlgs = options.algorithms;
    assert.optionalArrayOfString(enAlgs, "algorithms");
    var hashType = "ssh";
    if (options.hashType !== void 0)
      hashType = options.hashType;
    assert.string(hashType, "options.hashType");
    var parts = fp.split(":");
    if (parts.length == 2) {
      alg = parts[0].toLowerCase();
      if (!base64RE.test(parts[1]))
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts[1], "base64");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else if (parts.length > 2) {
      alg = "md5";
      if (parts[0].toLowerCase() === "md5")
        parts = parts.slice(1);
      parts = parts.map(function(p) {
        while (p.length < 2)
          p = "0" + p;
        if (p.length > 2)
          throw new FingerprintFormatError(fp);
        return p;
      });
      parts = parts.join("");
      if (!hexRE.test(parts) || parts.length % 2 !== 0)
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts, "hex");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else {
      if (hexRE.test(fp)) {
        hash = Buffer2.from(fp, "hex");
      } else if (base64RE.test(fp)) {
        hash = Buffer2.from(fp, "base64");
      } else {
        throw new FingerprintFormatError(fp);
      }
      switch (hash.length) {
        case 32:
          alg = "sha256";
          break;
        case 16:
          alg = "md5";
          break;
        case 20:
          alg = "sha1";
          break;
        case 64:
          alg = "sha512";
          break;
        default:
          throw new FingerprintFormatError(fp);
      }
      if (options.hashType === void 0)
        hashType = "spki";
    }
    if (alg === void 0)
      throw new FingerprintFormatError(fp);
    if (algs.hashAlgs[alg] === void 0)
      throw new InvalidAlgorithmError(alg);
    if (enAlgs !== void 0) {
      enAlgs = enAlgs.map(function(a) {
        return a.toLowerCase();
      });
      if (enAlgs.indexOf(alg) === -1)
        throw new InvalidAlgorithmError(alg);
    }
    return new Fingerprint({
      algorithm: alg,
      hash,
      type: options.type || "key",
      hashType
    });
  };
  function addColons(s) {
    return s.replace(/(.{2})(?=.)/g, "$1:");
  }
  function base64Strip(s) {
    return s.replace(/=*$/, "");
  }
  function sshBase64Format(alg, h) {
    return alg.toUpperCase() + ":" + base64Strip(h);
  }
  Fingerprint.isFingerprint = function(obj, ver) {
    return utils.isCompatible(obj, Fingerprint, ver);
  };
  Fingerprint.prototype._sshpkApiVersion = [1, 2];
  Fingerprint._oldVersionDetect = function(obj) {
    assert.func(obj.toString);
    assert.func(obj.matches);
    return [1, 0];
  };
});

// node_modules/sshpk/lib/key.js
var require_key = __commonJS((exports2, module2) => {
  module2.exports = Key;
  var assert = require_assert();
  var algs = require_algs();
  var crypto = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var DiffieHellman = require_dhe().DiffieHellman;
  var errs = require_errors();
  var utils = require_utils();
  var PrivateKey = require_private_key();
  var edCompat;
  try {
    edCompat = require_ed_compat();
  } catch (e) {
  }
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var formats = {};
  formats["auto"] = require_auto();
  formats["pem"] = require_pem();
  formats["pkcs1"] = require_pkcs1();
  formats["pkcs8"] = require_pkcs8();
  formats["rfc4253"] = require_rfc4253();
  formats["ssh"] = require_ssh();
  formats["ssh-private"] = require_ssh_private();
  formats["openssh"] = formats["ssh-private"];
  formats["dnssec"] = require_dnssec();
  formats["putty"] = require_putty();
  formats["ppk"] = formats["putty"];
  function Key(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    assert.optionalString(opts.comment, "options.comment");
    var algInfo = algs.info[opts.type];
    if (typeof algInfo !== "object")
      throw new InvalidAlgorithmError(opts.type);
    var partLookup = {};
    for (var i = 0; i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.parts = opts.parts;
    this.part = partLookup;
    this.comment = void 0;
    this.source = opts.source;
    this._rfc4253Cache = opts._rfc4253Cache;
    this._hashCache = {};
    var sz;
    this.curve = void 0;
    if (this.type === "ecdsa") {
      var curve = this.part.curve.data.toString();
      this.curve = curve;
      sz = algs.curves[curve].size;
    } else if (this.type === "ed25519" || this.type === "curve25519") {
      sz = 256;
      this.curve = "curve25519";
    } else {
      var szPart = this.part[algInfo.sizePart];
      sz = szPart.data.length;
      sz = sz * 8 - utils.countZeros(szPart.data);
    }
    this.size = sz;
  }
  Key.formats = formats;
  Key.prototype.toBuffer = function(format, options) {
    if (format === void 0)
      format = "ssh";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    if (format === "rfc4253") {
      if (this._rfc4253Cache === void 0)
        this._rfc4253Cache = formats["rfc4253"].write(this);
      return this._rfc4253Cache;
    }
    return formats[format].write(this, options);
  };
  Key.prototype.toString = function(format, options) {
    return this.toBuffer(format, options).toString();
  };
  Key.prototype.hash = function(algo, type) {
    assert.string(algo, "algorithm");
    assert.optionalString(type, "type");
    if (type === void 0)
      type = "ssh";
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === void 0)
      throw new InvalidAlgorithmError(algo);
    var cacheKey = algo + "||" + type;
    if (this._hashCache[cacheKey])
      return this._hashCache[cacheKey];
    var buf;
    if (type === "ssh") {
      buf = this.toBuffer("rfc4253");
    } else if (type === "spki") {
      buf = formats.pkcs8.pkcs8ToBuffer(this);
    } else {
      throw new Error("Hash type " + type + " not supported");
    }
    var hash = crypto.createHash(algo).update(buf).digest();
    this._hashCache[cacheKey] = hash;
    return hash;
  };
  Key.prototype.fingerprint = function(algo, type) {
    if (algo === void 0)
      algo = "sha256";
    if (type === void 0)
      type = "ssh";
    assert.string(algo, "algorithm");
    assert.string(type, "type");
    var opts = {
      type: "key",
      hash: this.hash(algo, type),
      algorithm: algo,
      hashType: type
    };
    return new Fingerprint(opts);
  };
  Key.prototype.defaultHashAlgorithm = function() {
    var hashAlgo = "sha1";
    if (this.type === "rsa")
      hashAlgo = "sha256";
    if (this.type === "dsa" && this.size > 1024)
      hashAlgo = "sha256";
    if (this.type === "ed25519")
      hashAlgo = "sha512";
    if (this.type === "ecdsa") {
      if (this.size <= 256)
        hashAlgo = "sha256";
      else if (this.size <= 384)
        hashAlgo = "sha384";
      else
        hashAlgo = "sha512";
    }
    return hashAlgo;
  };
  Key.prototype.createVerify = function(hashAlgo) {
    if (hashAlgo === void 0)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat !== void 0)
      return new edCompat.Verifier(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    } catch (e) {
      err = e;
    }
    if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldVerify = v.verify.bind(v);
    var key = this.toBuffer("pkcs8");
    var curve = this.curve;
    var self2 = this;
    v.verify = function(signature, fmt) {
      if (Signature.isSignature(signature, [2, 0])) {
        if (signature.type !== self2.type)
          return false;
        if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo)
          return false;
        if (signature.curve && self2.type === "ecdsa" && signature.curve !== curve)
          return false;
        return oldVerify(key, signature.toBuffer("asn1"));
      } else if (typeof signature === "string" || Buffer.isBuffer(signature)) {
        return oldVerify(key, signature, fmt);
      } else if (Signature.isSignature(signature, [1, 0])) {
        throw new Error("signature was created by too old a version of sshpk and cannot be verified");
      } else {
        throw new TypeError("signature must be a string, Buffer, or Signature object");
      }
    };
    return v;
  };
  Key.prototype.createDiffieHellman = function() {
    if (this.type === "rsa")
      throw new Error("RSA keys do not support Diffie-Hellman");
    return new DiffieHellman(this);
  };
  Key.prototype.createDH = Key.prototype.createDiffieHellman;
  Key.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === void 0)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = {filename: options};
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === void 0)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      if (k instanceof PrivateKey)
        k = k.toPublic();
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  Key.isKey = function(obj, ver) {
    return utils.isCompatible(obj, Key, ver);
  };
  Key.prototype._sshpkApiVersion = [1, 7];
  Key._oldVersionDetect = function(obj) {
    assert.func(obj.toBuffer);
    assert.func(obj.fingerprint);
    if (obj.createDH)
      return [1, 4];
    if (obj.defaultHashAlgorithm)
      return [1, 3];
    if (obj.formats["auto"])
      return [1, 2];
    if (obj.formats["pkcs1"])
      return [1, 1];
    return [1, 0];
  };
});

// node_modules/sshpk/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  var Key = require_key();
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var Identity = require_identity();
  var errs = require_errors();
  module2.exports = {
    Key,
    parseKey: Key.parse,
    Fingerprint,
    parseFingerprint: Fingerprint.parse,
    Signature,
    parseSignature: Signature.parse,
    PrivateKey,
    parsePrivateKey: PrivateKey.parse,
    generatePrivateKey: PrivateKey.generate,
    Certificate,
    parseCertificate: Certificate.parse,
    createSelfSignedCertificate: Certificate.createSelfSigned,
    createCertificate: Certificate.create,
    Identity,
    identityFromDN: Identity.parseDN,
    identityForHost: Identity.forHost,
    identityForUser: Identity.forUser,
    identityForEmail: Identity.forEmail,
    identityFromArray: Identity.fromArray,
    FingerprintFormatError: errs.FingerprintFormatError,
    InvalidAlgorithmError: errs.InvalidAlgorithmError,
    KeyParseError: errs.KeyParseError,
    SignatureParseError: errs.SignatureParseError,
    KeyEncryptedError: errs.KeyEncryptedError,
    CertificateParseError: errs.CertificateParseError
  };
});

// node_modules/http-signature/lib/utils.js
var require_utils2 = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var sshpk = require_lib2();
  var util = require("util");
  var HASH_ALGOS = {
    sha1: true,
    sha256: true,
    sha512: true
  };
  var PK_ALGOS = {
    rsa: true,
    dsa: true,
    ecdsa: true
  };
  function HttpSignatureError(message, caller) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, caller || HttpSignatureError);
    this.message = message;
    this.name = caller.name;
  }
  util.inherits(HttpSignatureError, Error);
  function InvalidAlgorithmError(message) {
    HttpSignatureError.call(this, message, InvalidAlgorithmError);
  }
  util.inherits(InvalidAlgorithmError, HttpSignatureError);
  function validateAlgorithm(algorithm) {
    var alg = algorithm.toLowerCase().split("-");
    if (alg.length !== 2) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " is not a valid algorithm");
    }
    if (alg[0] !== "hmac" && !PK_ALGOS[alg[0]]) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " type keys are not supported");
    }
    if (!HASH_ALGOS[alg[1]]) {
      throw new InvalidAlgorithmError(alg[1].toUpperCase() + " is not a supported hash algorithm");
    }
    return alg;
  }
  module2.exports = {
    HASH_ALGOS,
    PK_ALGOS,
    HttpSignatureError,
    InvalidAlgorithmError,
    validateAlgorithm,
    sshKeyToPEM: function sshKeyToPEM(key) {
      assert.string(key, "ssh_key");
      var k = sshpk.parseKey(key, "ssh");
      return k.toString("pem");
    },
    fingerprint: function fingerprint(key) {
      assert.string(key, "ssh_key");
      var k = sshpk.parseKey(key, "ssh");
      return k.fingerprint("md5").toString("hex");
    },
    pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
      assert.equal("string", typeof pem, "typeof pem");
      var k = sshpk.parseKey(pem, "pem");
      k.comment = comment;
      return k.toString("ssh");
    }
  };
});

// node_modules/http-signature/lib/parser.js
var require_parser = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var util = require("util");
  var utils = require_utils2();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var HttpSignatureError = utils.HttpSignatureError;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var validateAlgorithm = utils.validateAlgorithm;
  var State = {
    New: 0,
    Params: 1
  };
  var ParamsState = {
    Name: 0,
    Quote: 1,
    Value: 2,
    Comma: 3
  };
  function ExpiredRequestError(message) {
    HttpSignatureError.call(this, message, ExpiredRequestError);
  }
  util.inherits(ExpiredRequestError, HttpSignatureError);
  function InvalidHeaderError(message) {
    HttpSignatureError.call(this, message, InvalidHeaderError);
  }
  util.inherits(InvalidHeaderError, HttpSignatureError);
  function InvalidParamsError(message) {
    HttpSignatureError.call(this, message, InvalidParamsError);
  }
  util.inherits(InvalidParamsError, HttpSignatureError);
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util.inherits(StrictParsingError, HttpSignatureError);
  module2.exports = {
    parseRequest: function parseRequest(request, options) {
      assert.object(request, "request");
      assert.object(request.headers, "request.headers");
      if (options === void 0) {
        options = {};
      }
      if (options.headers === void 0) {
        options.headers = [request.headers["x-date"] ? "x-date" : "date"];
      }
      assert.object(options, "options");
      assert.arrayOfString(options.headers, "options.headers");
      assert.optionalFinite(options.clockSkew, "options.clockSkew");
      var authzHeaderName = options.authorizationHeaderName || "authorization";
      if (!request.headers[authzHeaderName]) {
        throw new MissingHeaderError("no " + authzHeaderName + " header present in the request");
      }
      options.clockSkew = options.clockSkew || 300;
      var i = 0;
      var state = State.New;
      var substate = ParamsState.Name;
      var tmpName = "";
      var tmpValue = "";
      var parsed = {
        scheme: "",
        params: {},
        signingString: ""
      };
      var authz = request.headers[authzHeaderName];
      for (i = 0; i < authz.length; i++) {
        var c = authz.charAt(i);
        switch (Number(state)) {
          case State.New:
            if (c !== " ")
              parsed.scheme += c;
            else
              state = State.Params;
            break;
          case State.Params:
            switch (Number(substate)) {
              case ParamsState.Name:
                var code = c.charCodeAt(0);
                if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
                  tmpName += c;
                } else if (c === "=") {
                  if (tmpName.length === 0)
                    throw new InvalidHeaderError("bad param format");
                  substate = ParamsState.Quote;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              case ParamsState.Quote:
                if (c === '"') {
                  tmpValue = "";
                  substate = ParamsState.Value;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              case ParamsState.Value:
                if (c === '"') {
                  parsed.params[tmpName] = tmpValue;
                  substate = ParamsState.Comma;
                } else {
                  tmpValue += c;
                }
                break;
              case ParamsState.Comma:
                if (c === ",") {
                  tmpName = "";
                  substate = ParamsState.Name;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              default:
                throw new Error("Invalid substate");
            }
            break;
          default:
            throw new Error("Invalid substate");
        }
      }
      if (!parsed.params.headers || parsed.params.headers === "") {
        if (request.headers["x-date"]) {
          parsed.params.headers = ["x-date"];
        } else {
          parsed.params.headers = ["date"];
        }
      } else {
        parsed.params.headers = parsed.params.headers.split(" ");
      }
      if (!parsed.scheme || parsed.scheme !== "Signature")
        throw new InvalidHeaderError('scheme was not "Signature"');
      if (!parsed.params.keyId)
        throw new InvalidHeaderError("keyId was not specified");
      if (!parsed.params.algorithm)
        throw new InvalidHeaderError("algorithm was not specified");
      if (!parsed.params.signature)
        throw new InvalidHeaderError("signature was not specified");
      parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
      try {
        validateAlgorithm(parsed.params.algorithm);
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw new InvalidParamsError(parsed.params.algorithm + " is not supported");
        else
          throw e;
      }
      for (i = 0; i < parsed.params.headers.length; i++) {
        var h = parsed.params.headers[i].toLowerCase();
        parsed.params.headers[i] = h;
        if (h === "request-line") {
          if (!options.strict) {
            parsed.signingString += request.method + " " + request.url + " HTTP/" + request.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          parsed.signingString += "(request-target): " + request.method.toLowerCase() + " " + request.url;
        } else {
          var value = request.headers[h];
          if (value === void 0)
            throw new MissingHeaderError(h + " was not in the request");
          parsed.signingString += h + ": " + value;
        }
        if (i + 1 < parsed.params.headers.length)
          parsed.signingString += "\n";
      }
      var date;
      if (request.headers.date || request.headers["x-date"]) {
        if (request.headers["x-date"]) {
          date = new Date(request.headers["x-date"]);
        } else {
          date = new Date(request.headers.date);
        }
        var now = new Date();
        var skew = Math.abs(now.getTime() - date.getTime());
        if (skew > options.clockSkew * 1e3) {
          throw new ExpiredRequestError("clock skew of " + skew / 1e3 + "s was greater than " + options.clockSkew + "s");
        }
      }
      options.headers.forEach(function(hdr) {
        if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
          throw new MissingHeaderError(hdr + " was not a signed header");
      });
      if (options.algorithms) {
        if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
          throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
      }
      parsed.algorithm = parsed.params.algorithm.toUpperCase();
      parsed.keyId = parsed.params.keyId;
      return parsed;
    }
  };
});

// node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS((exports2) => {
  var mod_assert = require("assert");
  var mod_util = require("util");
  exports2.sprintf = jsSprintf;
  exports2.printf = jsPrintf;
  exports2.fprintf = jsFprintf;
  function jsSprintf(fmt) {
    var regex = [
      "([^%]*)",
      "%",
      "(['\\-+ #0]*?)",
      "([1-9]\\d*)?",
      "(\\.([1-9]\\d*))?",
      "[lhjztL]*?",
      "([diouxXfFeEgGaAcCsSp%jr])"
    ].join("");
    var re = new RegExp(regex);
    var args = Array.prototype.slice.call(arguments, 1);
    var flags, width, precision, conversion;
    var left, pad, sign, arg, match;
    var ret = "";
    var argn = 1;
    mod_assert.equal("string", typeof fmt);
    while ((match = re.exec(fmt)) !== null) {
      ret += match[1];
      fmt = fmt.substring(match[0].length);
      flags = match[2] || "";
      width = match[3] || 0;
      precision = match[4] || "";
      conversion = match[6];
      left = false;
      sign = false;
      pad = " ";
      if (conversion == "%") {
        ret += "%";
        continue;
      }
      if (args.length === 0)
        throw new Error("too few args to sprintf");
      arg = args.shift();
      argn++;
      if (flags.match(/[\' #]/))
        throw new Error("unsupported flags: " + flags);
      if (precision.length > 0)
        throw new Error("non-zero precision not supported");
      if (flags.match(/-/))
        left = true;
      if (flags.match(/0/))
        pad = "0";
      if (flags.match(/\+/))
        sign = true;
      switch (conversion) {
        case "s":
          if (arg === void 0 || arg === null)
            throw new Error("argument " + argn + ": attempted to print undefined or null as a string");
          ret += doPad(pad, width, left, arg.toString());
          break;
        case "d":
          arg = Math.floor(arg);
        case "f":
          sign = sign && arg > 0 ? "+" : "";
          ret += sign + doPad(pad, width, left, arg.toString());
          break;
        case "x":
          ret += doPad(pad, width, left, arg.toString(16));
          break;
        case "j":
          if (width === 0)
            width = 10;
          ret += mod_util.inspect(arg, false, width);
          break;
        case "r":
          ret += dumpException(arg);
          break;
        default:
          throw new Error("unsupported conversion: " + conversion);
      }
    }
    ret += fmt;
    return ret;
  }
  function jsPrintf() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(process.stdout);
    jsFprintf.apply(null, args);
  }
  function jsFprintf(stream) {
    var args = Array.prototype.slice.call(arguments, 1);
    return stream.write(jsSprintf.apply(this, args));
  }
  function doPad(chr, width, left, str) {
    var ret = str;
    while (ret.length < width) {
      if (left)
        ret += chr;
      else
        ret = chr + ret;
    }
    return ret;
  }
  function dumpException(ex) {
    var ret;
    if (!(ex instanceof Error))
      throw new Error(jsSprintf("invalid type for %%r: %j", ex));
    ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
    if (ex.cause && typeof ex.cause === "function") {
      var cex = ex.cause();
      if (cex) {
        ret += "\nCaused by: " + dumpException(cex);
      }
    }
    return ret;
  }
});

// node_modules/verror/node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf2 = __commonJS((exports2) => {
  var mod_assert = require("assert");
  var mod_util = require("util");
  exports2.sprintf = jsSprintf;
  exports2.printf = jsPrintf;
  exports2.fprintf = jsFprintf;
  function jsSprintf(ofmt) {
    var regex = [
      "([^%]*)",
      "%",
      "(['\\-+ #0]*?)",
      "([1-9]\\d*)?",
      "(\\.([1-9]\\d*))?",
      "[lhjztL]*?",
      "([diouxXfFeEgGaAcCsSp%jr])"
    ].join("");
    var re = new RegExp(regex);
    var args = Array.prototype.slice.call(arguments, 1);
    var fmt = ofmt;
    var flags, width, precision, conversion;
    var left, pad, sign, arg, match;
    var ret = "";
    var argn = 1;
    var posn = 0;
    var convposn;
    var curconv;
    mod_assert.equal("string", typeof fmt, "first argument must be a format string");
    while ((match = re.exec(fmt)) !== null) {
      ret += match[1];
      fmt = fmt.substring(match[0].length);
      curconv = match[0].substring(match[1].length);
      convposn = posn + match[1].length + 1;
      posn += match[0].length;
      flags = match[2] || "";
      width = match[3] || 0;
      precision = match[4] || "";
      conversion = match[6];
      left = false;
      sign = false;
      pad = " ";
      if (conversion == "%") {
        ret += "%";
        continue;
      }
      if (args.length === 0) {
        throw jsError(ofmt, convposn, curconv, "has no matching argument (too few arguments passed)");
      }
      arg = args.shift();
      argn++;
      if (flags.match(/[\' #]/)) {
        throw jsError(ofmt, convposn, curconv, "uses unsupported flags");
      }
      if (precision.length > 0) {
        throw jsError(ofmt, convposn, curconv, "uses non-zero precision (not supported)");
      }
      if (flags.match(/-/))
        left = true;
      if (flags.match(/0/))
        pad = "0";
      if (flags.match(/\+/))
        sign = true;
      switch (conversion) {
        case "s":
          if (arg === void 0 || arg === null) {
            throw jsError(ofmt, convposn, curconv, "attempted to print undefined or null as a string (argument " + argn + " to sprintf)");
          }
          ret += doPad(pad, width, left, arg.toString());
          break;
        case "d":
          arg = Math.floor(arg);
        case "f":
          sign = sign && arg > 0 ? "+" : "";
          ret += sign + doPad(pad, width, left, arg.toString());
          break;
        case "x":
          ret += doPad(pad, width, left, arg.toString(16));
          break;
        case "j":
          if (width === 0)
            width = 10;
          ret += mod_util.inspect(arg, false, width);
          break;
        case "r":
          ret += dumpException(arg);
          break;
        default:
          throw jsError(ofmt, convposn, curconv, "is not supported");
      }
    }
    ret += fmt;
    return ret;
  }
  function jsError(fmtstr, convposn, curconv, reason) {
    mod_assert.equal(typeof fmtstr, "string");
    mod_assert.equal(typeof curconv, "string");
    mod_assert.equal(typeof convposn, "number");
    mod_assert.equal(typeof reason, "string");
    return new Error('format string "' + fmtstr + '": conversion specifier "' + curconv + '" at character ' + convposn + " " + reason);
  }
  function jsPrintf() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(process.stdout);
    jsFprintf.apply(null, args);
  }
  function jsFprintf(stream) {
    var args = Array.prototype.slice.call(arguments, 1);
    return stream.write(jsSprintf.apply(this, args));
  }
  function doPad(chr, width, left, str) {
    var ret = str;
    while (ret.length < width) {
      if (left)
        ret += chr;
      else
        ret = chr + ret;
    }
    return ret;
  }
  function dumpException(ex) {
    var ret;
    if (!(ex instanceof Error))
      throw new Error(jsSprintf("invalid type for %%r: %j", ex));
    ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
    if (ex.cause && typeof ex.cause === "function") {
      var cex = ex.cause();
      if (cex) {
        ret += "\nCaused by: " + dumpException(cex);
      }
    }
    return ret;
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports2) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/verror/lib/verror.js
var require_verror = __commonJS((exports2, module2) => {
  var mod_assertplus = require_assert();
  var mod_util = require("util");
  var mod_extsprintf = require_extsprintf2();
  var mod_isError = require_util().isError;
  var sprintf = mod_extsprintf.sprintf;
  module2.exports = VError;
  VError.VError = VError;
  VError.SError = SError;
  VError.WError = WError;
  VError.MultiError = MultiError;
  function parseConstructorArguments(args) {
    var argv, options, sprintf_args, shortmessage, k;
    mod_assertplus.object(args, "args");
    mod_assertplus.bool(args.strict, "args.strict");
    mod_assertplus.array(args.argv, "args.argv");
    argv = args.argv;
    if (argv.length === 0) {
      options = {};
      sprintf_args = [];
    } else if (mod_isError(argv[0])) {
      options = {cause: argv[0]};
      sprintf_args = argv.slice(1);
    } else if (typeof argv[0] === "object") {
      options = {};
      for (k in argv[0]) {
        options[k] = argv[0][k];
      }
      sprintf_args = argv.slice(1);
    } else {
      mod_assertplus.string(argv[0], "first argument to VError, SError, or WError constructor must be a string, object, or Error");
      options = {};
      sprintf_args = argv;
    }
    mod_assertplus.object(options);
    if (!options.strict && !args.strict) {
      sprintf_args = sprintf_args.map(function(a) {
        return a === null ? "null" : a === void 0 ? "undefined" : a;
      });
    }
    if (sprintf_args.length === 0) {
      shortmessage = "";
    } else {
      shortmessage = sprintf.apply(null, sprintf_args);
    }
    return {
      options,
      shortmessage
    };
  }
  function VError() {
    var args, obj, parsed, cause, ctor, message, k;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof VError)) {
      obj = Object.create(VError.prototype);
      VError.apply(obj, arguments);
      return obj;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false
    });
    if (parsed.options.name) {
      mod_assertplus.string(parsed.options.name, `error's "name" must be a string`);
      this.name = parsed.options.name;
    }
    this.jse_shortmsg = parsed.shortmessage;
    message = parsed.shortmessage;
    cause = parsed.options.cause;
    if (cause) {
      mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
      this.jse_cause = cause;
      if (!parsed.options.skipCauseMessage) {
        message += ": " + cause.message;
      }
    }
    this.jse_info = {};
    if (parsed.options.info) {
      for (k in parsed.options.info) {
        this.jse_info[k] = parsed.options.info[k];
      }
    }
    this.message = message;
    Error.call(this, message);
    if (Error.captureStackTrace) {
      ctor = parsed.options.constructorOpt || this.constructor;
      Error.captureStackTrace(this, ctor);
    }
    return this;
  }
  mod_util.inherits(VError, Error);
  VError.prototype.name = "VError";
  VError.prototype.toString = function ve_toString() {
    var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str += ": " + this.message;
    return str;
  };
  VError.prototype.cause = function ve_cause() {
    var cause = VError.cause(this);
    return cause === null ? void 0 : cause;
  };
  VError.cause = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    return mod_isError(err.jse_cause) ? err.jse_cause : null;
  };
  VError.info = function(err) {
    var rv, cause, k;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    cause = VError.cause(err);
    if (cause !== null) {
      rv = VError.info(cause);
    } else {
      rv = {};
    }
    if (typeof err.jse_info == "object" && err.jse_info !== null) {
      for (k in err.jse_info) {
        rv[k] = err.jse_info[k];
      }
    }
    return rv;
  };
  VError.findCauseByName = function(err, name) {
    var cause;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.string(name, "name");
    mod_assertplus.ok(name.length > 0, "name cannot be empty");
    for (cause = err; cause !== null; cause = VError.cause(cause)) {
      mod_assertplus.ok(mod_isError(cause));
      if (cause.name == name) {
        return cause;
      }
    }
    return null;
  };
  VError.hasCauseWithName = function(err, name) {
    return VError.findCauseByName(err, name) !== null;
  };
  VError.fullStack = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    var cause = VError.cause(err);
    if (cause) {
      return err.stack + "\ncaused by: " + VError.fullStack(cause);
    }
    return err.stack;
  };
  VError.errorFromList = function(errors) {
    mod_assertplus.arrayOfObject(errors, "errors");
    if (errors.length === 0) {
      return null;
    }
    errors.forEach(function(e) {
      mod_assertplus.ok(mod_isError(e));
    });
    if (errors.length == 1) {
      return errors[0];
    }
    return new MultiError(errors);
  };
  VError.errorForEach = function(err, func) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.func(func, "func");
    if (err instanceof MultiError) {
      err.errors().forEach(function iterError(e) {
        func(e);
      });
    } else {
      func(err);
    }
  };
  function SError() {
    var args, obj, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof SError)) {
      obj = Object.create(SError.prototype);
      SError.apply(obj, arguments);
      return obj;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: true
    });
    options = parsed.options;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(SError, VError);
  function MultiError(errors) {
    mod_assertplus.array(errors, "list of errors");
    mod_assertplus.ok(errors.length > 0, "must be at least one error");
    this.ase_errors = errors;
    VError.call(this, {
      cause: errors[0]
    }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
  }
  mod_util.inherits(MultiError, VError);
  MultiError.prototype.name = "MultiError";
  MultiError.prototype.errors = function me_errors() {
    return this.ase_errors.slice(0);
  };
  function WError() {
    var args, obj, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof WError)) {
      obj = Object.create(WError.prototype);
      WError.apply(obj, args);
      return obj;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false
    });
    options = parsed.options;
    options["skipCauseMessage"] = true;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(WError, VError);
  WError.prototype.name = "WError";
  WError.prototype.toString = function we_toString() {
    var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str += ": " + this.message;
    if (this.jse_cause && this.jse_cause.message)
      str += "; caused by " + this.jse_cause.toString();
    return str;
  };
  WError.prototype.cause = function we_cause(c) {
    if (mod_isError(c))
      this.jse_cause = c;
    return this.jse_cause;
  };
});

// node_modules/json-schema/lib/validate.js
var require_validate = __commonJS((exports2, module2) => {
  (function(root2, factory) {
    if (typeof define === "function" && define.amd) {
      define([], function() {
        return factory();
      });
    } else if (typeof module2 === "object" && module2.exports) {
      module2.exports = factory();
    } else {
      root2.jsonSchema = factory();
    }
  })(exports2, function() {
    var exports3 = validate;
    exports3.Integer = {type: "integer"};
    var primitiveConstructors = {
      String,
      Boolean,
      Number,
      Object,
      Array,
      Date
    };
    exports3.validate = validate;
    function validate(instance, schema) {
      return validate(instance, schema, {changing: false});
    }
    ;
    exports3.checkPropertyChange = function(value, schema, property) {
      return validate(value, schema, {changing: property || "property"});
    };
    var validate = exports3._validate = function(instance, schema, options) {
      if (!options)
        options = {};
      var _changing = options.changing;
      function getType(schema2) {
        return schema2.type || primitiveConstructors[schema2.name] == schema2 && schema2.name.toLowerCase();
      }
      var errors = [];
      function checkProp(value, schema2, path, i) {
        var l;
        path += path ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
        function addError(message) {
          errors.push({property: path, message});
        }
        if ((typeof schema2 != "object" || schema2 instanceof Array) && (path || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
          if (typeof schema2 == "function") {
            if (!(value instanceof schema2)) {
              addError("is not an instance of the class/constructor " + schema2.name);
            }
          } else if (schema2) {
            addError("Invalid schema/property definition " + schema2);
          }
          return null;
        }
        if (_changing && schema2.readonly) {
          addError("is a readonly field, it can not be changed");
        }
        if (schema2["extends"]) {
          checkProp(value, schema2["extends"], path, i);
        }
        function checkType(type, value2) {
          if (type) {
            if (typeof type == "string" && type != "any" && (type == "null" ? value2 !== null : typeof value2 != type) && !(value2 instanceof Array && type == "array") && !(value2 instanceof Date && type == "date") && !(type == "integer" && value2 % 1 === 0)) {
              return [{property: path, message: typeof value2 + " value found, but a " + type + " is required"}];
            }
            if (type instanceof Array) {
              var unionErrors = [];
              for (var j2 = 0; j2 < type.length; j2++) {
                if (!(unionErrors = checkType(type[j2], value2)).length) {
                  break;
                }
              }
              if (unionErrors.length) {
                return unionErrors;
              }
            } else if (typeof type == "object") {
              var priorErrors = errors;
              errors = [];
              checkProp(value2, type, path);
              var theseErrors = errors;
              errors = priorErrors;
              return theseErrors;
            }
          }
          return [];
        }
        if (value === void 0) {
          if (schema2.required) {
            addError("is missing and it is required");
          }
        } else {
          errors = errors.concat(checkType(getType(schema2), value));
          if (schema2.disallow && !checkType(schema2.disallow, value).length) {
            addError(" disallowed value was matched");
          }
          if (value !== null) {
            if (value instanceof Array) {
              if (schema2.items) {
                var itemsIsArray = schema2.items instanceof Array;
                var propDef = schema2.items;
                for (i = 0, l = value.length; i < l; i += 1) {
                  if (itemsIsArray)
                    propDef = schema2.items[i];
                  if (options.coerce)
                    value[i] = options.coerce(value[i], propDef);
                  errors.concat(checkProp(value[i], propDef, path, i));
                }
              }
              if (schema2.minItems && value.length < schema2.minItems) {
                addError("There must be a minimum of " + schema2.minItems + " in the array");
              }
              if (schema2.maxItems && value.length > schema2.maxItems) {
                addError("There must be a maximum of " + schema2.maxItems + " in the array");
              }
            } else if (schema2.properties || schema2.additionalProperties) {
              errors.concat(checkObj(value, schema2.properties, path, schema2.additionalProperties));
            }
            if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
              addError("does not match the regex pattern " + schema2.pattern);
            }
            if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
              addError("may only be " + schema2.maxLength + " characters long");
            }
            if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
              addError("must be at least " + schema2.minLength + " characters long");
            }
            if (typeof schema2.minimum !== void 0 && typeof value == typeof schema2.minimum && schema2.minimum > value) {
              addError("must have a minimum value of " + schema2.minimum);
            }
            if (typeof schema2.maximum !== void 0 && typeof value == typeof schema2.maximum && schema2.maximum < value) {
              addError("must have a maximum value of " + schema2.maximum);
            }
            if (schema2["enum"]) {
              var enumer = schema2["enum"];
              l = enumer.length;
              var found;
              for (var j = 0; j < l; j++) {
                if (enumer[j] === value) {
                  found = 1;
                  break;
                }
              }
              if (!found) {
                addError("does not have a value in the enumeration " + enumer.join(", "));
              }
            }
            if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
              addError("may only have " + schema2.maxDecimal + " digits of decimal places");
            }
          }
        }
        return null;
      }
      function checkObj(instance2, objTypeDef, path, additionalProp) {
        if (typeof objTypeDef == "object") {
          if (typeof instance2 != "object" || instance2 instanceof Array) {
            errors.push({property: path, message: "an object is required"});
          }
          for (var i in objTypeDef) {
            if (objTypeDef.hasOwnProperty(i)) {
              var value = instance2[i];
              if (value === void 0 && options.existingOnly)
                continue;
              var propDef = objTypeDef[i];
              if (value === void 0 && propDef["default"]) {
                value = instance2[i] = propDef["default"];
              }
              if (options.coerce && i in instance2) {
                value = instance2[i] = options.coerce(value, propDef);
              }
              checkProp(value, propDef, path, i);
            }
          }
        }
        for (i in instance2) {
          if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
            if (options.filter) {
              delete instance2[i];
              continue;
            } else {
              errors.push({property: path, message: typeof value + "The property " + i + " is not defined in the schema and the schema does not allow additional properties"});
            }
          }
          var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
          if (requires && !(requires in instance2)) {
            errors.push({property: path, message: "the presence of the property " + i + " requires that " + requires + " also be present"});
          }
          value = instance2[i];
          if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
            if (options.coerce) {
              value = instance2[i] = options.coerce(value, additionalProp);
            }
            checkProp(value, additionalProp, path, i);
          }
          if (!_changing && value && value.$schema) {
            errors = errors.concat(checkProp(value, value.$schema, path, i));
          }
        }
        return errors;
      }
      if (schema) {
        checkProp(instance, schema, "", _changing || "");
      }
      if (!_changing && instance && instance.$schema) {
        checkProp(instance, instance.$schema, "", "");
      }
      return {valid: !errors.length, errors};
    };
    exports3.mustBeValid = function(result) {
      if (!result.valid) {
        throw new TypeError(result.errors.map(function(error) {
          return "for property " + error.property + ": " + error.message;
        }).join(", \n"));
      }
    };
    return exports3;
  });
});

// node_modules/jsprim/lib/jsprim.js
var require_jsprim = __commonJS((exports2) => {
  var mod_assert = require_assert();
  var mod_util = require("util");
  var mod_extsprintf = require_extsprintf();
  var mod_verror = require_verror();
  var mod_jsonschema = require_validate();
  exports2.deepCopy = deepCopy;
  exports2.deepEqual = deepEqual;
  exports2.isEmpty = isEmpty;
  exports2.hasKey = hasKey;
  exports2.forEachKey = forEachKey;
  exports2.pluck = pluck;
  exports2.flattenObject = flattenObject;
  exports2.flattenIter = flattenIter;
  exports2.validateJsonObject = validateJsonObjectJS;
  exports2.validateJsonObjectJS = validateJsonObjectJS;
  exports2.randElt = randElt;
  exports2.extraProperties = extraProperties;
  exports2.mergeObjects = mergeObjects;
  exports2.startsWith = startsWith;
  exports2.endsWith = endsWith;
  exports2.parseInteger = parseInteger;
  exports2.iso8601 = iso8601;
  exports2.rfc1123 = rfc1123;
  exports2.parseDateTime = parseDateTime;
  exports2.hrtimediff = hrtimeDiff;
  exports2.hrtimeDiff = hrtimeDiff;
  exports2.hrtimeAccum = hrtimeAccum;
  exports2.hrtimeAdd = hrtimeAdd;
  exports2.hrtimeNanosec = hrtimeNanosec;
  exports2.hrtimeMicrosec = hrtimeMicrosec;
  exports2.hrtimeMillisec = hrtimeMillisec;
  function deepCopy(obj) {
    var ret, key;
    var marker = "__deepCopy";
    if (obj && obj[marker])
      throw new Error("attempted deep copy of cyclic object");
    if (obj && obj.constructor == Object) {
      ret = {};
      obj[marker] = true;
      for (key in obj) {
        if (key == marker)
          continue;
        ret[key] = deepCopy(obj[key]);
      }
      delete obj[marker];
      return ret;
    }
    if (obj && obj.constructor == Array) {
      ret = [];
      obj[marker] = true;
      for (key = 0; key < obj.length; key++)
        ret.push(deepCopy(obj[key]));
      delete obj[marker];
      return ret;
    }
    return obj;
  }
  function deepEqual(obj1, obj2) {
    if (typeof obj1 != typeof obj2)
      return false;
    if (obj1 === null || obj2 === null || typeof obj1 != "object")
      return obj1 === obj2;
    if (obj1.constructor != obj2.constructor)
      return false;
    var k;
    for (k in obj1) {
      if (!obj2.hasOwnProperty(k))
        return false;
      if (!deepEqual(obj1[k], obj2[k]))
        return false;
    }
    for (k in obj2) {
      if (!obj1.hasOwnProperty(k))
        return false;
    }
    return true;
  }
  function isEmpty(obj) {
    var key;
    for (key in obj)
      return false;
    return true;
  }
  function hasKey(obj, key) {
    mod_assert.equal(typeof key, "string");
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function forEachKey(obj, callback) {
    for (var key in obj) {
      if (hasKey(obj, key)) {
        callback(key, obj[key]);
      }
    }
  }
  function pluck(obj, key) {
    mod_assert.equal(typeof key, "string");
    return pluckv(obj, key);
  }
  function pluckv(obj, key) {
    if (obj === null || typeof obj !== "object")
      return void 0;
    if (obj.hasOwnProperty(key))
      return obj[key];
    var i = key.indexOf(".");
    if (i == -1)
      return void 0;
    var key1 = key.substr(0, i);
    if (!obj.hasOwnProperty(key1))
      return void 0;
    return pluckv(obj[key1], key.substr(i + 1));
  }
  function flattenIter(data, depth, callback) {
    doFlattenIter(data, depth, [], callback);
  }
  function doFlattenIter(data, depth, accum, callback) {
    var each;
    var key;
    if (depth === 0) {
      each = accum.slice(0);
      each.push(data);
      callback(each);
      return;
    }
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    for (key in data) {
      each = accum.slice(0);
      each.push(key);
      doFlattenIter(data[key], depth - 1, each, callback);
    }
  }
  function flattenObject(data, depth) {
    if (depth === 0)
      return [data];
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    var rv = [];
    var key;
    for (key in data) {
      flattenObject(data[key], depth - 1).forEach(function(p) {
        rv.push([key].concat(p));
      });
    }
    return rv;
  }
  function startsWith(str, prefix) {
    return str.substr(0, prefix.length) == prefix;
  }
  function endsWith(str, suffix) {
    return str.substr(str.length - suffix.length, suffix.length) == suffix;
  }
  function iso8601(d) {
    if (typeof d == "number")
      d = new Date(d);
    mod_assert.ok(d.constructor === Date);
    return mod_extsprintf.sprintf("%4d-%02d-%02dT%02d:%02d:%02d.%03dZ", d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
  }
  var RFC1123_MONTHS = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var RFC1123_DAYS = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  function rfc1123(date) {
    return mod_extsprintf.sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT", RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  }
  function parseDateTime(str) {
    var numeric = +str;
    if (!isNaN(numeric)) {
      return new Date(numeric);
    } else {
      return new Date(str);
    }
  }
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var PI_DEFAULTS = {
    base: 10,
    allowSign: true,
    allowPrefix: false,
    allowTrailing: false,
    allowImprecise: false,
    trimWhitespace: false,
    leadingZeroIsOctal: false
  };
  var CP_0 = 48;
  var CP_9 = 57;
  var CP_A = 65;
  var CP_B = 66;
  var CP_O = 79;
  var CP_T = 84;
  var CP_X = 88;
  var CP_Z = 90;
  var CP_a = 97;
  var CP_b = 98;
  var CP_o = 111;
  var CP_t = 116;
  var CP_x = 120;
  var CP_z = 122;
  var PI_CONV_DEC = 48;
  var PI_CONV_UC = 55;
  var PI_CONV_LC = 87;
  function parseInteger(str, uopts) {
    mod_assert.string(str, "str");
    mod_assert.optionalObject(uopts, "options");
    var baseOverride = false;
    var options = PI_DEFAULTS;
    if (uopts) {
      baseOverride = hasKey(uopts, "base");
      options = mergeObjects(options, uopts);
      mod_assert.number(options.base, "options.base");
      mod_assert.ok(options.base >= 2, "options.base >= 2");
      mod_assert.ok(options.base <= 36, "options.base <= 36");
      mod_assert.bool(options.allowSign, "options.allowSign");
      mod_assert.bool(options.allowPrefix, "options.allowPrefix");
      mod_assert.bool(options.allowTrailing, "options.allowTrailing");
      mod_assert.bool(options.allowImprecise, "options.allowImprecise");
      mod_assert.bool(options.trimWhitespace, "options.trimWhitespace");
      mod_assert.bool(options.leadingZeroIsOctal, "options.leadingZeroIsOctal");
      if (options.leadingZeroIsOctal) {
        mod_assert.ok(!baseOverride, '"base" and "leadingZeroIsOctal" are mutually exclusive');
      }
    }
    var c;
    var pbase = -1;
    var base = options.base;
    var start;
    var mult = 1;
    var value = 0;
    var idx = 0;
    var len = str.length;
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (options.allowSign) {
      if (str[idx] === "-") {
        idx += 1;
        mult = -1;
      } else if (str[idx] === "+") {
        idx += 1;
      }
    }
    if (str[idx] === "0") {
      if (options.allowPrefix) {
        pbase = prefixToBase(str.charCodeAt(idx + 1));
        if (pbase !== -1 && (!baseOverride || pbase === base)) {
          base = pbase;
          idx += 2;
        }
      }
      if (pbase === -1 && options.leadingZeroIsOctal) {
        base = 8;
      }
    }
    for (start = idx; idx < len; ++idx) {
      c = translateDigit(str.charCodeAt(idx));
      if (c !== -1 && c < base) {
        value *= base;
        value += c;
      } else {
        break;
      }
    }
    if (start === idx) {
      return new Error("invalid number: " + JSON.stringify(str));
    }
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (idx < len && !options.allowTrailing) {
      return new Error("trailing characters after number: " + JSON.stringify(str.slice(idx)));
    }
    if (value === 0) {
      return 0;
    }
    var result = value * mult;
    if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
      return new Error("number is outside of the supported range: " + JSON.stringify(str.slice(start, idx)));
    }
    return result;
  }
  function translateDigit(d) {
    if (d >= CP_0 && d <= CP_9) {
      return d - PI_CONV_DEC;
    } else if (d >= CP_A && d <= CP_Z) {
      return d - PI_CONV_UC;
    } else if (d >= CP_a && d <= CP_z) {
      return d - PI_CONV_LC;
    } else {
      return -1;
    }
  }
  function isSpace(c) {
    return c === 32 || c >= 9 && c <= 13 || c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8232 || c === 8233 || c === 8239 || c === 8287 || c === 12288 || c === 65279;
  }
  function prefixToBase(c) {
    if (c === CP_b || c === CP_B) {
      return 2;
    } else if (c === CP_o || c === CP_O) {
      return 8;
    } else if (c === CP_t || c === CP_T) {
      return 10;
    } else if (c === CP_x || c === CP_X) {
      return 16;
    } else {
      return -1;
    }
  }
  function validateJsonObjectJS(schema, input) {
    var report = mod_jsonschema.validate(input, schema);
    if (report.errors.length === 0)
      return null;
    var error = report.errors[0];
    var propname = error["property"];
    var reason = error["message"].toLowerCase();
    var i, j;
    if ((i = reason.indexOf("the property ")) != -1 && (j = reason.indexOf(" is not defined in the schema and the schema does not allow additional properties")) != -1) {
      i += "the property ".length;
      if (propname === "")
        propname = reason.substr(i, j - i);
      else
        propname = propname + "." + reason.substr(i, j - i);
      reason = "unsupported property";
    }
    var rv = new mod_verror.VError('property "%s": %s', propname, reason);
    rv.jsv_details = error;
    return rv;
  }
  function randElt(arr) {
    mod_assert.ok(Array.isArray(arr) && arr.length > 0, "randElt argument must be a non-empty array");
    return arr[Math.floor(Math.random() * arr.length)];
  }
  function assertHrtime(a) {
    mod_assert.ok(a[0] >= 0 && a[1] >= 0, "negative numbers not allowed in hrtimes");
    mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
  }
  function hrtimeDiff(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], "negative differences not allowed");
    var rv = [a[0] - b[0], 0];
    if (a[1] >= b[1]) {
      rv[1] = a[1] - b[1];
    } else {
      rv[0]--;
      rv[1] = 1e9 - (b[1] - a[1]);
    }
    return rv;
  }
  function hrtimeNanosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e9 + a[1]);
  }
  function hrtimeMicrosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e6 + a[1] / 1e3);
  }
  function hrtimeMillisec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e3 + a[1] / 1e6);
  }
  function hrtimeAccum(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    a[1] += b[1];
    if (a[1] >= 1e9) {
      a[0]++;
      a[1] -= 1e9;
    }
    a[0] += b[0];
    return a;
  }
  function hrtimeAdd(a, b) {
    assertHrtime(a);
    var rv = [a[0], a[1]];
    return hrtimeAccum(rv, b);
  }
  function extraProperties(obj, allowed) {
    mod_assert.ok(typeof obj === "object" && obj !== null, "obj argument must be a non-null object");
    mod_assert.ok(Array.isArray(allowed), "allowed argument must be an array of strings");
    for (var i = 0; i < allowed.length; i++) {
      mod_assert.ok(typeof allowed[i] === "string", "allowed argument must be an array of strings");
    }
    return Object.keys(obj).filter(function(key) {
      return allowed.indexOf(key) === -1;
    });
  }
  function mergeObjects(provided, overrides, defaults) {
    var rv, k;
    rv = {};
    if (defaults) {
      for (k in defaults)
        rv[k] = defaults[k];
    }
    if (provided) {
      for (k in provided)
        rv[k] = provided[k];
    }
    if (overrides) {
      for (k in overrides)
        rv[k] = overrides[k];
    }
    return rv;
  }
});

// node_modules/http-signature/lib/signer.js
var require_signer = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var crypto = require("crypto");
  var http = require("http");
  var util = require("util");
  var sshpk = require_lib2();
  var jsprim = require_jsprim();
  var utils = require_utils2();
  var sprintf = require("util").format;
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  var AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util.inherits(StrictParsingError, HttpSignatureError);
  function RequestSigner(options) {
    assert.object(options, "options");
    var alg = [];
    if (options.algorithm !== void 0) {
      assert.string(options.algorithm, "options.algorithm");
      alg = validateAlgorithm(options.algorithm);
    }
    this.rs_alg = alg;
    if (options.sign !== void 0) {
      assert.func(options.sign, "options.sign");
      this.rs_signFunc = options.sign;
    } else if (alg[0] === "hmac" && options.key !== void 0) {
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
        throw new TypeError("options.key for HMAC must be a string or Buffer");
      this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
      this.rs_signer.sign = function() {
        var digest = this.digest("base64");
        return {
          hashAlgorithm: alg[1],
          toString: function() {
            return digest;
          }
        };
      };
    } else if (options.key !== void 0) {
      var key = options.key;
      if (typeof key === "string" || Buffer.isBuffer(key))
        key = sshpk.parsePrivateKey(key);
      assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
      this.rs_key = key;
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (!PK_ALGOS[key.type]) {
        throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
      }
      if (alg[0] !== void 0 && key.type !== alg[0]) {
        throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
      }
      this.rs_signer = key.createSign(alg[1]);
    } else {
      throw new TypeError("options.sign (func) or options.key is required");
    }
    this.rs_headers = [];
    this.rs_lines = [];
  }
  RequestSigner.prototype.writeHeader = function(header, value) {
    assert.string(header, "header");
    header = header.toLowerCase();
    assert.string(value, "value");
    this.rs_headers.push(header);
    if (this.rs_signFunc) {
      this.rs_lines.push(header + ": " + value);
    } else {
      var line = header + ": " + value;
      if (this.rs_headers.length > 0)
        line = "\n" + line;
      this.rs_signer.update(line);
    }
    return value;
  };
  RequestSigner.prototype.writeDateHeader = function() {
    return this.writeHeader("date", jsprim.rfc1123(new Date()));
  };
  RequestSigner.prototype.writeTarget = function(method, path) {
    assert.string(method, "method");
    assert.string(path, "path");
    method = method.toLowerCase();
    this.writeHeader("(request-target)", method + " " + path);
  };
  RequestSigner.prototype.sign = function(cb) {
    assert.func(cb, "callback");
    if (this.rs_headers.length < 1)
      throw new Error("At least one header must be signed");
    var alg, authz;
    if (this.rs_signFunc) {
      var data = this.rs_lines.join("\n");
      var self2 = this;
      this.rs_signFunc(data, function(err, sig) {
        if (err) {
          cb(err);
          return;
        }
        try {
          assert.object(sig, "signature");
          assert.string(sig.keyId, "signature.keyId");
          assert.string(sig.algorithm, "signature.algorithm");
          assert.string(sig.signature, "signature.signature");
          alg = validateAlgorithm(sig.algorithm);
          authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self2.rs_headers.join(" "), sig.signature);
        } catch (e) {
          cb(e);
          return;
        }
        cb(null, authz);
      });
    } else {
      try {
        var sigObj = this.rs_signer.sign();
      } catch (e) {
        cb(e);
        return;
      }
      alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
      var signature = sigObj.toString();
      authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(" "), signature);
      cb(null, authz);
    }
  };
  module2.exports = {
    isSigner: function(obj) {
      if (typeof obj === "object" && obj instanceof RequestSigner)
        return true;
      return false;
    },
    createSigner: function createSigner(options) {
      return new RequestSigner(options);
    },
    signRequest: function signRequest(request, options) {
      assert.object(request, "request");
      assert.object(options, "options");
      assert.optionalString(options.algorithm, "options.algorithm");
      assert.string(options.keyId, "options.keyId");
      assert.optionalArrayOfString(options.headers, "options.headers");
      assert.optionalString(options.httpVersion, "options.httpVersion");
      if (!request.getHeader("Date"))
        request.setHeader("Date", jsprim.rfc1123(new Date()));
      if (!options.headers)
        options.headers = ["date"];
      if (!options.httpVersion)
        options.httpVersion = "1.1";
      var alg = [];
      if (options.algorithm) {
        options.algorithm = options.algorithm.toLowerCase();
        alg = validateAlgorithm(options.algorithm);
      }
      var i;
      var stringToSign = "";
      for (i = 0; i < options.headers.length; i++) {
        if (typeof options.headers[i] !== "string")
          throw new TypeError("options.headers must be an array of Strings");
        var h = options.headers[i].toLowerCase();
        if (h === "request-line") {
          if (!options.strict) {
            stringToSign += request.method + " " + request.path + " HTTP/" + options.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          stringToSign += "(request-target): " + request.method.toLowerCase() + " " + request.path;
        } else {
          var value = request.getHeader(h);
          if (value === void 0 || value === "") {
            throw new MissingHeaderError(h + " was not in the request");
          }
          stringToSign += h + ": " + value;
        }
        if (i + 1 < options.headers.length)
          stringToSign += "\n";
      }
      if (request.hasOwnProperty("_stringToSign")) {
        request._stringToSign = stringToSign;
      }
      var signature;
      if (alg[0] === "hmac") {
        if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
          throw new TypeError("options.key must be a string or Buffer");
        var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
        hmac.update(stringToSign);
        signature = hmac.digest("base64");
      } else {
        var key = options.key;
        if (typeof key === "string" || Buffer.isBuffer(key))
          key = sshpk.parsePrivateKey(options.key);
        assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
        if (!PK_ALGOS[key.type]) {
          throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
        }
        if (alg[0] !== void 0 && key.type !== alg[0]) {
          throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
        }
        var signer = key.createSign(alg[1]);
        signer.update(stringToSign);
        var sigObj = signer.sign();
        if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
          throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
        }
        options.algorithm = key.type + "-" + sigObj.hashAlgorithm;
        signature = sigObj.toString();
        assert.notStrictEqual(signature, "", "empty signature produced");
      }
      var authzHeaderName = options.authorizationHeaderName || "Authorization";
      request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(" "), signature));
      return true;
    }
  };
});

// node_modules/http-signature/lib/verify.js
var require_verify = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var crypto = require("crypto");
  var sshpk = require_lib2();
  var utils = require_utils2();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  module2.exports = {
    verifySignature: function verifySignature(parsedSignature, pubkey) {
      assert.object(parsedSignature, "parsedSignature");
      if (typeof pubkey === "string" || Buffer.isBuffer(pubkey))
        pubkey = sshpk.parseKey(pubkey);
      assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), "pubkey must be a sshpk.Key");
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] === "hmac" || alg[0] !== pubkey.type)
        return false;
      var v = pubkey.createVerify(alg[1]);
      v.update(parsedSignature.signingString);
      return v.verify(parsedSignature.params.signature, "base64");
    },
    verifyHMAC: function verifyHMAC(parsedSignature, secret) {
      assert.object(parsedSignature, "parsedHMAC");
      assert.string(secret, "secret");
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] !== "hmac")
        return false;
      var hashAlg = alg[1].toUpperCase();
      var hmac = crypto.createHmac(hashAlg, secret);
      hmac.update(parsedSignature.signingString);
      var h1 = crypto.createHmac(hashAlg, secret);
      h1.update(hmac.digest());
      h1 = h1.digest();
      var h2 = crypto.createHmac(hashAlg, secret);
      h2.update(new Buffer(parsedSignature.params.signature, "base64"));
      h2 = h2.digest();
      if (typeof h1 === "string")
        return h1 === h2;
      if (Buffer.isBuffer(h1) && !h1.equals)
        return h1.toString("binary") === h2.toString("binary");
      return h1.equals(h2);
    }
  };
});

// node_modules/http-signature/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  var parser = require_parser();
  var signer = require_signer();
  var verify = require_verify();
  var utils = require_utils2();
  module2.exports = {
    parse: parser.parseRequest,
    parseRequest: parser.parseRequest,
    sign: signer.signRequest,
    signRequest: signer.signRequest,
    createSigner: signer.createSigner,
    isSigner: signer.isSigner,
    sshKeyToPEM: utils.sshKeyToPEM,
    sshKeyFingerprint: utils.fingerprint,
    pemToRsaSSHKey: utils.pemToRsaSSHKey,
    verify: verify.verifySignature,
    verifySignature: verify.verifySignature,
    verifyHMAC: verify.verifyHMAC
  };
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports2, module2) => {
  module2.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["ecma", "es"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true
    },
    "application/fhir+json": {
      source: "iana",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana"
    },
    "application/news-groupinfo": {
      source: "iana"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana"
    },
    "application/nss": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana"
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana"
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["keynote"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana"
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana"
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "apache",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana"
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana"
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana"
    },
    "image/avcs": {
      source: "iana"
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana",
      compressible: false
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shex": {
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana"
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vp8": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports2, module2) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module2.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports2) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var db = require_mime_db();
  var extname = require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset;
  exports2.charsets = {lookup: charset};
  exports2.contentType = contentType;
  exports2.extension = extension;
  exports2.extensions = Object.create(null);
  exports2.lookup = lookup;
  exports2.types = Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports2.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports2.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports2.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/caseless/index.js
var require_caseless = __commonJS((exports2, module2) => {
  function Caseless(dict) {
    this.dict = dict || {};
  }
  Caseless.prototype.set = function(name, value, clobber) {
    if (typeof name === "object") {
      for (var i in name) {
        this.set(i, name[i], value);
      }
    } else {
      if (typeof clobber === "undefined")
        clobber = true;
      var has2 = this.has(name);
      if (!clobber && has2)
        this.dict[has2] = this.dict[has2] + "," + value;
      else
        this.dict[has2 || name] = value;
      return has2;
    }
  };
  Caseless.prototype.has = function(name) {
    var keys = Object.keys(this.dict), name = name.toLowerCase();
    for (var i = 0; i < keys.length; i++) {
      if (keys[i].toLowerCase() === name)
        return keys[i];
    }
    return false;
  };
  Caseless.prototype.get = function(name) {
    name = name.toLowerCase();
    var result, _key;
    var headers = this.dict;
    Object.keys(headers).forEach(function(key) {
      _key = key.toLowerCase();
      if (name === _key)
        result = headers[key];
    });
    return result;
  };
  Caseless.prototype.swap = function(name) {
    var has2 = this.has(name);
    if (has2 === name)
      return;
    if (!has2)
      throw new Error('There is no header than matches "' + name + '"');
    this.dict[name] = this.dict[has2];
    delete this.dict[has2];
  };
  Caseless.prototype.del = function(name) {
    var has2 = this.has(name);
    return delete this.dict[has2 || name];
  };
  module2.exports = function(dict) {
    return new Caseless(dict);
  };
  module2.exports.httpify = function(resp, headers) {
    var c = new Caseless(headers);
    resp.setHeader = function(key, value, clobber) {
      if (typeof value === "undefined")
        return;
      return c.set(key, value, clobber);
    };
    resp.hasHeader = function(key) {
      return c.has(key);
    };
    resp.getHeader = function(key) {
      return c.get(key);
    };
    resp.removeHeader = function(key) {
      return c.del(key);
    };
    resp.headers = c.dict;
    return c;
  };
});

// node_modules/forever-agent/index.js
var require_forever_agent = __commonJS((exports2, module2) => {
  module2.exports = ForeverAgent;
  ForeverAgent.SSL = ForeverAgentSSL;
  var util = require("util");
  var Agent = require("http").Agent;
  var net2 = require("net");
  var tls = require("tls");
  var AgentSSL = require("https").Agent;
  function getConnectionName(host, port) {
    var name = "";
    if (typeof host === "string") {
      name = host + ":" + port;
    } else {
      name = host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
    }
    return name;
  }
  function ForeverAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.requests = {};
    self2.sockets = {};
    self2.freeSockets = {};
    self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
    self2.minSockets = self2.options.minSockets || ForeverAgent.defaultMinSockets;
    self2.on("free", function(socket, host, port) {
      var name = getConnectionName(host, port);
      if (self2.requests[name] && self2.requests[name].length) {
        self2.requests[name].shift().onSocket(socket);
      } else if (self2.sockets[name].length < self2.minSockets) {
        if (!self2.freeSockets[name])
          self2.freeSockets[name] = [];
        self2.freeSockets[name].push(socket);
        var onIdleError = function() {
          socket.destroy();
        };
        socket._onIdleError = onIdleError;
        socket.on("error", onIdleError);
      } else {
        socket.destroy();
      }
    });
  }
  util.inherits(ForeverAgent, Agent);
  ForeverAgent.defaultMinSockets = 5;
  ForeverAgent.prototype.createConnection = net2.createConnection;
  ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
  ForeverAgent.prototype.addRequest = function(req, host, port) {
    var name = getConnectionName(host, port);
    if (typeof host !== "string") {
      var options = host;
      port = options.port;
      host = options.host;
    }
    if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
      var idleSocket = this.freeSockets[name].pop();
      idleSocket.removeListener("error", idleSocket._onIdleError);
      delete idleSocket._onIdleError;
      req._reusedSocket = true;
      req.onSocket(idleSocket);
    } else {
      this.addRequestNoreuse(req, host, port);
    }
  };
  ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
    if (this.sockets[name]) {
      var index = this.sockets[name].indexOf(s);
      if (index !== -1) {
        this.sockets[name].splice(index, 1);
      }
    } else if (this.sockets[name] && this.sockets[name].length === 0) {
      delete this.sockets[name];
      delete this.requests[name];
    }
    if (this.freeSockets[name]) {
      var index = this.freeSockets[name].indexOf(s);
      if (index !== -1) {
        this.freeSockets[name].splice(index, 1);
        if (this.freeSockets[name].length === 0) {
          delete this.freeSockets[name];
        }
      }
    }
    if (this.requests[name] && this.requests[name].length) {
      this.createSocket(name, host, port).emit("free");
    }
  };
  function ForeverAgentSSL(options) {
    ForeverAgent.call(this, options);
  }
  util.inherits(ForeverAgentSSL, ForeverAgent);
  ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
  ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
  function createConnectionSSL(port, host, options) {
    if (typeof port === "object") {
      options = port;
    } else if (typeof host === "object") {
      options = host;
    } else if (typeof options === "object") {
      options = options;
    } else {
      options = {};
    }
    if (typeof port === "number") {
      options.port = port;
    }
    if (typeof host === "string") {
      options.host = host;
    }
    return tls.connect(options);
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  var util = require("util");
  module2.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports2, module2) => {
  var util = require("util");
  var Stream = require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module2.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, {end: false});
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports2, module2) => {
  module2.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var defer = require_defer();
  module2.exports = async;
  function async(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports2, module2) => {
  module2.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports2, module2) => {
  var async = require_async();
  var abort = require_abort();
  module2.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports2, module2) => {
  module2.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports2, module2) => {
  var abort = require_abort();
  var async = require_async();
  module2.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = serialOrdered;
  module2.exports.ascending = ascending;
  module2.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports2, module2) => {
  var serialOrdered = require_serialOrdered();
  module2.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports2, module2) => {
  module2.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports2, module2) => {
  module2.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports2, module2) => {
  var CombinedStream = require_combined_stream();
  var util = require("util");
  var path = require("path");
  var http = require("http");
  var https = require("https");
  var parseUrl = require("url").parse;
  var fs = require("fs");
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var populate = require_populate();
  module2.exports = FormData;
  util.inherits(FormData, CombinedStream);
  function FormData(options) {
    if (!(this instanceof FormData)) {
      return new FormData();
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData.LINE_BREAK = "\r\n";
  FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = {filename: options};
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (util.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData.prototype._lengthRetriever = function(value, callback) {
    if (value.hasOwnProperty("fd")) {
      if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (value.hasOwnProperty("httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (value.hasOwnProperty("httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (!headers.hasOwnProperty(prop))
        continue;
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
      }
    }
    return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
  };
  FormData.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty("httpVersion")) {
      filename = path.basename(value.client._httpMessage.path);
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData.prototype._multiPartFooter = function() {
    return function(next2) {
      var footer = FormData.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next2(footer);
    }.bind(this);
  };
  FormData.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
  };
  FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (userHeaders.hasOwnProperty(header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData.prototype.submit = function(params, cb) {
    var request, options, defaults = {method: "post"};
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err) {
        this._error(err);
        return;
      }
      request.setHeader("Content-Length", length);
      this.pipe(request);
      if (cb) {
        request.on("error", cb);
        request.on("response", cb.bind(this, null));
      }
    }.bind(this));
    return request;
  };
  FormData.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData.prototype.toString = function() {
    return "[object FormData]";
  };
});

// node_modules/isstream/isstream.js
var require_isstream = __commonJS((exports2, module2) => {
  var stream = require("stream");
  function isStream(obj) {
    return obj instanceof stream.Stream;
  }
  function isReadable(obj) {
    return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
  }
  function isWritable(obj) {
    return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
  }
  function isDuplex(obj) {
    return isReadable(obj) && isWritable(obj);
  }
  module2.exports = isStream;
  module2.exports.isReadable = isReadable;
  module2.exports.isWritable = isWritable;
  module2.exports.isDuplex = isDuplex;
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS((exports2, module2) => {
  module2.exports = isTypedArray;
  isTypedArray.strict = isStrictTypedArray;
  isTypedArray.loose = isLooseTypedArray;
  var toString = Object.prototype.toString;
  var names = {
    "[object Int8Array]": true,
    "[object Int16Array]": true,
    "[object Int32Array]": true,
    "[object Uint8Array]": true,
    "[object Uint8ClampedArray]": true,
    "[object Uint16Array]": true,
    "[object Uint32Array]": true,
    "[object Float32Array]": true,
    "[object Float64Array]": true
  };
  function isTypedArray(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }
  function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
  }
});

// node_modules/request/lib/getProxyFromURI.js
var require_getProxyFromURI = __commonJS((exports2, module2) => {
  "use strict";
  function formatHostname(hostname) {
    return hostname.replace(/^\.*/, ".").toLowerCase();
  }
  function parseNoProxyZone(zone) {
    zone = zone.trim().toLowerCase();
    var zoneParts = zone.split(":", 2);
    var zoneHost = formatHostname(zoneParts[0]);
    var zonePort = zoneParts[1];
    var hasPort = zone.indexOf(":") > -1;
    return {hostname: zoneHost, port: zonePort, hasPort};
  }
  function uriInNoProxy(uri, noProxy) {
    var port = uri.port || (uri.protocol === "https:" ? "443" : "80");
    var hostname = formatHostname(uri.hostname);
    var noProxyList = noProxy.split(",");
    return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
      var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
      var hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
      if (noProxyZone.hasPort) {
        return port === noProxyZone.port && hostnameMatched;
      }
      return hostnameMatched;
    });
  }
  function getProxyFromURI(uri) {
    var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
    if (noProxy === "*") {
      return null;
    }
    if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
      return null;
    }
    if (uri.protocol === "http:") {
      return process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    if (uri.protocol === "https:") {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    return null;
  }
  module2.exports = getProxyFromURI;
});

// node_modules/qs/lib/utils.js
var require_utils3 = __commonJS((exports2, module2) => {
  "use strict";
  var has2 = Object.prototype.hasOwnProperty;
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue) {
    var obj;
    while (queue.length) {
      var item = queue.pop();
      obj = item.obj[item.prop];
      if (Array.isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
    return obj;
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge2(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (Array.isArray(target)) {
        target.push(source);
      } else if (typeof target === "object") {
        if (options.plainObjects || options.allowPrototypes || !has2.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (Array.isArray(target) && Array.isArray(source)) {
      source.forEach(function(item, i) {
        if (has2.call(target, i)) {
          if (target[i] && typeof target[i] === "object") {
            target[i] = merge2(target[i], item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has2.call(acc, key)) {
        acc[key] = merge2(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str) {
    try {
      return decodeURIComponent(str.replace(/\+/g, " "));
    } catch (e) {
      return str;
    }
  };
  var encode = function encode2(str) {
    if (str.length === 0) {
      return str;
    }
    var string = typeof str === "string" ? str : String(str);
    var out = "";
    for (var i = 0; i < string.length; ++i) {
      var c = string.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
        out += string.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{obj: {o: value}, prop: "o"}];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({obj, prop: key});
          refs.push(val);
        }
      }
    }
    return compactQueue(queue);
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (obj === null || typeof obj === "undefined") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  module2.exports = {
    arrayToObject,
    assign,
    compact,
    decode,
    encode,
    isBuffer,
    isRegExp,
    merge
  };
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports2, module2) => {
  "use strict";
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  module2.exports = {
    default: "RFC3986",
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return value;
      }
    },
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
});

// node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils3();
  var formats = require_formats();
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat2(prefix) {
      return prefix;
    }
  };
  var toISO = Date.prototype.toISOString;
  var defaults = {
    delimiter: "&",
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var stringify = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
    var obj = object;
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
      }
      obj = "";
    }
    if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (Array.isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      if (Array.isArray(obj)) {
        values = values.concat(stringify2(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
      } else {
        values = values.concat(stringify2(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
      }
    }
    return values;
  };
  module2.exports = function(object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};
    if (options.encoder !== null && options.encoder !== void 0 && typeof options.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var delimiter = typeof options.delimiter === "undefined" ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === "boolean" ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === "boolean" ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === "function" ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === "function" ? options.sort : null;
    var allowDots = typeof options.allowDots === "undefined" ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === "function" ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === "boolean" ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === "undefined") {
      options.format = formats["default"];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (Array.isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = options.arrayFormat;
    } else if ("indices" in options) {
      arrayFormat = options.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (sort) {
      objKeys.sort(sort);
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
    }
    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    return joined.length > 0 ? prefix + joined : "";
  };
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils3();
  var has2 = Object.prototype.hasOwnProperty;
  var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    parameterLimit: 1e3,
    plainObjects: false,
    strictNullHandling: false
  };
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    for (var i = 0; i < parts.length; ++i) {
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder);
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder);
        val = options.decoder(part.slice(pos + 1), defaults.decoder);
      }
      if (has2.call(obj, key)) {
        obj[key] = [].concat(obj[key]).concat(val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options) {
    var leaf = val;
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root2 = chain[i];
      if (root2 === "[]") {
        obj = [];
        obj = obj.concat(leaf);
      } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
        var index = parseInt(cleanRoot, 10);
        if (!isNaN(index) && root2 !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has2.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has2.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options);
  };
  module2.exports = function(str, opts) {
    var options = opts ? utils.assign({}, opts) : {};
    if (options.decoder !== null && options.decoder !== void 0 && typeof options.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === "string" || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === "number" ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === "function" ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === "boolean" ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === "boolean" ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === "boolean" ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options);
      obj = utils.merge(obj, newObj, options);
    }
    return utils.compact(obj);
  };
});

// node_modules/qs/lib/index.js
var require_lib4 = __commonJS((exports2, module2) => {
  "use strict";
  var stringify = require_stringify2();
  var parse = require_parse2();
  var formats = require_formats();
  module2.exports = {
    formats,
    parse,
    stringify
  };
});

// node_modules/request/lib/querystring.js
var require_querystring = __commonJS((exports2) => {
  "use strict";
  var qs = require_lib4();
  var querystring = require("querystring");
  function Querystring(request) {
    this.request = request;
    this.lib = null;
    this.useQuerystring = null;
    this.parseOptions = null;
    this.stringifyOptions = null;
  }
  Querystring.prototype.init = function(options) {
    if (this.lib) {
      return;
    }
    this.useQuerystring = options.useQuerystring;
    this.lib = this.useQuerystring ? querystring : qs;
    this.parseOptions = options.qsParseOptions || {};
    this.stringifyOptions = options.qsStringifyOptions || {};
  };
  Querystring.prototype.stringify = function(obj) {
    return this.useQuerystring ? this.rfc3986(this.lib.stringify(obj, this.stringifyOptions.sep || null, this.stringifyOptions.eq || null, this.stringifyOptions)) : this.lib.stringify(obj, this.stringifyOptions);
  };
  Querystring.prototype.parse = function(str) {
    return this.useQuerystring ? this.lib.parse(str, this.parseOptions.sep || null, this.parseOptions.eq || null, this.parseOptions) : this.lib.parse(str, this.parseOptions);
  };
  Querystring.prototype.rfc3986 = function(str) {
    return str.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  };
  Querystring.prototype.unescape = querystring.unescape;
  exports2.Querystring = Querystring;
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS((exports2, module2) => {
  /** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
  })(exports2, function(exports3) {
    "use strict";
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
      var obj = target;
      if (source) {
        for (var key in source) {
          obj[key] = source[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI2) {
      var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (var w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$1("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$1("overflow");
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1("overflow");
            }
            if (_currentValue == n) {
              var q2 = delta;
              for (var k = base; ; k += base) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q2 < t) {
                  break;
                }
                var qMinusT = q2 - t;
                var baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      version: "2.1.0",
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode,
      encode,
      toASCII,
      toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({index, length: 1});
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host)) {
        } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve(baseURI, relativeURI, options) {
      var schemelessOptions = assign({scheme: "null"}, options);
      return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse2(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    var O = {};
    var isIRI = true;
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$2 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$3 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$4 = {
      scheme: "urn:uuid",
      parse: function parse2(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    exports3.SCHEMES = SCHEMES;
    exports3.pctEncChar = pctEncChar;
    exports3.pctDecChars = pctDecChars;
    exports3.parse = parse;
    exports3.removeDotSegments = removeDotSegments;
    exports3.serialize = serialize;
    exports3.resolveComponents = resolveComponents;
    exports3.resolve = resolve;
    exports3.normalize = normalize;
    exports3.equal = equal;
    exports3.escapeComponent = escapeComponent;
    exports3.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports3, "__esModule", {value: true});
  });
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports2, module2) => {
  "use strict";
  var isArray = Array.isArray;
  var keyList = Object.keys;
  var hasProp = Object.prototype.hasOwnProperty;
  module2.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      var arrA = isArray(a), arrB = isArray(b), i, length, key;
      if (arrA && arrB) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length; i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (arrA != arrB)
        return false;
      var dateA = a instanceof Date, dateB = b instanceof Date;
      if (dateA != dateB)
        return false;
      if (dateA && dateB)
        return a.getTime() == b.getTime();
      var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
      if (regexpA != regexpB)
        return false;
      if (regexpA && regexpB)
        return a.toString() == b.toString();
      var keys = keyList(a);
      length = keys.length;
      if (length !== keyList(b).length)
        return false;
      for (i = length; i-- !== 0; )
        if (!hasProp.call(b, keys[i]))
          return false;
      for (i = length; i-- !== 0; ) {
        key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function ucs2length(str) {
    var length = 0, len = str.length, pos = 0, value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) == 56320)
          pos++;
      }
    }
    return length;
  };
});

// node_modules/ajv/lib/compile/util.js
var require_util2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    copy,
    checkDataType,
    checkDataTypes,
    coerceToTypes,
    toHash,
    getProperty,
    escapeQuotes,
    equal: require_fast_deep_equal(),
    ucs2length: require_ucs2length(),
    varOccurences,
    varReplace,
    cleanUpCode,
    finalCleanUpCode,
    schemaHasRules,
    schemaHasRulesExcept,
    schemaUnknownRules,
    toQuotedString,
    getPathExpr,
    getPath,
    getData,
    unescapeFragment,
    unescapeJsonPointer,
    escapeFragment,
    escapeJsonPointer
  };
  function copy(o, to) {
    to = to || {};
    for (var key in o)
      to[key] = o[key];
    return to;
  }
  function checkDataType(dataType, data, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
    switch (dataType) {
      case "null":
        return data + EQUAL + "null";
      case "array":
        return OK + "Array.isArray(" + data + ")";
      case "object":
        return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
      case "integer":
        return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + ")";
      default:
        return "typeof " + data + EQUAL + '"' + dataType + '"';
    }
  }
  function checkDataTypes(dataTypes, data) {
    switch (dataTypes.length) {
      case 1:
        return checkDataType(dataTypes[0], data, true);
      default:
        var code = "";
        var types = toHash(dataTypes);
        if (types.array && types.object) {
          code = types.null ? "(" : "(!" + data + " || ";
          code += "typeof " + data + ' !== "object")';
          delete types.null;
          delete types.array;
          delete types.object;
        }
        if (types.number)
          delete types.integer;
        for (var t in types)
          code += (code ? " && " : "") + checkDataType(t, data, true);
        return code;
    }
  }
  var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
      var types = [];
      for (var i = 0; i < dataTypes.length; i++) {
        var t = dataTypes[i];
        if (COERCE_TO_TYPES[t])
          types[types.length] = t;
        else if (optionCoerceTypes === "array" && t === "array")
          types[types.length] = t;
      }
      if (types.length)
        return types;
    } else if (COERCE_TO_TYPES[dataTypes]) {
      return [dataTypes];
    } else if (optionCoerceTypes === "array" && dataTypes === "array") {
      return ["array"];
    }
  }
  function toHash(arr) {
    var hash = {};
    for (var i = 0; i < arr.length; i++)
      hash[arr[i]] = true;
    return hash;
  }
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var SINGLE_QUOTE = /'|\\/g;
  function getProperty(key) {
    return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
  }
  function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
  }
  function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
  }
  var EMPTY_ELSE = /else\s*{\s*}/g;
  var EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g;
  var EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
  function cleanUpCode(out) {
    return out.replace(EMPTY_ELSE, "").replace(EMPTY_IF_NO_ELSE, "").replace(EMPTY_IF_WITH_ELSE, "if (!($1))");
  }
  var ERRORS_REGEXP = /[^v.]errors/g;
  var REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g;
  var REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g;
  var RETURN_VALID = "return errors === 0;";
  var RETURN_TRUE = "validate.errors = null; return true;";
  var RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/;
  var RETURN_DATA_ASYNC = "return data;";
  var ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g;
  var REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;
  function finalCleanUpCode(out, async) {
    var matches = out.match(ERRORS_REGEXP);
    if (matches && matches.length == 2) {
      out = async ? out.replace(REMOVE_ERRORS_ASYNC, "").replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, "").replace(RETURN_VALID, RETURN_TRUE);
    }
    matches = out.match(ROOTDATA_REGEXP);
    if (!matches || matches.length !== 3)
      return out;
    return out.replace(REMOVE_ROOTDATA, "");
  }
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean")
      return !schema;
    for (var key in schema)
      if (rules2[key])
        return true;
  }
  function schemaHasRulesExcept(schema, rules2, exceptKeyword) {
    if (typeof schema == "boolean")
      return !schema && exceptKeyword != "not";
    for (var key in schema)
      if (key != exceptKeyword && rules2[key])
        return true;
  }
  function schemaUnknownRules(schema, rules2) {
    if (typeof schema == "boolean")
      return;
    for (var key in schema)
      if (!rules2[key])
        return key;
  }
  function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
  }
  function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
  }
  function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, lvl, paths) {
    var up, jsonPointer, data, matches;
    if ($data === "")
      return "rootData";
    if ($data[0] == "/") {
      if (!JSON_POINTER.test($data))
        throw new Error("Invalid JSON-pointer: " + $data);
      jsonPointer = $data;
      data = "rootData";
    } else {
      matches = $data.match(RELATIVE_JSON_POINTER);
      if (!matches)
        throw new Error("Invalid JSON-pointer: " + $data);
      up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer == "#") {
        if (up >= lvl)
          throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
        return paths[lvl - up];
      }
      if (up > lvl)
        throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
      data = "data" + (lvl - up || "");
      if (!jsonPointer)
        return data;
    }
    var expr = data;
    var segments = jsonPointer.split("/");
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment) {
        data += getProperty(unescapeJsonPointer(segment));
        expr += " && " + data;
      }
    }
    return expr;
  }
  function joinPaths(a, b) {
    if (a == '""')
      return b;
    return (a + " + " + b).replace(/' \+ '/g, "");
  }
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS((exports2, module2) => {
  "use strict";
  var util = require_util2();
  module2.exports = SchemaObject;
  function SchemaObject(obj) {
    util.copy(obj, this);
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports2, module2) => {
  "use strict";
  var traverse = module2.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS((exports2, module2) => {
  "use strict";
  var URI = require_uri_all();
  var equal = require_fast_deep_equal();
  var util = require_util2();
  var SchemaObject = require_schema_obj();
  var traverse = require_json_schema_traverse();
  module2.exports = resolve;
  resolve.normalizeId = normalizeId;
  resolve.fullPath = getFullPath;
  resolve.url = resolveUrl;
  resolve.ids = resolveIds;
  resolve.inlineRef = inlineRef;
  resolve.schema = resolveSchema;
  function resolve(compile, root2, ref) {
    var refVal = this._refs[ref];
    if (typeof refVal == "string") {
      if (this._refs[refVal])
        refVal = this._refs[refVal];
      else
        return resolve.call(this, compile, root2, refVal);
    }
    refVal = refVal || this._schemas[ref];
    if (refVal instanceof SchemaObject) {
      return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    }
    var res = resolveSchema.call(this, root2, ref);
    var schema, v, baseId;
    if (res) {
      schema = res.schema;
      root2 = res.root;
      baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) {
      v = schema.validate || compile.call(this, schema.schema, root2, void 0, baseId);
    } else if (schema !== void 0) {
      v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root2, void 0, baseId);
    }
    return v;
  }
  function resolveSchema(root2, ref) {
    var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root2.schema));
    if (Object.keys(root2.schema).length === 0 || refPath !== baseId) {
      var id = normalizeId(refPath);
      var refVal = this._refs[id];
      if (typeof refVal == "string") {
        return resolveRecursive.call(this, root2, refVal, p);
      } else if (refVal instanceof SchemaObject) {
        if (!refVal.validate)
          this._compile(refVal);
        root2 = refVal;
      } else {
        refVal = this._schemas[id];
        if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          if (id == normalizeId(ref))
            return {schema: refVal, root: root2, baseId};
          root2 = refVal;
        } else {
          return;
        }
      }
      if (!root2.schema)
        return;
      baseId = getFullPath(this._getId(root2.schema));
    }
    return getJsonPointer.call(this, p, baseId, root2.schema, root2);
  }
  function resolveRecursive(root2, ref, parsedRef) {
    var res = resolveSchema.call(this, root2, ref);
    if (res) {
      var schema = res.schema;
      var baseId = res.baseId;
      root2 = res.root;
      var id = this._getId(schema);
      if (id)
        baseId = resolveUrl(baseId, id);
      return getJsonPointer.call(this, parsedRef, baseId, schema, root2);
    }
  }
  var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function getJsonPointer(parsedRef, baseId, schema, root2) {
    parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/")
      return;
    var parts = parsedRef.fragment.split("/");
    for (var i = 1; i < parts.length; i++) {
      var part = parts[i];
      if (part) {
        part = util.unescapeFragment(part);
        schema = schema[part];
        if (schema === void 0)
          break;
        var id;
        if (!PREVENT_SCOPE_CHANGE[part]) {
          id = this._getId(schema);
          if (id)
            baseId = resolveUrl(baseId, id);
          if (schema.$ref) {
            var $ref = resolveUrl(baseId, schema.$ref);
            var res = resolveSchema.call(this, root2, $ref);
            if (res) {
              schema = res.schema;
              root2 = res.root;
              baseId = res.baseId;
            }
          }
        }
      }
    }
    if (schema !== void 0 && schema !== root2.schema)
      return {schema, root: root2, baseId};
  }
  var SIMPLE_INLINED = util.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function inlineRef(schema, limit) {
    if (limit === false)
      return false;
    if (limit === void 0 || limit === true)
      return checkNoRef(schema);
    else if (limit)
      return countKeys(schema) <= limit;
  }
  function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object" && !checkNoRef(item))
          return false;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref")
          return false;
        item = schema[key];
        if (typeof item == "object" && !checkNoRef(item))
          return false;
      }
    }
    return true;
  }
  function countKeys(schema) {
    var count = 0, item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object")
          count += countKeys(item);
        if (count == Infinity)
          return Infinity;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref")
          return Infinity;
        if (SIMPLE_INLINED[key]) {
          count++;
        } else {
          item = schema[key];
          if (typeof item == "object")
            count += countKeys(item) + 1;
          if (count == Infinity)
            return Infinity;
        }
      }
    }
    return count;
  }
  function getFullPath(id, normalize) {
    if (normalize !== false)
      id = normalizeId(id);
    var p = URI.parse(id);
    return _getFullPath(p);
  }
  function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
  }
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
  }
  function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = {"": schemaId};
    var fullPaths = {"": getFullPath(schemaId, false)};
    var localRefs = {};
    var self2 = this;
    traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (jsonPtr === "")
        return;
      var id = self2._getId(sch);
      var baseId = baseIds[parentJsonPtr];
      var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
      if (keyIndex !== void 0)
        fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
      if (typeof id == "string") {
        id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
        var refVal = self2._refs[id];
        if (typeof refVal == "string")
          refVal = self2._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal(sch, refVal.schema))
            throw new Error('id "' + id + '" resolves to more than one schema');
        } else if (id != normalizeId(fullPath)) {
          if (id[0] == "#") {
            if (localRefs[id] && !equal(sch, localRefs[id]))
              throw new Error('id "' + id + '" resolves to more than one schema');
            localRefs[id] = sch;
          } else {
            self2._refs[id] = fullPath;
          }
        }
      }
      baseIds[jsonPtr] = baseId;
      fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS((exports2, module2) => {
  "use strict";
  var resolve = require_resolve();
  module2.exports = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
  };
  function ValidationError(errors) {
    this.message = "validation failed";
    this.errors = errors;
    this.ajv = this.validation = true;
  }
  MissingRefError.message = function(baseId, ref) {
    return "can't resolve reference " + ref + " from id " + baseId;
  };
  function MissingRefError(baseId, ref, message) {
    this.message = message || MissingRefError.message(baseId, ref);
    this.missingRef = resolve.url(baseId, ref);
    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
  }
  function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(data, opts) {
    if (!opts)
      opts = {};
    if (typeof opts === "function")
      opts = {cmp: opts};
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
      return function(node) {
        return function(a, b) {
          var aobj = {key: a, value: node[a]};
          var bobj = {key: b, value: node[b]};
          return f(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === void 0)
        return;
      if (typeof node == "number")
        return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object")
        return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0; i < node.length; i++) {
          if (i)
            out += ",";
          out += stringify(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null)
        return "null";
      if (seen.indexOf(node) !== -1) {
        if (cycles)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = stringify(node[key]);
        if (!value)
          continue;
        if (out)
          out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data);
  };
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_validate(it, $keyword, $ruleType) {
    var out = "";
    var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
    if (it.opts.strictKeywords) {
      var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
      if ($unknownKwd) {
        var $keywordsMsg = "unknown keyword: " + $unknownKwd;
        if (it.opts.strictKeywords === "log")
          it.logger.warn($keywordsMsg);
        else
          throw new Error($keywordsMsg);
      }
    }
    if (it.isTop) {
      out += " var validate = ";
      if ($async) {
        it.async = true;
        out += "async ";
      }
      out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
      if ($id && (it.opts.sourceCode || it.opts.processCode)) {
        out += " " + ("/*# sourceURL=" + $id + " */") + " ";
      }
    }
    if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
      var $keyword = "false schema";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      if (it.schema === false) {
        if (it.isTop) {
          $breakOnError = true;
        } else {
          out += " var " + $valid + " = false; ";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'boolean schema is false' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        if (it.isTop) {
          if ($async) {
            out += " return data; ";
          } else {
            out += " validate.errors = null; return true; ";
          }
        } else {
          out += " var " + $valid + " = true; ";
        }
      }
      if (it.isTop) {
        out += " }; return validate; ";
      }
      return out;
    }
    if (it.isTop) {
      var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
      it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
      it.baseId = it.baseId || it.rootId;
      delete it.isTop;
      it.dataPathArr = [void 0];
      if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
        var $defaultMsg = "default is ignored in the schema root";
        if (it.opts.strictDefaults === "log")
          it.logger.warn($defaultMsg);
        else
          throw new Error($defaultMsg);
      }
      out += " var vErrors = null; ";
      out += " var errors = 0;     ";
      out += " if (rootData === undefined) rootData = data; ";
    } else {
      var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
      if ($id)
        it.baseId = it.resolve.url(it.baseId, $id);
      if ($async && !it.async)
        throw new Error("async schema in sync schema");
      out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
      if ($typeIsArray) {
        if ($typeSchema.indexOf("null") == -1)
          $typeSchema = $typeSchema.concat("null");
      } else if ($typeSchema != "null") {
        $typeSchema = [$typeSchema, "null"];
        $typeIsArray = true;
      }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
      $typeSchema = $typeSchema[0];
      $typeIsArray = false;
    }
    if (it.schema.$ref && $refKeywords) {
      if (it.opts.extendRefs == "fail") {
        throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
      } else if (it.opts.extendRefs !== true) {
        $refKeywords = false;
        it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
      }
    }
    if (it.schema.$comment && it.opts.$comment) {
      out += " " + it.RULES.all.$comment.code(it, "$comment");
    }
    if ($typeSchema) {
      if (it.opts.coerceTypes) {
        var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
      }
      var $rulesGroup = it.RULES.types[$typeSchema];
      if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
        out += " if (" + it.util[$method]($typeSchema, $data, true) + ") { ";
        if ($coerceToTypes) {
          var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
          out += " var " + $dataType + " = typeof " + $data + "; ";
          if (it.opts.coerceTypes == "array") {
            out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ")) " + $dataType + " = 'array'; ";
          }
          out += " var " + $coerced + " = undefined; ";
          var $bracesCoercion = "";
          var arr1 = $coerceToTypes;
          if (arr1) {
            var $type, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $type = arr1[$i += 1];
              if ($i) {
                out += " if (" + $coerced + " === undefined) { ";
                $bracesCoercion += "}";
              }
              if (it.opts.coerceTypes == "array" && $type != "array") {
                out += " if (" + $dataType + " == 'array' && " + $data + ".length == 1) { " + $coerced + " = " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + ";  } ";
              }
              if ($type == "string") {
                out += " if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
              } else if ($type == "number" || $type == "integer") {
                out += " if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                if ($type == "integer") {
                  out += " && !(" + $data + " % 1)";
                }
                out += ")) " + $coerced + " = +" + $data + "; ";
              } else if ($type == "boolean") {
                out += " if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
              } else if ($type == "null") {
                out += " if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
              } else if (it.opts.coerceTypes == "array" && $type == "array") {
                out += " if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
              }
            }
          }
          out += " " + $bracesCoercion + " if (" + $coerced + " === undefined) {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else {  ";
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " " + $data + " = " + $coerced + "; ";
          if (!$dataLvl) {
            out += "if (" + $parentData + " !== undefined)";
          }
          out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        }
        out += " } ";
      }
    }
    if (it.schema.$ref && !$refKeywords) {
      out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
      if ($breakOnError) {
        out += " } if (errors === ";
        if ($top) {
          out += "0";
        } else {
          out += "errs_" + $lvl;
        }
        out += ") { ";
        $closingBraces2 += "}";
      }
    } else {
      var arr2 = it.RULES;
      if (arr2) {
        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
        while (i2 < l2) {
          $rulesGroup = arr2[i2 += 1];
          if ($shouldUseGroup($rulesGroup)) {
            if ($rulesGroup.type) {
              out += " if (" + it.util.checkDataType($rulesGroup.type, $data) + ") { ";
            }
            if (it.opts.useDefaults) {
              if ($rulesGroup.type == "object" && it.schema.properties) {
                var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                var arr3 = $schemaKeys;
                if (arr3) {
                  var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                  while (i3 < l3) {
                    $propertyKey = arr3[i3 += 1];
                    var $sch = $schema[$propertyKey];
                    if ($sch.default !== void 0) {
                      var $passData = $data + it.util.getProperty($propertyKey);
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log")
                            it.logger.warn($defaultMsg);
                          else
                            throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                var arr4 = it.schema.items;
                if (arr4) {
                  var $sch, $i = -1, l4 = arr4.length - 1;
                  while ($i < l4) {
                    $sch = arr4[$i += 1];
                    if ($sch.default !== void 0) {
                      var $passData = $data + "[" + $i + "]";
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log")
                            it.logger.warn($defaultMsg);
                          else
                            throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              }
            }
            var arr5 = $rulesGroup.rules;
            if (arr5) {
              var $rule, i5 = -1, l5 = arr5.length - 1;
              while (i5 < l5) {
                $rule = arr5[i5 += 1];
                if ($shouldUseRule($rule)) {
                  var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                  if ($code) {
                    out += " " + $code + " ";
                    if ($breakOnError) {
                      $closingBraces1 += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces1 + " ";
              $closingBraces1 = "";
            }
            if ($rulesGroup.type) {
              out += " } ";
              if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                out += " else { ";
                var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should be ";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                out += " } ";
              }
            }
            if ($breakOnError) {
              out += " if (errors === ";
              if ($top) {
                out += "0";
              } else {
                out += "errs_" + $lvl;
              }
              out += ") { ";
              $closingBraces2 += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces2 + " ";
    }
    if ($top) {
      if ($async) {
        out += " if (errors === 0) return data;           ";
        out += " else throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; ";
        out += " return errors === 0;       ";
      }
      out += " }; return validate;";
    } else {
      out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    }
    out = it.util.cleanUpCode(out);
    if ($top) {
      out = it.util.finalCleanUpCode(out, $async);
    }
    function $shouldUseGroup($rulesGroup2) {
      var rules2 = $rulesGroup2.rules;
      for (var i = 0; i < rules2.length; i++)
        if ($shouldUseRule(rules2[i]))
          return true;
    }
    function $shouldUseRule($rule2) {
      return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
    }
    function $ruleImplementsSomeKeyword($rule2) {
      var impl = $rule2.implements;
      for (var i = 0; i < impl.length; i++)
        if (it.schema[impl[i]] !== void 0)
          return true;
    }
    return out;
  };
});

// node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS((exports2, module2) => {
  "use strict";
  var resolve = require_resolve();
  var util = require_util2();
  var errorClasses = require_error_classes();
  var stableStringify = require_fast_json_stable_stringify();
  var validateGenerator = require_validate2();
  var ucs2length = util.ucs2length;
  var equal = require_fast_deep_equal();
  var ValidationError = errorClasses.Validation;
  module2.exports = compile;
  function compile(schema, root2, localRefs, baseId) {
    var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
    root2 = root2 || {schema, refVal, refs};
    var c = checkCompiling.call(this, schema, root2, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling)
      return compilation.callValidate = callValidate;
    var formats = this._formats;
    var RULES = this.RULES;
    try {
      var v = localCompile(schema, root2, localRefs, baseId);
      compilation.validate = v;
      var cv = compilation.callValidate;
      if (cv) {
        cv.schema = v.schema;
        cv.errors = null;
        cv.refs = v.refs;
        cv.refVal = v.refVal;
        cv.root = v.root;
        cv.$async = v.$async;
        if (opts.sourceCode)
          cv.source = v.source;
      }
      return v;
    } finally {
      endCompiling.call(this, schema, root2, baseId);
    }
    function callValidate() {
      var validate = compilation.validate;
      var result = validate.apply(this, arguments);
      callValidate.errors = validate.errors;
      return result;
    }
    function localCompile(_schema, _root, localRefs2, baseId2) {
      var isRoot = !_root || _root && _root.schema == _schema;
      if (_root.schema != root2.schema)
        return compile.call(self2, _schema, _root, localRefs2, baseId2);
      var $async = _schema.$async === true;
      var sourceCode = validateGenerator({
        isTop: true,
        schema: _schema,
        isRoot,
        baseId: baseId2,
        root: _root,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: errorClasses.MissingRef,
        RULES,
        validate: validateGenerator,
        util,
        resolve,
        resolveRef,
        usePattern,
        useDefault,
        useCustomRule,
        opts,
        formats,
        logger: self2.logger,
        self: self2
      });
      sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
      if (opts.processCode)
        sourceCode = opts.processCode(sourceCode);
      var validate;
      try {
        var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
        validate = makeValidate(self2, RULES, formats, root2, refVal, defaults, customRules, equal, ucs2length, ValidationError);
        refVal[0] = validate;
      } catch (e) {
        self2.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      }
      validate.schema = _schema;
      validate.errors = null;
      validate.refs = refs;
      validate.refVal = refVal;
      validate.root = isRoot ? validate : _root;
      if ($async)
        validate.$async = true;
      if (opts.sourceCode === true) {
        validate.source = {
          code: sourceCode,
          patterns,
          defaults
        };
      }
      return validate;
    }
    function resolveRef(baseId2, ref, isRoot) {
      ref = resolve.url(baseId2, ref);
      var refIndex = refs[ref];
      var _refVal, refCode;
      if (refIndex !== void 0) {
        _refVal = refVal[refIndex];
        refCode = "refVal[" + refIndex + "]";
        return resolvedRef(_refVal, refCode);
      }
      if (!isRoot && root2.refs) {
        var rootRefId = root2.refs[ref];
        if (rootRefId !== void 0) {
          _refVal = root2.refVal[rootRefId];
          refCode = addLocalRef(ref, _refVal);
          return resolvedRef(_refVal, refCode);
        }
      }
      refCode = addLocalRef(ref);
      var v2 = resolve.call(self2, localCompile, root2, ref);
      if (v2 === void 0) {
        var localSchema = localRefs && localRefs[ref];
        if (localSchema) {
          v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root2, localRefs, baseId2);
        }
      }
      if (v2 === void 0) {
        removeLocalRef(ref);
      } else {
        replaceLocalRef(ref, v2);
        return resolvedRef(v2, refCode);
      }
    }
    function addLocalRef(ref, v2) {
      var refId = refVal.length;
      refVal[refId] = v2;
      refs[ref] = refId;
      return "refVal" + refId;
    }
    function removeLocalRef(ref) {
      delete refs[ref];
    }
    function replaceLocalRef(ref, v2) {
      var refId = refs[ref];
      refVal[refId] = v2;
    }
    function resolvedRef(refVal2, code) {
      return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? {code, schema: refVal2, inline: true} : {code, $async: refVal2 && !!refVal2.$async};
    }
    function usePattern(regexStr) {
      var index = patternsHash[regexStr];
      if (index === void 0) {
        index = patternsHash[regexStr] = patterns.length;
        patterns[index] = regexStr;
      }
      return "pattern" + index;
    }
    function useDefault(value) {
      switch (typeof value) {
        case "boolean":
        case "number":
          return "" + value;
        case "string":
          return util.toQuotedString(value);
        case "object":
          if (value === null)
            return "null";
          var valueStr = stableStringify(value);
          var index = defaultsHash[valueStr];
          if (index === void 0) {
            index = defaultsHash[valueStr] = defaults.length;
            defaults[index] = value;
          }
          return "default" + index;
      }
    }
    function useCustomRule(rule, schema2, parentSchema, it) {
      if (self2._opts.validateSchema !== false) {
        var deps = rule.definition.dependencies;
        if (deps && !deps.every(function(keyword) {
          return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
        }))
          throw new Error("parent schema must have all required keywords: " + deps.join(","));
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == "log")
              self2.logger.error(message);
            else
              throw new Error(message);
          }
        }
      }
      var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
      var validate;
      if (compile2) {
        validate = compile2.call(self2, schema2, parentSchema, it);
      } else if (macro) {
        validate = macro.call(self2, schema2, parentSchema, it);
        if (opts.validateSchema !== false)
          self2.validateSchema(validate, true);
      } else if (inline) {
        validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
      } else {
        validate = rule.definition.validate;
        if (!validate)
          return;
      }
      if (validate === void 0)
        throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
      var index = customRules.length;
      customRules[index] = validate;
      return {
        code: "customRule" + index,
        validate
      };
    }
  }
  function checkCompiling(schema, root2, baseId) {
    var index = compIndex.call(this, schema, root2, baseId);
    if (index >= 0)
      return {index, compiling: true};
    index = this._compilations.length;
    this._compilations[index] = {
      schema,
      root: root2,
      baseId
    };
    return {index, compiling: false};
  }
  function endCompiling(schema, root2, baseId) {
    var i = compIndex.call(this, schema, root2, baseId);
    if (i >= 0)
      this._compilations.splice(i, 1);
  }
  function compIndex(schema, root2, baseId) {
    for (var i = 0; i < this._compilations.length; i++) {
      var c = this._compilations[i];
      if (c.schema == schema && c.root == root2 && c.baseId == baseId)
        return i;
    }
    return -1;
  }
  function patternCode(i, patterns) {
    return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
  }
  function defaultCode(i) {
    return "var default" + i + " = defaults[" + i + "];";
  }
  function refValCode(i, refVal) {
    return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
  }
  function customRuleCode(i) {
    return "var customRule" + i + " = customRules[" + i + "];";
  }
  function vars(arr, statement) {
    if (!arr.length)
      return "";
    var code = "";
    for (var i = 0; i < arr.length; i++)
      code += statement(i, arr);
    return code;
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS((exports2, module2) => {
  "use strict";
  var Cache = module2.exports = function Cache2() {
    this._cache = {};
  };
  Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
  };
  Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
  };
  Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
  };
  Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
  };
});

// node_modules/ajv/lib/compile/formats.js
var require_formats2 = __commonJS((exports2, module2) => {
  "use strict";
  var util = require_util2();
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
  var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
  var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
  var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  module2.exports = formats;
  function formats(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util.copy(formats[mode]);
  }
  formats.fast = {
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
    uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  formats.full = {
    date,
    time,
    "date-time": date_time,
    uri,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function date(str) {
    var matches = str.match(DATE);
    if (!matches)
      return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function time(str, full) {
    var matches = str.match(TIME);
    if (!matches)
      return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function hostname(str) {
    return str.length <= 255 && HOSTNAME.test(str);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_ref(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema == "#" || $schema == "#/") {
      if (it.isRoot) {
        $async = it.async;
        $refCode = "validate";
      } else {
        $async = it.root.schema.$async === true;
        $refCode = "root.refVal[0]";
      }
    } else {
      var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
      if ($refVal === void 0) {
        var $message = it.MissingRefError.message(it.baseId, $schema);
        if (it.opts.missingRefs == "fail") {
          it.logger.error($message);
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          if ($breakOnError) {
            out += " if (false) { ";
          }
        } else if (it.opts.missingRefs == "ignore") {
          it.logger.warn($message);
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          throw new it.MissingRefError(it.baseId, $schema, $message);
        }
      } else if ($refVal.inline) {
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $refVal.schema;
        $it.schemaPath = "";
        $it.errSchemaPath = $schema;
        var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
        out += " " + $code + " ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
        }
      } else {
        $async = $refVal.$async === true || it.async && $refVal.$async !== false;
        $refCode = $refVal.code;
      }
    }
    if ($refCode) {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.opts.passContext) {
        out += " " + $refCode + ".call(this, ";
      } else {
        out += " " + $refCode + "( ";
      }
      out += " " + $data + ", (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
      var __callValidate = out;
      out = $$outStack.pop();
      if ($async) {
        if (!it.async)
          throw new Error("async schema referenced by sync schema");
        if ($breakOnError) {
          out += " var " + $valid + "; ";
        }
        out += " try { await " + __callValidate + "; ";
        if ($breakOnError) {
          out += " " + $valid + " = true; ";
        }
        out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
        if ($breakOnError) {
          out += " " + $valid + " = false; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " if (" + $valid + ") { ";
        }
      } else {
        out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_allOf(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all)) {
          $allSchemasEmpty = false;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($breakOnError) {
      if ($allSchemasEmpty) {
        out += " if (true) { ";
      } else {
        out += " " + $closingBraces.slice(0, -1) + " ";
      }
    }
    out = it.util.cleanUpCode(out);
    return out;
  };
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_anyOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema.every(function($sch2) {
      return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 : it.util.schemaHasRules($sch2, it.RULES.all);
    });
    if ($noEmptySchema) {
      var $currentBaseId = $it.baseId;
      out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
          $closingBraces += "}";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match some schema in anyOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
      out = it.util.cleanUpCode(out);
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_comment(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $comment = it.util.toQuotedString($schema);
    if (it.opts.$comment === true) {
      out += " console.log(" + $comment + ");";
    } else if (typeof it.opts.$comment == "function") {
      out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_const(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!$isData) {
      out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to constant' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_contains(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      out += " if (" + $nextValid + ") break; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else {
      out += " if (" + $data + ".length == 0) {";
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should contain a valid item' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else { ";
    if ($nonEmptySchema) {
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    }
    if (it.opts.allErrors) {
      out += " } ";
    }
    out = it.util.cleanUpCode(out);
    return out;
  };
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_dependencies(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
    for ($property in $schema) {
      var $sch = $schema[$property];
      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
      $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it.errorPath;
    out += "var missing" + $lvl + ";";
    for (var $property in $propertyDeps) {
      $deps = $propertyDeps[$property];
      if ($deps.length) {
        out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        if ($breakOnError) {
          out += " && ( ";
          var arr1 = $deps;
          if (arr1) {
            var $propertyKey, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $propertyKey = arr1[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ")) {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should have ";
              if ($deps.length == 1) {
                out += "property " + it.util.escapeQuotes($deps[0]);
              } else {
                out += "properties " + it.util.escapeQuotes($deps.join(", "));
              }
              out += " when property " + it.util.escapeQuotes($property) + " is present' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          out += " ) { ";
          var arr2 = $deps;
          if (arr2) {
            var $propertyKey, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $propertyKey = arr2[i2 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
        out += " }   ";
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
    }
    it.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for (var $property in $schemaDeps) {
      var $sch = $schemaDeps[$property];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all)) {
        out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        out += ") { ";
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + it.util.getProperty($property);
        $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
    if ($breakOnError) {
      out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    out = it.util.cleanUpCode(out);
    return out;
  };
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_enum(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) {
      out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + ";";
    if ($isData) {
      out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    }
    out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to one of the allowed values' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_format(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it.opts.format === false) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
      var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
      out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
      if (it.async) {
        out += " var async" + $lvl + " = " + $format + ".async; ";
      }
      out += " " + $format + " = " + $format + ".validate; } if (  ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " (";
      if ($unknownFormats != "ignore") {
        out += " (" + $schemaValue + " && !" + $format + " ";
        if ($allowUnknown) {
          out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
        }
        out += ") || ";
      }
      out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
      if (it.async) {
        out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
      } else {
        out += " " + $format + "(" + $data + ") ";
      }
      out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
      var $format = it.formats[$schema];
      if (!$format) {
        if ($unknownFormats == "ignore") {
          it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else {
          throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
        }
      }
      var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
      var $formatType = $isObject && $format.type || "string";
      if ($isObject) {
        var $async = $format.async === true;
        $format = $format.validate;
      }
      if ($formatType != $ruleType) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      if ($async) {
        if (!it.async)
          throw new Error("async format in sync schema");
        var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
        out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
      } else {
        out += " if (! ";
        var $formatRef = "formats" + it.util.getProperty($schema);
        if ($isObject)
          $formatRef += ".validate";
        if (typeof $format == "function") {
          out += " " + $formatRef + "(" + $data + ") ";
        } else {
          out += " " + $formatRef + ".test(" + $data + ") ";
        }
        out += ") { ";
      }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match format "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_if(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
      var $ifClause;
      $it.createErrors = false;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      $it.createErrors = true;
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      if ($thenPresent) {
        out += " if (" + $nextValid + ") {  ";
        $it.schema = it.schema["then"];
        $it.schemaPath = it.schemaPath + ".then";
        $it.errSchemaPath = it.errSchemaPath + "/then";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'then'; ";
        } else {
          $ifClause = "'then'";
        }
        out += " } ";
        if ($elsePresent) {
          out += " else { ";
        }
      } else {
        out += " if (!" + $nextValid + ") { ";
      }
      if ($elsePresent) {
        $it.schema = it.schema["else"];
        $it.schemaPath = it.schemaPath + ".else";
        $it.errSchemaPath = it.errSchemaPath + "/else";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'else'; ";
        } else {
          $ifClause = "'else'";
        }
        out += " } ";
      }
      out += " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " }   ";
      if ($breakOnError) {
        out += " else { ";
      }
      out = it.util.cleanUpCode(out);
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_items(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema)) {
      var $additionalItems = it.schema.additionalItems;
      if ($additionalItems === false) {
        out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
        var $currErrSchemaPath = $errSchemaPath;
        $errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have more than " + $schema.length + " items' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        $errSchemaPath = $currErrSchemaPath;
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
            var $passData = $data + "[" + $i + "]";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
            $it.dataPathArr[$dataNxt] = $i;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
        $it.schema = $additionalItems;
        $it.schemaPath = it.schemaPath + ".additionalItems";
        $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " } }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    out = it.util.cleanUpCode(out);
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limit(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
    if ($isDataExcl) {
      var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
      out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
      $schemaValueExcl = "schemaExcl" + $lvl;
      out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
      var $errorKeyword = $exclusiveKeyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
      if ($schema === void 0) {
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaValueExcl;
        $isData = $isDataExcl;
      }
    } else {
      var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
      if ($exclIsNumber && $isData) {
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
      } else {
        if ($exclIsNumber && $schema === void 0) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaExcl;
          $notOp += "=";
        } else {
          if ($exclIsNumber)
            $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $notOp += "=";
          } else {
            $exclusive = false;
            $opStr += "=";
          }
        }
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
      }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be " + $opStr + " ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limitItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxItems") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " items' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limitLength(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    if (it.opts.unicode === false) {
      out += " " + $data + ".length ";
    } else {
      out += " ucs2length(" + $data + ") ";
    }
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be ";
        if ($keyword == "maxLength") {
          out += "longer";
        } else {
          out += "shorter";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " characters' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limitProperties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxProperties") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " properties' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_multipleOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    out += "var division" + $lvl + ";if (";
    if ($isData) {
      out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    }
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it.opts.multipleOfPrecision) {
      out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
    } else {
      out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    }
    out += " ) ";
    if ($isData) {
      out += "  )  ";
    }
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be multiple of ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_not(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.createErrors = false;
      var $allErrorsOption;
      if ($it.opts.allErrors) {
        $allErrorsOption = $it.opts.allErrors;
        $it.opts.allErrors = false;
      }
      out += " " + it.validate($it) + " ";
      $it.createErrors = true;
      if ($allErrorsOption)
        $it.opts.allErrors = $allErrorsOption;
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (" + $nextValid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
    } else {
      out += "  var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if ($breakOnError) {
        out += " if (false) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_oneOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
        } else {
          out += " var " + $nextValid + " = true; ";
        }
        if ($i) {
          out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
          $closingBraces += "}";
        }
        out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should match exactly one schema in oneOf' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_pattern(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " !" + $regexp + ".test(" + $data + ") ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match pattern "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_properties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema || {}), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    var $required = it.schema.required;
    if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired)
      var $requiredHash = it.util.toHash($required);
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined;";
    }
    if ($checkAdditional) {
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      if ($someProperties) {
        out += " var isAdditional" + $lvl + " = !(false ";
        if ($schemaKeys.length) {
          if ($schemaKeys.length > 8) {
            out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
          } else {
            var arr1 = $schemaKeys;
            if (arr1) {
              var $propertyKey, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $propertyKey = arr1[i1 += 1];
                out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr2 = $pPropertyKeys;
          if (arr2) {
            var $pProperty, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $pProperty = arr2[$i += 1];
              out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
            }
          }
        }
        out += " ); if (isAdditional" + $lvl + ") { ";
      }
      if ($removeAdditional == "all") {
        out += " delete " + $data + "[" + $key + "]; ";
      } else {
        var $currentErrorPath = it.errorPath;
        var $additionalProperty = "' + " + $key + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
        }
        if ($noAdditional) {
          if ($removeAdditional) {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            out += " " + $nextValid + " = false; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalProperties";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is an invalid additional property";
                } else {
                  out += "should NOT have additional properties";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += " break; ";
            }
          }
        } else if ($additionalIsSchema) {
          if ($removeAdditional == "failing") {
            out += " var " + $errs + " = errors;  ";
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
            it.compositeRule = $it.compositeRule = $wasComposite;
          } else {
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
          }
        }
        it.errorPath = $currentErrorPath;
      }
      if ($someProperties) {
        out += " } ";
      }
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
    var $useDefaults = it.opts.useDefaults && !it.compositeRule;
    if ($schemaKeys.length) {
      var arr3 = $schemaKeys;
      if (arr3) {
        var $propertyKey, i3 = -1, l3 = arr3.length - 1;
        while (i3 < l3) {
          $propertyKey = arr3[i3 += 1];
          var $sch = $schema[$propertyKey];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all)) {
            var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + $prop;
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
            $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
            $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              $code = it.util.varReplace($code, $nextData, $passData);
              var $useData = $passData;
            } else {
              var $useData = $nextData;
              out += " var " + $nextData + " = " + $passData + "; ";
            }
            if ($hasDefault) {
              out += " " + $code + " ";
            } else {
              if ($requiredHash && $requiredHash[$propertyKey]) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = false; ";
                var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                $errSchemaPath = it.errSchemaPath + "/required";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                it.errorPath = $currentErrorPath;
                out += " } else { ";
              } else {
                if ($breakOnError) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = true; } else { ";
                } else {
                  out += " if (" + $useData + " !== undefined ";
                  if ($ownProperties) {
                    out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += " ) { ";
                }
              }
              out += " " + $code + " } ";
            }
          }
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($pPropertyKeys.length) {
      var arr4 = $pPropertyKeys;
      if (arr4) {
        var $pProperty, i4 = -1, l4 = arr4.length - 1;
        while (i4 < l4) {
          $pProperty = arr4[i4 += 1];
          var $sch = $pProperties[$pProperty];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
            $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
            if ($ownProperties) {
              out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
            } else {
              out += " for (var " + $key + " in " + $data + ") { ";
            }
            out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else " + $nextValid + " = true; ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    out = it.util.cleanUpCode(out);
    return out;
  };
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_propertyNames(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined; ";
      }
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      out += " var startErrs" + $lvl + " = errors; ";
      var $passData = $key;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
        if (it.opts.messages !== false) {
          out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      if ($breakOnError) {
        out += " break; ";
      }
      out += " } }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    out = it.util.cleanUpCode(out);
    return out;
  };
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_required(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
      if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
        var $required = [];
        var arr1 = $schema;
        if (arr1) {
          var $property, i1 = -1, l1 = arr1.length - 1;
          while (i1 < l1) {
            $property = arr1[i1 += 1];
            var $propertySch = it.schema.properties[$property];
            if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
              $required[$required.length] = $property;
            }
          }
        }
      } else {
        var $required = $schema;
      }
    }
    if ($isData || $required.length) {
      var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
      if ($breakOnError) {
        out += " var missing" + $lvl + "; ";
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          out += " var " + $valid + " = true; ";
          if ($isData) {
            out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
          if ($ownProperties) {
            out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += "; if (!" + $valid + ") break; } ";
          if ($isData) {
            out += "  }  ";
          }
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        } else {
          out += " if ( ";
          var arr2 = $required;
          if (arr2) {
            var $propertyKey, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $propertyKey = arr2[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ") {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        }
      } else {
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          if ($isData) {
            out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
          if ($ownProperties) {
            out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += ") {  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
          if ($isData) {
            out += "  }  ";
          }
        } else {
          var arr3 = $required;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
      }
      it.errorPath = $currentErrorPath;
    } else if ($breakOnError) {
      out += " if (true) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (($schema || $isData) && it.opts.uniqueItems !== false) {
      if ($isData) {
        out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
      }
      out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
      var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
      if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
        out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
      } else {
        out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
        var $method = "checkDataType" + ($typeIsArray ? "s" : "");
        out += " if (" + it.util[$method]($itemType, "item", true) + ") continue; ";
        if ($typeIsArray) {
          out += ` if (typeof item == 'string') item = '"' + item; `;
        }
        out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      out += " } ";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    $ref: require_ref(),
    allOf: require_allOf(),
    anyOf: require_anyOf(),
    $comment: require_comment(),
    const: require_const(),
    contains: require_contains(),
    dependencies: require_dependencies(),
    enum: require_enum(),
    format: require_format(),
    if: require_if(),
    items: require_items(),
    maximum: require_limit(),
    minimum: require_limit(),
    maxItems: require_limitItems(),
    minItems: require_limitItems(),
    maxLength: require_limitLength(),
    minLength: require_limitLength(),
    maxProperties: require_limitProperties(),
    minProperties: require_limitProperties(),
    multipleOf: require_multipleOf(),
    not: require_not(),
    oneOf: require_oneOf(),
    pattern: require_pattern(),
    properties: require_properties(),
    propertyNames: require_propertyNames(),
    required: require_required(),
    uniqueItems: require_uniqueItems(),
    validate: require_validate2()
  };
});

// node_modules/ajv/lib/compile/rules.js
var require_rules2 = __commonJS((exports2, module2) => {
  "use strict";
  var ruleModules = require_dotjs();
  var toHash = require_util2().toHash;
  module2.exports = function rules2() {
    var RULES = [
      {
        type: "number",
        rules: [
          {maximum: ["exclusiveMaximum"]},
          {minimum: ["exclusiveMinimum"]},
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          {properties: ["additionalProperties", "patternProperties"]}
        ]
      },
      {rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"]}
    ];
    var ALL = ["type", "$comment"];
    var KEYWORDS = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ];
    var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
      group.rules = group.rules.map(function(keyword) {
        var implKeywords;
        if (typeof keyword == "object") {
          var key = Object.keys(keyword)[0];
          implKeywords = keyword[key];
          keyword = key;
          implKeywords.forEach(function(k) {
            ALL.push(k);
            RULES.all[k] = true;
          });
        }
        ALL.push(keyword);
        var rule = RULES.all[keyword] = {
          keyword,
          code: ruleModules[keyword],
          implements: implKeywords
        };
        return rule;
      });
      RULES.all.$comment = {
        keyword: "$comment",
        code: ruleModules.$comment
      };
      if (group.type)
        RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
  };
});

// node_modules/ajv/lib/data.js
var require_data = __commonJS((exports2, module2) => {
  "use strict";
  var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  module2.exports = function(metaSchema, keywordsJsonPointers) {
    for (var i = 0; i < keywordsJsonPointers.length; i++) {
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var segments = keywordsJsonPointers[i].split("/");
      var keywords = metaSchema;
      var j;
      for (j = 1; j < segments.length; j++)
        keywords = keywords[segments[j]];
      for (j = 0; j < KEYWORDS.length; j++) {
        var key = KEYWORDS[j];
        var schema = keywords[key];
        if (schema) {
          keywords[key] = {
            anyOf: [
              schema,
              {$ref: "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#"}
            ]
          };
        }
      }
    }
    return metaSchema;
  };
});

// node_modules/ajv/lib/compile/async.js
var require_async2 = __commonJS((exports2, module2) => {
  "use strict";
  var MissingRefError = require_error_classes().MissingRef;
  module2.exports = compileAsync;
  function compileAsync(schema, meta, callback) {
    var self2 = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    if (typeof meta == "function") {
      callback = meta;
      meta = void 0;
    }
    var p = loadMetaSchemaOf(schema).then(function() {
      var schemaObj = self2._addSchema(schema, void 0, meta);
      return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) {
      p.then(function(v) {
        callback(null, v);
      }, callback);
    }
    return p;
    function loadMetaSchemaOf(sch) {
      var $schema = sch.$schema;
      return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, {$ref: $schema}, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
      try {
        return self2._compile(schemaObj);
      } catch (e) {
        if (e instanceof MissingRefError)
          return loadMissingSchema(e);
        throw e;
      }
      function loadMissingSchema(e) {
        var ref = e.missingSchema;
        if (added(ref))
          throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
        var schemaPromise = self2._loadingSchemas[ref];
        if (!schemaPromise) {
          schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
          schemaPromise.then(removePromise, removePromise);
        }
        return schemaPromise.then(function(sch) {
          if (!added(ref)) {
            return loadMetaSchemaOf(sch).then(function() {
              if (!added(ref))
                self2.addSchema(sch, ref, void 0, meta);
            });
          }
        }).then(function() {
          return _compileAsync(schemaObj);
        });
        function removePromise() {
          delete self2._loadingSchemas[ref];
        }
        function added(ref2) {
          return self2._refs[ref2] || self2._schemas[ref2];
        }
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_custom(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
      $validateCode = "keywordValidate" + $lvl;
      var $validateSchema = $rDef.validateSchema;
      out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
      $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
      if (!$ruleValidate)
        return;
      $schemaValue = "validate.schema" + $schemaPath;
      $validateCode = $ruleValidate.code;
      $compile = $rDef.compile;
      $inline = $rDef.inline;
      $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it.async)
      throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) {
      out += "" + $ruleErrs + " = null;";
    }
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
      $closingBraces += "}";
      out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
      if ($validateSchema) {
        $closingBraces += "}";
        out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
      }
    }
    if ($inline) {
      if ($rDef.statements) {
        out += " " + $ruleValidate.validate + " ";
      } else {
        out += " " + $valid + " = " + $ruleValidate.validate + "; ";
      }
    } else if ($macro) {
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $ruleValidate.validate;
      $it.schemaPath = "";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $code;
    } else {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      out += "  " + $validateCode + ".call( ";
      if (it.opts.passContext) {
        out += "this";
      } else {
        out += "self";
      }
      if ($compile || $rDef.schema === false) {
        out += " , " + $data + " ";
      } else {
        out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
      }
      out += " , (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
      var def_callRuleValidate = out;
      out = $$outStack.pop();
      if ($rDef.errors === false) {
        out += " " + $valid + " = ";
        if ($asyncKeyword) {
          out += "await ";
        }
        out += "" + def_callRuleValidate + "; ";
      } else {
        if ($asyncKeyword) {
          $ruleErrs = "customErrors" + $lvl;
          out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else {
          out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
        }
      }
    }
    if ($rDef.modifying) {
      out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    }
    out += "" + $closingBraces;
    if ($rDef.valid) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    } else {
      out += " if ( ";
      if ($rDef.valid === void 0) {
        out += " !";
        if ($macro) {
          out += "" + $nextValid;
        } else {
          out += "" + $valid;
        }
      } else {
        out += " " + !$rDef.valid + " ";
      }
      out += ") { ";
      $errorKeyword = $rule.keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      var def_customError = out;
      out = $$outStack.pop();
      if ($inline) {
        if ($rDef.errors) {
          if ($rDef.errors != "full") {
            out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } ";
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } ";
          }
        }
      } else if ($macro) {
        out += "   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } else { " + def_customError + " } ";
        }
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {$ref: "#"}
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [
          {$ref: "#/definitions/nonNegativeInteger"},
          {default: 0}
        ]
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: {type: "string"},
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: {$ref: "#/definitions/nonNegativeInteger"},
      minLength: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {$ref: "#"},
      items: {
        anyOf: [
          {$ref: "#"},
          {$ref: "#/definitions/schemaArray"}
        ],
        default: true
      },
      maxItems: {$ref: "#/definitions/nonNegativeInteger"},
      minItems: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: {$ref: "#"},
      maxProperties: {$ref: "#/definitions/nonNegativeInteger"},
      minProperties: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      required: {$ref: "#/definitions/stringArray"},
      additionalProperties: {$ref: "#"},
      definitions: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        propertyNames: {format: "regex"},
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            {$ref: "#"},
            {$ref: "#/definitions/stringArray"}
          ]
        }
      },
      propertyNames: {$ref: "#"},
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          {$ref: "#/definitions/simpleTypes"},
          {
            type: "array",
            items: {$ref: "#/definitions/simpleTypes"},
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: {type: "string"},
      contentMediaType: {type: "string"},
      contentEncoding: {type: "string"},
      if: {$ref: "#"},
      then: {$ref: "#"},
      else: {$ref: "#"},
      allOf: {$ref: "#/definitions/schemaArray"},
      anyOf: {$ref: "#/definitions/schemaArray"},
      oneOf: {$ref: "#/definitions/schemaArray"},
      not: {$ref: "#"}
    },
    default: true
  };
});

// node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS((exports2, module2) => {
  "use strict";
  var metaSchema = require_json_schema_draft_07();
  module2.exports = {
    $id: "https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: {not: {required: ["macro"]}}
    },
    properties: {
      type: metaSchema.properties.type,
      schema: {type: "boolean"},
      statements: {type: "boolean"},
      dependencies: {
        type: "array",
        items: {type: "string"}
      },
      metaSchema: {type: "object"},
      modifying: {type: "boolean"},
      valid: {type: "boolean"},
      $data: {type: "boolean"},
      async: {type: "boolean"},
      errors: {
        anyOf: [
          {type: "boolean"},
          {const: "full"}
        ]
      }
    }
  };
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS((exports2, module2) => {
  "use strict";
  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
  var customRuleCode = require_custom();
  var definitionSchema = require_definition_schema();
  module2.exports = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
  };
  function addKeyword(keyword, definition) {
    var RULES = this.RULES;
    if (RULES.keywords[keyword])
      throw new Error("Keyword " + keyword + " is already defined");
    if (!IDENTIFIER.test(keyword))
      throw new Error("Keyword " + keyword + " is not a valid identifier");
    if (definition) {
      this.validateKeyword(definition, true);
      var dataType = definition.type;
      if (Array.isArray(dataType)) {
        for (var i = 0; i < dataType.length; i++)
          _addRule(keyword, dataType[i], definition);
      } else {
        _addRule(keyword, dataType, definition);
      }
      var metaSchema = definition.metaSchema;
      if (metaSchema) {
        if (definition.$data && this._opts.$data) {
          metaSchema = {
            anyOf: [
              metaSchema,
              {$ref: "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#"}
            ]
          };
        }
        definition.validateSchema = this.compile(metaSchema, true);
      }
    }
    RULES.keywords[keyword] = RULES.all[keyword] = true;
    function _addRule(keyword2, dataType2, definition2) {
      var ruleGroup;
      for (var i2 = 0; i2 < RULES.length; i2++) {
        var rg = RULES[i2];
        if (rg.type == dataType2) {
          ruleGroup = rg;
          break;
        }
      }
      if (!ruleGroup) {
        ruleGroup = {type: dataType2, rules: []};
        RULES.push(ruleGroup);
      }
      var rule = {
        keyword: keyword2,
        definition: definition2,
        custom: true,
        code: customRuleCode,
        implements: definition2.implements
      };
      ruleGroup.rules.push(rule);
      RULES.custom[keyword2] = rule;
    }
    return this;
  }
  function getKeyword(keyword) {
    var rule = this.RULES.custom[keyword];
    return rule ? rule.definition : this.RULES.keywords[keyword] || false;
  }
  function removeKeyword(keyword) {
    var RULES = this.RULES;
    delete RULES.keywords[keyword];
    delete RULES.all[keyword];
    delete RULES.custom[keyword];
    for (var i = 0; i < RULES.length; i++) {
      var rules2 = RULES[i].rules;
      for (var j = 0; j < rules2.length; j++) {
        if (rules2[j].keyword == keyword) {
          rules2.splice(j, 1);
          break;
        }
      }
    }
    return this;
  }
  function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v(definition))
      return true;
    validateKeyword.errors = v.errors;
    if (throwError)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
    else
      return false;
  }
});

// node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON Schema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [
          {format: "relative-json-pointer"},
          {format: "json-pointer"}
        ]
      }
    },
    additionalProperties: false
  };
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS((exports2, module2) => {
  "use strict";
  var compileSchema = require_compile();
  var resolve = require_resolve();
  var Cache = require_cache();
  var SchemaObject = require_schema_obj();
  var stableStringify = require_fast_json_stable_stringify();
  var formats = require_formats2();
  var rules2 = require_rules2();
  var $dataMetaSchema = require_data();
  var util = require_util2();
  module2.exports = Ajv;
  Ajv.prototype.validate = validate;
  Ajv.prototype.compile = compile;
  Ajv.prototype.addSchema = addSchema;
  Ajv.prototype.addMetaSchema = addMetaSchema;
  Ajv.prototype.validateSchema = validateSchema;
  Ajv.prototype.getSchema = getSchema;
  Ajv.prototype.removeSchema = removeSchema;
  Ajv.prototype.addFormat = addFormat;
  Ajv.prototype.errorsText = errorsText;
  Ajv.prototype._addSchema = _addSchema;
  Ajv.prototype._compile = _compile;
  Ajv.prototype.compileAsync = require_async2();
  var customKeyword = require_keyword();
  Ajv.prototype.addKeyword = customKeyword.add;
  Ajv.prototype.getKeyword = customKeyword.get;
  Ajv.prototype.removeKeyword = customKeyword.remove;
  Ajv.prototype.validateKeyword = customKeyword.validate;
  var errorClasses = require_error_classes();
  Ajv.ValidationError = errorClasses.Validation;
  Ajv.MissingRefError = errorClasses.MissingRef;
  Ajv.$dataMetaSchema = $dataMetaSchema;
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
  var META_SUPPORT_DATA = ["/properties"];
  function Ajv(opts) {
    if (!(this instanceof Ajv))
      return new Ajv(opts);
    opts = this._opts = util.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats(opts.format);
    this._cache = opts.cache || new Cache();
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules2();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property")
      opts._errorDataPathProperty = true;
    if (opts.serialize === void 0)
      opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats)
      addInitialFormats(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object")
      this.addMetaSchema(opts.meta);
    if (opts.nullable)
      this.addKeyword("nullable", {metaSchema: {type: "boolean"}});
    addInitialSchemas(this);
  }
  function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == "string") {
      v = this.getSchema(schemaKeyRef);
      if (!v)
        throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = this._addSchema(schemaKeyRef);
      v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data);
    if (v.$async !== true)
      this.errors = v.errors;
    return valid;
  }
  function compile(schema, _meta) {
    var schemaObj = this._addSchema(schema, void 0, _meta);
    return schemaObj.validate || this._compile(schemaObj);
  }
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++)
        this.addSchema(schema[i], void 0, _skipValidation, _meta);
      return this;
    }
    var id = this._getId(schema);
    if (id !== void 0 && typeof id != "string")
      throw new Error("schema id must be string");
    key = resolve.normalizeId(key || id);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
  }
  function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
  }
  function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema;
    if ($schema !== void 0 && typeof $schema != "string")
      throw new Error("$schema must be a string");
    $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema) {
      this.logger.warn("meta-schema not available");
      this.errors = null;
      return true;
    }
    var valid = this.validate($schema, schema);
    if (!valid && throwOrLogError) {
      var message = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log")
        this.logger.error(message);
      else
        throw new Error(message);
    }
    return valid;
  }
  function defaultMeta(self2) {
    var meta = self2._opts.meta;
    self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
    return self2._opts.defaultMeta;
  }
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch (typeof schemaObj) {
      case "object":
        return schemaObj.validate || this._compile(schemaObj);
      case "string":
        return this.getSchema(schemaObj);
      case "undefined":
        return _getSchemaFragment(this, keyRef);
    }
  }
  function _getSchemaFragment(self2, ref) {
    var res = resolve.schema.call(self2, {schema: {}}, ref);
    if (res) {
      var schema = res.schema, root2 = res.root, baseId = res.baseId;
      var v = compileSchema.call(self2, schema, root2, void 0, baseId);
      self2._fragments[ref] = new SchemaObject({
        ref,
        fragment: true,
        schema,
        root: root2,
        baseId,
        validate: v
      });
      return v;
    }
  }
  function _getSchemaObj(self2, keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
  }
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(this, this._schemas, schemaKeyRef);
      _removeAllSchemas(this, this._refs, schemaKeyRef);
      return this;
    }
    switch (typeof schemaKeyRef) {
      case "undefined":
        _removeAllSchemas(this, this._schemas);
        _removeAllSchemas(this, this._refs);
        this._cache.clear();
        return this;
      case "string":
        var schemaObj = _getSchemaObj(this, schemaKeyRef);
        if (schemaObj)
          this._cache.del(schemaObj.cacheKey);
        delete this._schemas[schemaKeyRef];
        delete this._refs[schemaKeyRef];
        return this;
      case "object":
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
        this._cache.del(cacheKey);
        var id = this._getId(schemaKeyRef);
        if (id) {
          id = resolve.normalizeId(id);
          delete this._schemas[id];
          delete this._refs[id];
        }
    }
    return this;
  }
  function _removeAllSchemas(self2, schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self2._cache.del(schemaObj.cacheKey);
        delete schemas[keyRef];
      }
    }
  }
  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean")
      throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached)
      return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id = resolve.normalizeId(this._getId(schema));
    if (id && shouldAddSchema)
      checkUnique(this, id);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
      this.validateSchema(schema, true);
    var localRefs = resolve.ids.call(this, schema);
    var schemaObj = new SchemaObject({
      id,
      schema,
      localRefs,
      cacheKey,
      meta
    });
    if (id[0] != "#" && shouldAddSchema)
      this._refs[id] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta)
      this.validateSchema(schema, true);
    return schemaObj;
  }
  function _compile(schemaObj, root2) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root2 ? root2 : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = this._opts;
      this._opts = this._metaOpts;
    }
    var v;
    try {
      v = compileSchema.call(this, schemaObj.schema, root2, schemaObj.localRefs);
    } catch (e) {
      delete schemaObj.validate;
      throw e;
    } finally {
      schemaObj.compiling = false;
      if (schemaObj.meta)
        this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(this, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }
  function chooseGetId(opts) {
    switch (opts.schemaId) {
      case "auto":
        return _get$IdOrId;
      case "id":
        return _getId;
      default:
        return _get$Id;
    }
  }
  function _getId(schema) {
    if (schema.$id)
      this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
  }
  function _get$Id(schema) {
    if (schema.id)
      this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
  }
  function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id)
      throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
  }
  function errorsText(errors, options) {
    errors = errors || this.errors;
    if (!errors)
      return "No errors";
    options = options || {};
    var separator = options.separator === void 0 ? ", " : options.separator;
    var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
    var text = "";
    for (var i = 0; i < errors.length; i++) {
      var e = errors[i];
      if (e)
        text += dataVar + e.dataPath + " " + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }
  function addFormat(name, format) {
    if (typeof format == "string")
      format = new RegExp(format);
    this._formats[name] = format;
    return this;
  }
  function addDefaultMetaSchema(self2) {
    var $dataSchema;
    if (self2._opts.$data) {
      $dataSchema = require_data2();
      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self2._opts.meta === false)
      return;
    var metaSchema = require_json_schema_draft_07();
    if (self2._opts.$data)
      metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
  }
  function addInitialSchemas(self2) {
    var optsSchemas = self2._opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      self2.addSchema(optsSchemas);
    else
      for (var key in optsSchemas)
        self2.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats(self2) {
    for (var name in self2._opts.formats) {
      var format = self2._opts.formats[name];
      self2.addFormat(name, format);
    }
  }
  function checkUnique(self2, id) {
    if (self2._schemas[id] || self2._refs[id])
      throw new Error('schema with key or id "' + id + '" already exists');
  }
  function getMetaSchemaOptions(self2) {
    var metaOpts = util.copy(self2._opts);
    for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
  function setLogger(self2) {
    var logger = self2._opts.logger;
    if (logger === false) {
      self2.logger = {log: noop, warn: noop, error: noop};
    } else {
      if (logger === void 0)
        logger = console;
      if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
        throw new Error("logger must implement log, warn and error methods");
      self2.logger = logger;
    }
  }
  function noop() {
  }
});

// node_modules/har-validator/lib/error.js
var require_error = __commonJS((exports2, module2) => {
  function HARError(errors) {
    var message = "validation failed";
    this.name = "HARError";
    this.message = message;
    this.errors = errors;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
  HARError.prototype = Error.prototype;
  module2.exports = HARError;
});

// node_modules/har-schema/lib/afterRequest.json
var require_afterRequest = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "afterRequest.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "lastAccess",
      "eTag",
      "hitCount"
    ],
    properties: {
      expires: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      lastAccess: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      eTag: {
        type: "string"
      },
      hitCount: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/beforeRequest.json
var require_beforeRequest = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "beforeRequest.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "lastAccess",
      "eTag",
      "hitCount"
    ],
    properties: {
      expires: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      lastAccess: {
        type: "string",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
      },
      eTag: {
        type: "string"
      },
      hitCount: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/browser.json
var require_browser = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "browser.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "version"
    ],
    properties: {
      name: {
        type: "string"
      },
      version: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/cache.json
var require_cache2 = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "cache.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    properties: {
      beforeRequest: {
        oneOf: [
          {type: "null"},
          {$ref: "beforeRequest.json#"}
        ]
      },
      afterRequest: {
        oneOf: [
          {type: "null"},
          {$ref: "afterRequest.json#"}
        ]
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/content.json
var require_content = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "content.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "size",
      "mimeType"
    ],
    properties: {
      size: {
        type: "integer"
      },
      compression: {
        type: "integer"
      },
      mimeType: {
        type: "string"
      },
      text: {
        type: "string"
      },
      encoding: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/cookie.json
var require_cookie2 = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "cookie.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "value"
    ],
    properties: {
      name: {
        type: "string"
      },
      value: {
        type: "string"
      },
      path: {
        type: "string"
      },
      domain: {
        type: "string"
      },
      expires: {
        type: ["string", "null"],
        format: "date-time"
      },
      httpOnly: {
        type: "boolean"
      },
      secure: {
        type: "boolean"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/creator.json
var require_creator = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "creator.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "version"
    ],
    properties: {
      name: {
        type: "string"
      },
      version: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/entry.json
var require_entry = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "entry.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "startedDateTime",
      "time",
      "request",
      "response",
      "cache",
      "timings"
    ],
    properties: {
      pageref: {
        type: "string"
      },
      startedDateTime: {
        type: "string",
        format: "date-time",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
      },
      time: {
        type: "number",
        min: 0
      },
      request: {
        $ref: "request.json#"
      },
      response: {
        $ref: "response.json#"
      },
      cache: {
        $ref: "cache.json#"
      },
      timings: {
        $ref: "timings.json#"
      },
      serverIPAddress: {
        type: "string",
        oneOf: [
          {format: "ipv4"},
          {format: "ipv6"}
        ]
      },
      connection: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/har.json
var require_har = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "har.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "log"
    ],
    properties: {
      log: {
        $ref: "log.json#"
      }
    }
  };
});

// node_modules/har-schema/lib/header.json
var require_header = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "header.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "value"
    ],
    properties: {
      name: {
        type: "string"
      },
      value: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/log.json
var require_log = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "log.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "version",
      "creator",
      "entries"
    ],
    properties: {
      version: {
        type: "string"
      },
      creator: {
        $ref: "creator.json#"
      },
      browser: {
        $ref: "browser.json#"
      },
      pages: {
        type: "array",
        items: {
          $ref: "page.json#"
        }
      },
      entries: {
        type: "array",
        items: {
          $ref: "entry.json#"
        }
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/page.json
var require_page = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "page.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "startedDateTime",
      "id",
      "title",
      "pageTimings"
    ],
    properties: {
      startedDateTime: {
        type: "string",
        format: "date-time",
        pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
      },
      id: {
        type: "string",
        unique: true
      },
      title: {
        type: "string"
      },
      pageTimings: {
        $ref: "pageTimings.json#"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/pageTimings.json
var require_pageTimings = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "pageTimings.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    properties: {
      onContentLoad: {
        type: "number",
        min: -1
      },
      onLoad: {
        type: "number",
        min: -1
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/postData.json
var require_postData = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "postData.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    optional: true,
    required: [
      "mimeType"
    ],
    properties: {
      mimeType: {
        type: "string"
      },
      text: {
        type: "string"
      },
      params: {
        type: "array",
        required: [
          "name"
        ],
        properties: {
          name: {
            type: "string"
          },
          value: {
            type: "string"
          },
          fileName: {
            type: "string"
          },
          contentType: {
            type: "string"
          },
          comment: {
            type: "string"
          }
        }
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/query.json
var require_query = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "query.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "name",
      "value"
    ],
    properties: {
      name: {
        type: "string"
      },
      value: {
        type: "string"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/request.json
var require_request = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "request.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "method",
      "url",
      "httpVersion",
      "cookies",
      "headers",
      "queryString",
      "headersSize",
      "bodySize"
    ],
    properties: {
      method: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri"
      },
      httpVersion: {
        type: "string"
      },
      cookies: {
        type: "array",
        items: {
          $ref: "cookie.json#"
        }
      },
      headers: {
        type: "array",
        items: {
          $ref: "header.json#"
        }
      },
      queryString: {
        type: "array",
        items: {
          $ref: "query.json#"
        }
      },
      postData: {
        $ref: "postData.json#"
      },
      headersSize: {
        type: "integer"
      },
      bodySize: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/response.json
var require_response = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "response.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    type: "object",
    required: [
      "status",
      "statusText",
      "httpVersion",
      "cookies",
      "headers",
      "content",
      "redirectURL",
      "headersSize",
      "bodySize"
    ],
    properties: {
      status: {
        type: "integer"
      },
      statusText: {
        type: "string"
      },
      httpVersion: {
        type: "string"
      },
      cookies: {
        type: "array",
        items: {
          $ref: "cookie.json#"
        }
      },
      headers: {
        type: "array",
        items: {
          $ref: "header.json#"
        }
      },
      content: {
        $ref: "content.json#"
      },
      redirectURL: {
        type: "string"
      },
      headersSize: {
        type: "integer"
      },
      bodySize: {
        type: "integer"
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/timings.json
var require_timings = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: "timings.json#",
    $schema: "http://json-schema.org/draft-06/schema#",
    required: [
      "send",
      "wait",
      "receive"
    ],
    properties: {
      dns: {
        type: "number",
        min: -1
      },
      connect: {
        type: "number",
        min: -1
      },
      blocked: {
        type: "number",
        min: -1
      },
      send: {
        type: "number",
        min: -1
      },
      wait: {
        type: "number",
        min: -1
      },
      receive: {
        type: "number",
        min: -1
      },
      ssl: {
        type: "number",
        min: -1
      },
      comment: {
        type: "string"
      }
    }
  };
});

// node_modules/har-schema/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    afterRequest: require_afterRequest(),
    beforeRequest: require_beforeRequest(),
    browser: require_browser(),
    cache: require_cache2(),
    content: require_content(),
    cookie: require_cookie2(),
    creator: require_creator(),
    entry: require_entry(),
    har: require_har(),
    header: require_header(),
    log: require_log(),
    page: require_page(),
    pageTimings: require_pageTimings(),
    postData: require_postData(),
    query: require_query(),
    request: require_request(),
    response: require_response(),
    timings: require_timings()
  };
});

// node_modules/ajv/lib/refs/json-schema-draft-06.json
var require_json_schema_draft_06 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: "http://json-schema.org/draft-06/schema#",
    $id: "http://json-schema.org/draft-06/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {$ref: "#"}
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [
          {$ref: "#/definitions/nonNegativeInteger"},
          {default: 0}
        ]
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: {type: "string"},
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: {},
      examples: {
        type: "array",
        items: {}
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: {$ref: "#/definitions/nonNegativeInteger"},
      minLength: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {$ref: "#"},
      items: {
        anyOf: [
          {$ref: "#"},
          {$ref: "#/definitions/schemaArray"}
        ],
        default: {}
      },
      maxItems: {$ref: "#/definitions/nonNegativeInteger"},
      minItems: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: {$ref: "#"},
      maxProperties: {$ref: "#/definitions/nonNegativeInteger"},
      minProperties: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      required: {$ref: "#/definitions/stringArray"},
      additionalProperties: {$ref: "#"},
      definitions: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            {$ref: "#"},
            {$ref: "#/definitions/stringArray"}
          ]
        }
      },
      propertyNames: {$ref: "#"},
      const: {},
      enum: {
        type: "array",
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          {$ref: "#/definitions/simpleTypes"},
          {
            type: "array",
            items: {$ref: "#/definitions/simpleTypes"},
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: {type: "string"},
      allOf: {$ref: "#/definitions/schemaArray"},
      anyOf: {$ref: "#/definitions/schemaArray"},
      oneOf: {$ref: "#/definitions/schemaArray"},
      not: {$ref: "#"}
    },
    default: {}
  };
});

// node_modules/har-validator/lib/promise.js
var require_promise = __commonJS((exports2) => {
  var Ajv = require_ajv();
  var HARError = require_error();
  var schemas = require_lib5();
  var ajv;
  function createAjvInstance() {
    var ajv2 = new Ajv({
      allErrors: true
    });
    ajv2.addMetaSchema(require_json_schema_draft_06());
    ajv2.addSchema(schemas);
    return ajv2;
  }
  function validate(name, data) {
    data = data || {};
    ajv = ajv || createAjvInstance();
    var validate2 = ajv.getSchema(name + ".json");
    return new Promise(function(resolve, reject) {
      var valid = validate2(data);
      !valid ? reject(new HARError(validate2.errors)) : resolve(data);
    });
  }
  exports2.afterRequest = function(data) {
    return validate("afterRequest", data);
  };
  exports2.beforeRequest = function(data) {
    return validate("beforeRequest", data);
  };
  exports2.browser = function(data) {
    return validate("browser", data);
  };
  exports2.cache = function(data) {
    return validate("cache", data);
  };
  exports2.content = function(data) {
    return validate("content", data);
  };
  exports2.cookie = function(data) {
    return validate("cookie", data);
  };
  exports2.creator = function(data) {
    return validate("creator", data);
  };
  exports2.entry = function(data) {
    return validate("entry", data);
  };
  exports2.har = function(data) {
    return validate("har", data);
  };
  exports2.header = function(data) {
    return validate("header", data);
  };
  exports2.log = function(data) {
    return validate("log", data);
  };
  exports2.page = function(data) {
    return validate("page", data);
  };
  exports2.pageTimings = function(data) {
    return validate("pageTimings", data);
  };
  exports2.postData = function(data) {
    return validate("postData", data);
  };
  exports2.query = function(data) {
    return validate("query", data);
  };
  exports2.request = function(data) {
    return validate("request", data);
  };
  exports2.response = function(data) {
    return validate("response", data);
  };
  exports2.timings = function(data) {
    return validate("timings", data);
  };
});

// node_modules/request/lib/har.js
var require_har2 = __commonJS((exports2) => {
  "use strict";
  var fs = require("fs");
  var qs = require("querystring");
  var validate = require_promise();
  var extend2 = require_extend();
  function Har(request) {
    this.request = request;
  }
  Har.prototype.reducer = function(obj, pair) {
    if (obj[pair.name] === void 0) {
      obj[pair.name] = pair.value;
      return obj;
    }
    var arr = [
      obj[pair.name],
      pair.value
    ];
    obj[pair.name] = arr;
    return obj;
  };
  Har.prototype.prep = function(data) {
    data.queryObj = {};
    data.headersObj = {};
    data.postData.jsonObj = false;
    data.postData.paramsObj = false;
    if (data.queryString && data.queryString.length) {
      data.queryObj = data.queryString.reduce(this.reducer, {});
    }
    if (data.headers && data.headers.length) {
      data.headersObj = data.headers.reduceRight(function(headers, header) {
        headers[header.name] = header.value;
        return headers;
      }, {});
    }
    if (data.cookies && data.cookies.length) {
      var cookies = data.cookies.map(function(cookie) {
        return cookie.name + "=" + cookie.value;
      });
      if (cookies.length) {
        data.headersObj.cookie = cookies.join("; ");
      }
    }
    function some(arr) {
      return arr.some(function(type) {
        return data.postData.mimeType.indexOf(type) === 0;
      });
    }
    if (some([
      "multipart/mixed",
      "multipart/related",
      "multipart/form-data",
      "multipart/alternative"
    ])) {
      data.postData.mimeType = "multipart/form-data";
    } else if (some([
      "application/x-www-form-urlencoded"
    ])) {
      if (!data.postData.params) {
        data.postData.text = "";
      } else {
        data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});
        data.postData.text = qs.stringify(data.postData.paramsObj);
      }
    } else if (some([
      "text/json",
      "text/x-json",
      "application/json",
      "application/x-json"
    ])) {
      data.postData.mimeType = "application/json";
      if (data.postData.text) {
        try {
          data.postData.jsonObj = JSON.parse(data.postData.text);
        } catch (e) {
          this.request.debug(e);
          data.postData.mimeType = "text/plain";
        }
      }
    }
    return data;
  };
  Har.prototype.options = function(options) {
    if (!options.har) {
      return options;
    }
    var har = {};
    extend2(har, options.har);
    if (har.log && har.log.entries) {
      har = har.log.entries[0];
    }
    har.url = har.url || options.url || options.uri || options.baseUrl || "/";
    har.httpVersion = har.httpVersion || "HTTP/1.1";
    har.queryString = har.queryString || [];
    har.headers = har.headers || [];
    har.cookies = har.cookies || [];
    har.postData = har.postData || {};
    har.postData.mimeType = har.postData.mimeType || "application/octet-stream";
    har.bodySize = 0;
    har.headersSize = 0;
    har.postData.size = 0;
    if (!validate.request(har)) {
      return options;
    }
    var req = this.prep(har);
    if (req.url) {
      options.url = req.url;
    }
    if (req.method) {
      options.method = req.method;
    }
    if (Object.keys(req.queryObj).length) {
      options.qs = req.queryObj;
    }
    if (Object.keys(req.headersObj).length) {
      options.headers = req.headersObj;
    }
    function test(type) {
      return req.postData.mimeType.indexOf(type) === 0;
    }
    if (test("application/x-www-form-urlencoded")) {
      options.form = req.postData.paramsObj;
    } else if (test("application/json")) {
      if (req.postData.jsonObj) {
        options.body = req.postData.jsonObj;
        options.json = true;
      }
    } else if (test("multipart/form-data")) {
      options.formData = {};
      req.postData.params.forEach(function(param) {
        var attachment = {};
        if (!param.fileName && !param.fileName && !param.contentType) {
          options.formData[param.name] = param.value;
          return;
        }
        if (param.fileName && !param.value) {
          attachment.value = fs.createReadStream(param.fileName);
        } else if (param.value) {
          attachment.value = param.value;
        }
        if (param.fileName) {
          attachment.options = {
            filename: param.fileName,
            contentType: param.contentType ? param.contentType : null
          };
        }
        options.formData[param.name] = attachment;
      });
    } else {
      if (req.postData.text) {
        options.body = req.postData.text;
      }
    }
    return options;
  };
  exports2.Har = Har;
});

// node_modules/uuid/lib/rng.js
var require_rng = __commonJS((exports2, module2) => {
  var crypto = require("crypto");
  module2.exports = function nodeRNG() {
    return crypto.randomBytes(16);
  };
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports2, module2) => {
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 256).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  module2.exports = bytesToUuid;
});

// node_modules/uuid/v4.js
var require_v4 = __commonJS((exports2, module2) => {
  var rng = require_rng();
  var bytesToUuid = require_bytesToUuid();
  function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  module2.exports = v4;
});

// node_modules/request/lib/auth.js
var require_auth = __commonJS((exports2) => {
  "use strict";
  var caseless = require_caseless();
  var uuid = require_v4();
  var helpers = require_helpers();
  var md5 = helpers.md5;
  var toBase64 = helpers.toBase64;
  function Auth(request) {
    this.request = request;
    this.hasAuth = false;
    this.sentAuth = false;
    this.bearerToken = null;
    this.user = null;
    this.pass = null;
  }
  Auth.prototype.basic = function(user, pass, sendImmediately) {
    var self2 = this;
    if (typeof user !== "string" || pass !== void 0 && typeof pass !== "string") {
      self2.request.emit("error", new Error("auth() received invalid user or password"));
    }
    self2.user = user;
    self2.pass = pass;
    self2.hasAuth = true;
    var header = user + ":" + (pass || "");
    if (sendImmediately || typeof sendImmediately === "undefined") {
      var authHeader = "Basic " + toBase64(header);
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.bearer = function(bearer, sendImmediately) {
    var self2 = this;
    self2.bearerToken = bearer;
    self2.hasAuth = true;
    if (sendImmediately || typeof sendImmediately === "undefined") {
      if (typeof bearer === "function") {
        bearer = bearer();
      }
      var authHeader = "Bearer " + (bearer || "");
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.digest = function(method, path, authHeader) {
    var self2 = this;
    var challenge = {};
    var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
    for (; ; ) {
      var match = re.exec(authHeader);
      if (!match) {
        break;
      }
      challenge[match[1]] = match[2] || match[3];
    }
    var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce2) {
      var ha12 = md5(user + ":" + realm + ":" + pass);
      if (algorithm && algorithm.toLowerCase() === "md5-sess") {
        return md5(ha12 + ":" + nonce + ":" + cnonce2);
      } else {
        return ha12;
      }
    };
    var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && "auth";
    var nc = qop && "00000001";
    var cnonce = qop && uuid().replace(/-/g, "");
    var ha1 = ha1Compute(challenge.algorithm, self2.user, challenge.realm, self2.pass, challenge.nonce, cnonce);
    var ha2 = md5(method + ":" + path);
    var digestResponse = qop ? md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) : md5(ha1 + ":" + challenge.nonce + ":" + ha2);
    var authValues = {
      username: self2.user,
      realm: challenge.realm,
      nonce: challenge.nonce,
      uri: path,
      qop,
      response: digestResponse,
      nc,
      cnonce,
      algorithm: challenge.algorithm,
      opaque: challenge.opaque
    };
    authHeader = [];
    for (var k in authValues) {
      if (authValues[k]) {
        if (k === "qop" || k === "nc" || k === "algorithm") {
          authHeader.push(k + "=" + authValues[k]);
        } else {
          authHeader.push(k + '="' + authValues[k] + '"');
        }
      }
    }
    authHeader = "Digest " + authHeader.join(", ");
    self2.sentAuth = true;
    return authHeader;
  };
  Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    var request = self2.request;
    var authHeader;
    if (bearer === void 0 && user === void 0) {
      self2.request.emit("error", new Error("no auth mechanism defined"));
    } else if (bearer !== void 0) {
      authHeader = self2.bearer(bearer, sendImmediately);
    } else {
      authHeader = self2.basic(user, pass, sendImmediately);
    }
    if (authHeader) {
      request.setHeader("authorization", authHeader);
    }
  };
  Auth.prototype.onResponse = function(response) {
    var self2 = this;
    var request = self2.request;
    if (!self2.hasAuth || self2.sentAuth) {
      return null;
    }
    var c = caseless(response.headers);
    var authHeader = c.get("www-authenticate");
    var authVerb = authHeader && authHeader.split(" ")[0].toLowerCase();
    request.debug("reauth", authVerb);
    switch (authVerb) {
      case "basic":
        return self2.basic(self2.user, self2.pass, true);
      case "bearer":
        return self2.bearer(self2.bearerToken, true);
      case "digest":
        return self2.digest(request.method, request.path, authHeader);
    }
  };
  exports2.Auth = Auth;
});

// node_modules/oauth-sign/index.js
var require_oauth_sign = __commonJS((exports2) => {
  var crypto = require("crypto");
  function sha(key, body, algorithm) {
    return crypto.createHmac(algorithm, key).update(body).digest("base64");
  }
  function rsa(key, body) {
    return crypto.createSign("RSA-SHA1").update(body).sign(key, "base64");
  }
  function rfc3986(str) {
    return encodeURIComponent(str).replace(/!/g, "%21").replace(/\*/g, "%2A").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/'/g, "%27");
  }
  function map(obj) {
    var key, val, arr = [];
    for (key in obj) {
      val = obj[key];
      if (Array.isArray(val))
        for (var i = 0; i < val.length; i++)
          arr.push([key, val[i]]);
      else if (typeof val === "object")
        for (var prop in val)
          arr.push([key + "[" + prop + "]", val[prop]]);
      else
        arr.push([key, val]);
    }
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  function generateBase(httpMethod, base_uri, params) {
    var normalized = map(params).map(function(p) {
      return [rfc3986(p[0]), rfc3986(p[1] || "")];
    }).sort(function(a, b) {
      return compare(a[0], b[0]) || compare(a[1], b[1]);
    }).map(function(p) {
      return p.join("=");
    }).join("&");
    var base = [
      rfc3986(httpMethod ? httpMethod.toUpperCase() : "GET"),
      rfc3986(base_uri),
      rfc3986(normalized)
    ].join("&");
    return base;
  }
  function hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return sha(key, base, "sha1");
  }
  function hmacsign256(httpMethod, base_uri, params, consumer_secret, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return sha(key, base, "sha256");
  }
  function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = private_key || "";
    return rsa(key, base);
  }
  function plaintext(consumer_secret, token_secret) {
    var key = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return key;
  }
  function sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
    var method;
    var skipArgs = 1;
    switch (signMethod) {
      case "RSA-SHA1":
        method = rsasign;
        break;
      case "HMAC-SHA1":
        method = hmacsign;
        break;
      case "HMAC-SHA256":
        method = hmacsign256;
        break;
      case "PLAINTEXT":
        method = plaintext;
        skipArgs = 4;
        break;
      default:
        throw new Error("Signature method not supported: " + signMethod);
    }
    return method.apply(null, [].slice.call(arguments, skipArgs));
  }
  exports2.hmacsign = hmacsign;
  exports2.hmacsign256 = hmacsign256;
  exports2.rsasign = rsasign;
  exports2.plaintext = plaintext;
  exports2.sign = sign;
  exports2.rfc3986 = rfc3986;
  exports2.generateBase = generateBase;
});

// node_modules/request/lib/oauth.js
var require_oauth = __commonJS((exports2) => {
  "use strict";
  var url = require("url");
  var qs = require_lib4();
  var caseless = require_caseless();
  var uuid = require_v4();
  var oauth = require_oauth_sign();
  var crypto = require("crypto");
  var Buffer2 = require_safe_buffer().Buffer;
  function OAuth(request) {
    this.request = request;
    this.params = null;
  }
  OAuth.prototype.buildParams = function(_oauth, uri, method, query, form, qsLib) {
    var oa = {};
    for (var i in _oauth) {
      oa["oauth_" + i] = _oauth[i];
    }
    if (!oa.oauth_version) {
      oa.oauth_version = "1.0";
    }
    if (!oa.oauth_timestamp) {
      oa.oauth_timestamp = Math.floor(Date.now() / 1e3).toString();
    }
    if (!oa.oauth_nonce) {
      oa.oauth_nonce = uuid().replace(/-/g, "");
    }
    if (!oa.oauth_signature_method) {
      oa.oauth_signature_method = "HMAC-SHA1";
    }
    var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key;
    delete oa.oauth_consumer_secret;
    delete oa.oauth_private_key;
    var token_secret = oa.oauth_token_secret;
    delete oa.oauth_token_secret;
    var realm = oa.oauth_realm;
    delete oa.oauth_realm;
    delete oa.oauth_transport_method;
    var baseurl = uri.protocol + "//" + uri.host + uri.pathname;
    var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join("&"));
    oa.oauth_signature = oauth.sign(oa.oauth_signature_method, method, baseurl, params, consumer_secret_or_private_key, token_secret);
    if (realm) {
      oa.realm = realm;
    }
    return oa;
  };
  OAuth.prototype.buildBodyHash = function(_oauth, body) {
    if (["HMAC-SHA1", "RSA-SHA1"].indexOf(_oauth.signature_method || "HMAC-SHA1") < 0) {
      this.request.emit("error", new Error("oauth: " + _oauth.signature_method + " signature_method not supported with body_hash signing."));
    }
    var shasum = crypto.createHash("sha1");
    shasum.update(body || "");
    var sha1 = shasum.digest("hex");
    return Buffer2.from(sha1, "hex").toString("base64");
  };
  OAuth.prototype.concatParams = function(oa, sep, wrap) {
    wrap = wrap || "";
    var params = Object.keys(oa).filter(function(i) {
      return i !== "realm" && i !== "oauth_signature";
    }).sort();
    if (oa.realm) {
      params.splice(0, 0, "realm");
    }
    params.push("oauth_signature");
    return params.map(function(i) {
      return i + "=" + wrap + oauth.rfc3986(oa[i]) + wrap;
    }).join(sep);
  };
  OAuth.prototype.onRequest = function(_oauth) {
    var self2 = this;
    self2.params = _oauth;
    var uri = self2.request.uri || {};
    var method = self2.request.method || "";
    var headers = caseless(self2.request.headers);
    var body = self2.request.body || "";
    var qsLib = self2.request.qsLib || qs;
    var form;
    var query;
    var contentType = headers.get("content-type") || "";
    var formContentType = "application/x-www-form-urlencoded";
    var transport = _oauth.transport_method || "header";
    if (contentType.slice(0, formContentType.length) === formContentType) {
      contentType = formContentType;
      form = body;
    }
    if (uri.query) {
      query = uri.query;
    }
    if (transport === "body" && (method !== "POST" || contentType !== formContentType)) {
      self2.request.emit("error", new Error("oauth: transport_method of body requires POST and content-type " + formContentType));
    }
    if (!form && typeof _oauth.body_hash === "boolean") {
      _oauth.body_hash = self2.buildBodyHash(_oauth, self2.request.body.toString());
    }
    var oa = self2.buildParams(_oauth, uri, method, query, form, qsLib);
    switch (transport) {
      case "header":
        self2.request.setHeader("Authorization", "OAuth " + self2.concatParams(oa, ",", '"'));
        break;
      case "query":
        var href = self2.request.uri.href += (query ? "&" : "?") + self2.concatParams(oa, "&");
        self2.request.uri = url.parse(href);
        self2.request.path = self2.request.uri.path;
        break;
      case "body":
        self2.request.body = (form ? form + "&" : "") + self2.concatParams(oa, "&");
        break;
      default:
        self2.request.emit("error", new Error("oauth: transport_method invalid"));
    }
  };
  exports2.OAuth = OAuth;
});

// node_modules/request/lib/hawk.js
var require_hawk = __commonJS((exports2) => {
  "use strict";
  var crypto = require("crypto");
  function randomString(size) {
    var bits = (size + 1) * 6;
    var buffer = crypto.randomBytes(Math.ceil(bits / 8));
    var string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return string.slice(0, size);
  }
  function calculatePayloadHash(payload, algorithm, contentType) {
    var hash = crypto.createHash(algorithm);
    hash.update("hawk.1.payload\n");
    hash.update((contentType ? contentType.split(";")[0].trim().toLowerCase() : "") + "\n");
    hash.update(payload || "");
    hash.update("\n");
    return hash.digest("base64");
  }
  exports2.calculateMac = function(credentials, opts) {
    var normalized = "hawk.1.header\n" + opts.ts + "\n" + opts.nonce + "\n" + (opts.method || "").toUpperCase() + "\n" + opts.resource + "\n" + opts.host.toLowerCase() + "\n" + opts.port + "\n" + (opts.hash || "") + "\n";
    if (opts.ext) {
      normalized = normalized + opts.ext.replace("\\", "\\\\").replace("\n", "\\n");
    }
    normalized = normalized + "\n";
    if (opts.app) {
      normalized = normalized + opts.app + "\n" + (opts.dlg || "") + "\n";
    }
    var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
    var digest = hmac.digest("base64");
    return digest;
  };
  exports2.header = function(uri, method, opts) {
    var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1e3);
    var credentials = opts.credentials;
    if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
      return "";
    }
    if (["sha1", "sha256"].indexOf(credentials.algorithm) === -1) {
      return "";
    }
    var artifacts = {
      ts: timestamp,
      nonce: opts.nonce || randomString(6),
      method,
      resource: uri.pathname + (uri.search || ""),
      host: uri.hostname,
      port: uri.port || (uri.protocol === "http:" ? 80 : 443),
      hash: opts.hash,
      ext: opts.ext,
      app: opts.app,
      dlg: opts.dlg
    };
    if (!artifacts.hash && (opts.payload || opts.payload === "")) {
      artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
    }
    var mac = exports2.calculateMac(credentials, artifacts);
    var hasExt = artifacts.ext !== null && artifacts.ext !== void 0 && artifacts.ext !== "";
    var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : "") + (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, "\\\\").replace(/"/g, '\\"') : "") + '", mac="' + mac + '"';
    if (artifacts.app) {
      header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : "") + '"';
    }
    return header;
  };
});

// node_modules/request/lib/multipart.js
var require_multipart = __commonJS((exports2) => {
  "use strict";
  var uuid = require_v4();
  var CombinedStream = require_combined_stream();
  var isstream = require_isstream();
  var Buffer2 = require_safe_buffer().Buffer;
  function Multipart(request) {
    this.request = request;
    this.boundary = uuid();
    this.chunked = false;
    this.body = null;
  }
  Multipart.prototype.isChunked = function(options) {
    var self2 = this;
    var chunked = false;
    var parts = options.data || options;
    if (!parts.forEach) {
      self2.request.emit("error", new Error("Argument error, options.multipart."));
    }
    if (options.chunked !== void 0) {
      chunked = options.chunked;
    }
    if (self2.request.getHeader("transfer-encoding") === "chunked") {
      chunked = true;
    }
    if (!chunked) {
      parts.forEach(function(part) {
        if (typeof part.body === "undefined") {
          self2.request.emit("error", new Error("Body attribute missing in multipart."));
        }
        if (isstream(part.body)) {
          chunked = true;
        }
      });
    }
    return chunked;
  };
  Multipart.prototype.setHeaders = function(chunked) {
    var self2 = this;
    if (chunked && !self2.request.hasHeader("transfer-encoding")) {
      self2.request.setHeader("transfer-encoding", "chunked");
    }
    var header = self2.request.getHeader("content-type");
    if (!header || header.indexOf("multipart") === -1) {
      self2.request.setHeader("content-type", "multipart/related; boundary=" + self2.boundary);
    } else {
      if (header.indexOf("boundary") !== -1) {
        self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, "$1");
      } else {
        self2.request.setHeader("content-type", header + "; boundary=" + self2.boundary);
      }
    }
  };
  Multipart.prototype.build = function(parts, chunked) {
    var self2 = this;
    var body = chunked ? new CombinedStream() : [];
    function add(part) {
      if (typeof part === "number") {
        part = part.toString();
      }
      return chunked ? body.append(part) : body.push(Buffer2.from(part));
    }
    if (self2.request.preambleCRLF) {
      add("\r\n");
    }
    parts.forEach(function(part) {
      var preamble = "--" + self2.boundary + "\r\n";
      Object.keys(part).forEach(function(key) {
        if (key === "body") {
          return;
        }
        preamble += key + ": " + part[key] + "\r\n";
      });
      preamble += "\r\n";
      add(preamble);
      add(part.body);
      add("\r\n");
    });
    add("--" + self2.boundary + "--");
    if (self2.request.postambleCRLF) {
      add("\r\n");
    }
    return body;
  };
  Multipart.prototype.onRequest = function(options) {
    var self2 = this;
    var chunked = self2.isChunked(options);
    var parts = options.data || options;
    self2.setHeaders(chunked);
    self2.chunked = chunked;
    self2.body = self2.build(parts, chunked);
  };
  exports2.Multipart = Multipart;
});

// node_modules/request/lib/redirect.js
var require_redirect = __commonJS((exports2) => {
  "use strict";
  var url = require("url");
  var isUrl = /^https?:/;
  function Redirect(request) {
    this.request = request;
    this.followRedirect = true;
    this.followRedirects = true;
    this.followAllRedirects = false;
    this.followOriginalHttpMethod = false;
    this.allowRedirect = function() {
      return true;
    };
    this.maxRedirects = 10;
    this.redirects = [];
    this.redirectsFollowed = 0;
    this.removeRefererHeader = false;
  }
  Redirect.prototype.onRequest = function(options) {
    var self2 = this;
    if (options.maxRedirects !== void 0) {
      self2.maxRedirects = options.maxRedirects;
    }
    if (typeof options.followRedirect === "function") {
      self2.allowRedirect = options.followRedirect;
    }
    if (options.followRedirect !== void 0) {
      self2.followRedirects = !!options.followRedirect;
    }
    if (options.followAllRedirects !== void 0) {
      self2.followAllRedirects = options.followAllRedirects;
    }
    if (self2.followRedirects || self2.followAllRedirects) {
      self2.redirects = self2.redirects || [];
    }
    if (options.removeRefererHeader !== void 0) {
      self2.removeRefererHeader = options.removeRefererHeader;
    }
    if (options.followOriginalHttpMethod !== void 0) {
      self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
    }
  };
  Redirect.prototype.redirectTo = function(response) {
    var self2 = this;
    var request = self2.request;
    var redirectTo = null;
    if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has("location")) {
      var location = response.caseless.get("location");
      request.debug("redirect", location);
      if (self2.followAllRedirects) {
        redirectTo = location;
      } else if (self2.followRedirects) {
        switch (request.method) {
          case "PATCH":
          case "PUT":
          case "POST":
          case "DELETE":
            break;
          default:
            redirectTo = location;
            break;
        }
      }
    } else if (response.statusCode === 401) {
      var authHeader = request._auth.onResponse(response);
      if (authHeader) {
        request.setHeader("authorization", authHeader);
        redirectTo = request.uri;
      }
    }
    return redirectTo;
  };
  Redirect.prototype.onResponse = function(response) {
    var self2 = this;
    var request = self2.request;
    var redirectTo = self2.redirectTo(response);
    if (!redirectTo || !self2.allowRedirect.call(request, response)) {
      return false;
    }
    request.debug("redirect to", redirectTo);
    if (response.resume) {
      response.resume();
    }
    if (self2.redirectsFollowed >= self2.maxRedirects) {
      request.emit("error", new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + request.uri.href));
      return false;
    }
    self2.redirectsFollowed += 1;
    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(request.uri.href, redirectTo);
    }
    var uriPrev = request.uri;
    request.uri = url.parse(redirectTo);
    if (request.uri.protocol !== uriPrev.protocol) {
      delete request.agent;
    }
    self2.redirects.push({statusCode: response.statusCode, redirectUri: redirectTo});
    if (self2.followAllRedirects && request.method !== "HEAD" && response.statusCode !== 401 && response.statusCode !== 307) {
      request.method = self2.followOriginalHttpMethod ? request.method : "GET";
    }
    delete request.src;
    delete request.req;
    delete request._started;
    if (response.statusCode !== 401 && response.statusCode !== 307) {
      delete request.body;
      delete request._form;
      if (request.headers) {
        request.removeHeader("host");
        request.removeHeader("content-type");
        request.removeHeader("content-length");
        if (request.uri.hostname !== request.originalHost.split(":")[0]) {
          request.removeHeader("authorization");
        }
      }
    }
    if (!self2.removeRefererHeader) {
      request.setHeader("referer", uriPrev.href);
    }
    request.emit("redirect");
    request.init();
    return true;
  };
  exports2.Redirect = Redirect;
});

// node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS((exports2) => {
  "use strict";
  var net2 = require("net");
  var tls = require("tls");
  var http = require("http");
  var https = require("https");
  var events = require("events");
  var assert = require("assert");
  var util = require("util");
  var Buffer2 = require_safe_buffer().Buffer;
  exports2.httpOverHttp = httpOverHttp;
  exports2.httpsOverHttp = httpsOverHttp;
  exports2.httpOverHttps = httpOverHttps;
  exports2.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port) {
      for (var i = 0, len = self2.requests.length; i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === host && pending.port === port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
    var self2 = this;
    if (typeof options === "string") {
      options = {
        host: options,
        port: arguments[2],
        path: arguments[3]
      };
    }
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push({host: options.host, port: options.port, request: req});
      return;
    }
    self2.createConnection({host: options.host, port: options.port, request: req});
  };
  TunnelingAgent.prototype.createConnection = function createConnection(pending) {
    var self2 = this;
    self2.createSocket(pending, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      pending.request.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, pending.host, pending.port);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: false
    });
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode === 200) {
        assert.equal(head.length, 0);
        debug("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        cb(socket);
      } else {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
      var error = new Error("tunneling socket could not be established, cause=" + cause.message);
      error.code = "ECONNRESET";
      options.request.emit("error", error);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1)
      return;
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createConnection(pending);
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var secureSocket = tls.connect(0, mergeOptions({}, self2.options, {
        servername: options.host,
        socket
      }));
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length; i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== void 0) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.debug = debug;
});

// node_modules/request/lib/tunnel.js
var require_tunnel = __commonJS((exports2) => {
  "use strict";
  var url = require("url");
  var tunnel = require_tunnel_agent();
  var defaultProxyHeaderWhiteList = [
    "accept",
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept-ranges",
    "cache-control",
    "content-encoding",
    "content-language",
    "content-location",
    "content-md5",
    "content-range",
    "content-type",
    "connection",
    "date",
    "expect",
    "max-forwards",
    "pragma",
    "referer",
    "te",
    "user-agent",
    "via"
  ];
  var defaultProxyHeaderExclusiveList = [
    "proxy-authorization"
  ];
  function constructProxyHost(uriObject) {
    var port = uriObject.port;
    var protocol = uriObject.protocol;
    var proxyHost = uriObject.hostname + ":";
    if (port) {
      proxyHost += port;
    } else if (protocol === "https:") {
      proxyHost += "443";
    } else {
      proxyHost += "80";
    }
    return proxyHost;
  }
  function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
    var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
      set[header.toLowerCase()] = true;
      return set;
    }, {});
    return Object.keys(headers).filter(function(header) {
      return whiteList[header.toLowerCase()];
    }).reduce(function(set, header) {
      set[header] = headers[header];
      return set;
    }, {});
  }
  function constructTunnelOptions(request, proxyHeaders) {
    var proxy = request.proxy;
    var tunnelOptions = {
      proxy: {
        host: proxy.hostname,
        port: +proxy.port,
        proxyAuth: proxy.auth,
        headers: proxyHeaders
      },
      headers: request.headers,
      ca: request.ca,
      cert: request.cert,
      key: request.key,
      passphrase: request.passphrase,
      pfx: request.pfx,
      ciphers: request.ciphers,
      rejectUnauthorized: request.rejectUnauthorized,
      secureOptions: request.secureOptions,
      secureProtocol: request.secureProtocol
    };
    return tunnelOptions;
  }
  function constructTunnelFnName(uri, proxy) {
    var uriProtocol = uri.protocol === "https:" ? "https" : "http";
    var proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
    return [uriProtocol, proxyProtocol].join("Over");
  }
  function getTunnelFn(request) {
    var uri = request.uri;
    var proxy = request.proxy;
    var tunnelFnName = constructTunnelFnName(uri, proxy);
    return tunnel[tunnelFnName];
  }
  function Tunnel(request) {
    this.request = request;
    this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    this.proxyHeaderExclusiveList = [];
    if (typeof request.tunnel !== "undefined") {
      this.tunnelOverride = request.tunnel;
    }
  }
  Tunnel.prototype.isEnabled = function() {
    var self2 = this;
    var request = self2.request;
    if (typeof self2.tunnelOverride !== "undefined") {
      return self2.tunnelOverride;
    }
    if (request.uri.protocol === "https:") {
      return true;
    }
    return false;
  };
  Tunnel.prototype.setup = function(options) {
    var self2 = this;
    var request = self2.request;
    options = options || {};
    if (typeof request.proxy === "string") {
      request.proxy = url.parse(request.proxy);
    }
    if (!request.proxy || !request.tunnel) {
      return false;
    }
    if (options.proxyHeaderWhiteList) {
      self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
    }
    if (options.proxyHeaderExclusiveList) {
      self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
    }
    var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
    var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);
    var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);
    proxyHeaders.host = constructProxyHost(request.uri);
    proxyHeaderExclusiveList.forEach(request.removeHeader, request);
    var tunnelFn = getTunnelFn(request);
    var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
    request.agent = tunnelFn(tunnelOptions);
    return true;
  };
  Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
  Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
  exports2.Tunnel = Tunnel;
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS((exports2, module2) => {
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      module2.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      module2.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module2.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module2.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  }).call(exports2);
});

// node_modules/request/request.js
var require_request2 = __commonJS((exports2, module2) => {
  "use strict";
  var http = require("http");
  var https = require("https");
  var url = require("url");
  var util = require("util");
  var stream = require("stream");
  var zlib = require("zlib");
  var aws2 = require_aws_sign2();
  var aws4 = require_aws4();
  var httpSignature = require_lib3();
  var mime = require_mime_types();
  var caseless = require_caseless();
  var ForeverAgent = require_forever_agent();
  var FormData = require_form_data();
  var extend2 = require_extend();
  var isstream = require_isstream();
  var isTypedArray = require_is_typedarray().strict;
  var helpers = require_helpers();
  var cookies = require_cookies();
  var getProxyFromURI = require_getProxyFromURI();
  var Querystring = require_querystring().Querystring;
  var Har = require_har2().Har;
  var Auth = require_auth().Auth;
  var OAuth = require_oauth().OAuth;
  var hawk = require_hawk();
  var Multipart = require_multipart().Multipart;
  var Redirect = require_redirect().Redirect;
  var Tunnel = require_tunnel().Tunnel;
  var now = require_performance_now();
  var Buffer2 = require_safe_buffer().Buffer;
  var safeStringify = helpers.safeStringify;
  var isReadStream = helpers.isReadStream;
  var toBase64 = helpers.toBase64;
  var defer = helpers.defer;
  var copy = helpers.copy;
  var version = helpers.version;
  var globalCookieJar = cookies.jar();
  var globalPool = {};
  function filterForNonReserved(reserved, options) {
    var object = {};
    for (var i in options) {
      var notReserved = reserved.indexOf(i) === -1;
      if (notReserved) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function filterOutReservedFunctions(reserved, options) {
    var object = {};
    for (var i in options) {
      var isReserved = !(reserved.indexOf(i) === -1);
      var isFunction = typeof options[i] === "function";
      if (!(isReserved && isFunction)) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function requestToJSON() {
    var self2 = this;
    return {
      uri: self2.uri,
      method: self2.method,
      headers: self2.headers
    };
  }
  function responseToJSON() {
    var self2 = this;
    return {
      statusCode: self2.statusCode,
      body: self2.body,
      headers: self2.headers,
      request: requestToJSON.call(self2.request)
    };
  }
  function Request(options) {
    var self2 = this;
    if (options.har) {
      self2._har = new Har(self2);
      options = self2._har.options(options);
    }
    stream.Stream.call(self2);
    var reserved = Object.keys(Request.prototype);
    var nonReserved = filterForNonReserved(reserved, options);
    extend2(self2, nonReserved);
    options = filterOutReservedFunctions(reserved, options);
    self2.readable = true;
    self2.writable = true;
    if (options.method) {
      self2.explicitMethod = true;
    }
    self2._qs = new Querystring(self2);
    self2._auth = new Auth(self2);
    self2._oauth = new OAuth(self2);
    self2._multipart = new Multipart(self2);
    self2._redirect = new Redirect(self2);
    self2._tunnel = new Tunnel(self2);
    self2.init(options);
  }
  util.inherits(Request, stream.Stream);
  Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
  function debug() {
    if (Request.debug) {
      console.error("REQUEST %s", util.format.apply(util, arguments));
    }
  }
  Request.prototype.debug = debug;
  Request.prototype.init = function(options) {
    var self2 = this;
    if (!options) {
      options = {};
    }
    self2.headers = self2.headers ? copy(self2.headers) : {};
    for (var headerName in self2.headers) {
      if (typeof self2.headers[headerName] === "undefined") {
        delete self2.headers[headerName];
      }
    }
    caseless.httpify(self2, self2.headers);
    if (!self2.method) {
      self2.method = options.method || "GET";
    }
    if (!self2.localAddress) {
      self2.localAddress = options.localAddress;
    }
    self2._qs.init(options);
    debug(options);
    if (!self2.pool && self2.pool !== false) {
      self2.pool = globalPool;
    }
    self2.dests = self2.dests || [];
    self2.__isRequestRequest = true;
    if (!self2._callback && self2.callback) {
      self2._callback = self2.callback;
      self2.callback = function() {
        if (self2._callbackCalled) {
          return;
        }
        self2._callbackCalled = true;
        self2._callback.apply(self2, arguments);
      };
      self2.on("error", self2.callback.bind());
      self2.on("complete", self2.callback.bind(self2, null));
    }
    if (!self2.uri && self2.url) {
      self2.uri = self2.url;
      delete self2.url;
    }
    if (self2.baseUrl) {
      if (typeof self2.baseUrl !== "string") {
        return self2.emit("error", new Error("options.baseUrl must be a string"));
      }
      if (typeof self2.uri !== "string") {
        return self2.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
      }
      if (self2.uri.indexOf("//") === 0 || self2.uri.indexOf("://") !== -1) {
        return self2.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
      }
      var baseUrlEndsWithSlash = self2.baseUrl.lastIndexOf("/") === self2.baseUrl.length - 1;
      var uriStartsWithSlash = self2.uri.indexOf("/") === 0;
      if (baseUrlEndsWithSlash && uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri.slice(1);
      } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri;
      } else if (self2.uri === "") {
        self2.uri = self2.baseUrl;
      } else {
        self2.uri = self2.baseUrl + "/" + self2.uri;
      }
      delete self2.baseUrl;
    }
    if (!self2.uri) {
      return self2.emit("error", new Error("options.uri is a required argument"));
    }
    if (typeof self2.uri === "string") {
      self2.uri = url.parse(self2.uri);
    }
    if (!self2.uri.href) {
      self2.uri.href = url.format(self2.uri);
    }
    if (self2.uri.protocol === "unix:") {
      return self2.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
    }
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    if (self2.strictSSL === false) {
      self2.rejectUnauthorized = false;
    }
    if (!self2.uri.pathname) {
      self2.uri.pathname = "/";
    }
    if (!(self2.uri.host || self2.uri.hostname && self2.uri.port) && !self2.uri.isUnix) {
      var faultyUri = url.format(self2.uri);
      var message = 'Invalid URI "' + faultyUri + '"';
      if (Object.keys(options).length === 0) {
        message += ". This can be caused by a crappy redirection.";
      }
      self2.abort();
      return self2.emit("error", new Error(message));
    }
    if (!self2.hasOwnProperty("proxy")) {
      self2.proxy = getProxyFromURI(self2.uri);
    }
    self2.tunnel = self2._tunnel.isEnabled();
    if (self2.proxy) {
      self2._tunnel.setup(options);
    }
    self2._redirect.onRequest(options);
    self2.setHost = false;
    if (!self2.hasHeader("host")) {
      var hostHeaderName = self2.originalHostHeaderName || "host";
      self2.setHeader(hostHeaderName, self2.uri.host);
      if (self2.uri.port) {
        if (self2.uri.port === "80" && self2.uri.protocol === "http:" || self2.uri.port === "443" && self2.uri.protocol === "https:") {
          self2.setHeader(hostHeaderName, self2.uri.hostname);
        }
      }
      self2.setHost = true;
    }
    self2.jar(self2._jar || options.jar);
    if (!self2.uri.port) {
      if (self2.uri.protocol === "http:") {
        self2.uri.port = 80;
      } else if (self2.uri.protocol === "https:") {
        self2.uri.port = 443;
      }
    }
    if (self2.proxy && !self2.tunnel) {
      self2.port = self2.proxy.port;
      self2.host = self2.proxy.hostname;
    } else {
      self2.port = self2.uri.port;
      self2.host = self2.uri.hostname;
    }
    if (options.form) {
      self2.form(options.form);
    }
    if (options.formData) {
      var formData = options.formData;
      var requestForm = self2.form();
      var appendFormValue = function(key, value) {
        if (value && value.hasOwnProperty("value") && value.hasOwnProperty("options")) {
          requestForm.append(key, value.value, value.options);
        } else {
          requestForm.append(key, value);
        }
      };
      for (var formKey in formData) {
        if (formData.hasOwnProperty(formKey)) {
          var formValue = formData[formKey];
          if (formValue instanceof Array) {
            for (var j = 0; j < formValue.length; j++) {
              appendFormValue(formKey, formValue[j]);
            }
          } else {
            appendFormValue(formKey, formValue);
          }
        }
      }
    }
    if (options.qs) {
      self2.qs(options.qs);
    }
    if (self2.uri.path) {
      self2.path = self2.uri.path;
    } else {
      self2.path = self2.uri.pathname + (self2.uri.search || "");
    }
    if (self2.path.length === 0) {
      self2.path = "/";
    }
    if (options.aws) {
      self2.aws(options.aws);
    }
    if (options.hawk) {
      self2.hawk(options.hawk);
    }
    if (options.httpSignature) {
      self2.httpSignature(options.httpSignature);
    }
    if (options.auth) {
      if (Object.prototype.hasOwnProperty.call(options.auth, "username")) {
        options.auth.user = options.auth.username;
      }
      if (Object.prototype.hasOwnProperty.call(options.auth, "password")) {
        options.auth.pass = options.auth.password;
      }
      self2.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer);
    }
    if (self2.gzip && !self2.hasHeader("accept-encoding")) {
      self2.setHeader("accept-encoding", "gzip, deflate");
    }
    if (self2.uri.auth && !self2.hasHeader("authorization")) {
      var uriAuthPieces = self2.uri.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true);
    }
    if (!self2.tunnel && self2.proxy && self2.proxy.auth && !self2.hasHeader("proxy-authorization")) {
      var proxyAuthPieces = self2.proxy.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      var authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
      self2.setHeader("proxy-authorization", authHeader);
    }
    if (self2.proxy && !self2.tunnel) {
      self2.path = self2.uri.protocol + "//" + self2.uri.host + self2.path;
    }
    if (options.json) {
      self2.json(options.json);
    }
    if (options.multipart) {
      self2.multipart(options.multipart);
    }
    if (options.time) {
      self2.timing = true;
      self2.elapsedTime = self2.elapsedTime || 0;
    }
    function setContentLength() {
      if (isTypedArray(self2.body)) {
        self2.body = Buffer2.from(self2.body);
      }
      if (!self2.hasHeader("content-length")) {
        var length;
        if (typeof self2.body === "string") {
          length = Buffer2.byteLength(self2.body);
        } else if (Array.isArray(self2.body)) {
          length = self2.body.reduce(function(a, b) {
            return a + b.length;
          }, 0);
        } else {
          length = self2.body.length;
        }
        if (length) {
          self2.setHeader("content-length", length);
        } else {
          self2.emit("error", new Error("Argument error, options.body."));
        }
      }
    }
    if (self2.body && !isstream(self2.body)) {
      setContentLength();
    }
    if (options.oauth) {
      self2.oauth(options.oauth);
    } else if (self2._oauth.params && self2.hasHeader("authorization")) {
      self2.oauth(self2._oauth.params);
    }
    var protocol = self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
    var defaultModules = {"http:": http, "https:": https};
    var httpModules = self2.httpModules || {};
    self2.httpModule = httpModules[protocol] || defaultModules[protocol];
    if (!self2.httpModule) {
      return self2.emit("error", new Error("Invalid protocol: " + protocol));
    }
    if (options.ca) {
      self2.ca = options.ca;
    }
    if (!self2.agent) {
      if (options.agentOptions) {
        self2.agentOptions = options.agentOptions;
      }
      if (options.agentClass) {
        self2.agentClass = options.agentClass;
      } else if (options.forever) {
        var v = version();
        if (v.major === 0 && v.minor <= 10) {
          self2.agentClass = protocol === "http:" ? ForeverAgent : ForeverAgent.SSL;
        } else {
          self2.agentClass = self2.httpModule.Agent;
          self2.agentOptions = self2.agentOptions || {};
          self2.agentOptions.keepAlive = true;
        }
      } else {
        self2.agentClass = self2.httpModule.Agent;
      }
    }
    if (self2.pool === false) {
      self2.agent = false;
    } else {
      self2.agent = self2.agent || self2.getNewAgent();
    }
    self2.on("pipe", function(src) {
      if (self2.ntick && self2._started) {
        self2.emit("error", new Error("You cannot pipe to this stream after the outbound request has started."));
      }
      self2.src = src;
      if (isReadStream(src)) {
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", mime.lookup(src.path));
        }
      } else {
        if (src.headers) {
          for (var i in src.headers) {
            if (!self2.hasHeader(i)) {
              self2.setHeader(i, src.headers[i]);
            }
          }
        }
        if (self2._json && !self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
        if (src.method && !self2.explicitMethod) {
          self2.method = src.method;
        }
      }
    });
    defer(function() {
      if (self2._aborted) {
        return;
      }
      var end = function() {
        if (self2._form) {
          if (!self2._auth.hasAuth) {
            self2._form.pipe(self2);
          } else if (self2._auth.hasAuth && self2._auth.sentAuth) {
            self2._form.pipe(self2);
          }
        }
        if (self2._multipart && self2._multipart.chunked) {
          self2._multipart.body.pipe(self2);
        }
        if (self2.body) {
          if (isstream(self2.body)) {
            self2.body.pipe(self2);
          } else {
            setContentLength();
            if (Array.isArray(self2.body)) {
              self2.body.forEach(function(part) {
                self2.write(part);
              });
            } else {
              self2.write(self2.body);
            }
            self2.end();
          }
        } else if (self2.requestBodyStream) {
          console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.");
          self2.requestBodyStream.pipe(self2);
        } else if (!self2.src) {
          if (self2._auth.hasAuth && !self2._auth.sentAuth) {
            self2.end();
            return;
          }
          if (self2.method !== "GET" && typeof self2.method !== "undefined") {
            self2.setHeader("content-length", 0);
          }
          self2.end();
        }
      };
      if (self2._form && !self2.hasHeader("content-length")) {
        self2.setHeader(self2._form.getHeaders(), true);
        self2._form.getLength(function(err, length) {
          if (!err && !isNaN(length)) {
            self2.setHeader("content-length", length);
          }
          end();
        });
      } else {
        end();
      }
      self2.ntick = true;
    });
  };
  Request.prototype.getNewAgent = function() {
    var self2 = this;
    var Agent = self2.agentClass;
    var options = {};
    if (self2.agentOptions) {
      for (var i in self2.agentOptions) {
        options[i] = self2.agentOptions[i];
      }
    }
    if (self2.ca) {
      options.ca = self2.ca;
    }
    if (self2.ciphers) {
      options.ciphers = self2.ciphers;
    }
    if (self2.secureProtocol) {
      options.secureProtocol = self2.secureProtocol;
    }
    if (self2.secureOptions) {
      options.secureOptions = self2.secureOptions;
    }
    if (typeof self2.rejectUnauthorized !== "undefined") {
      options.rejectUnauthorized = self2.rejectUnauthorized;
    }
    if (self2.cert && self2.key) {
      options.key = self2.key;
      options.cert = self2.cert;
    }
    if (self2.pfx) {
      options.pfx = self2.pfx;
    }
    if (self2.passphrase) {
      options.passphrase = self2.passphrase;
    }
    var poolKey = "";
    if (Agent !== self2.httpModule.Agent) {
      poolKey += Agent.name;
    }
    var proxy = self2.proxy;
    if (typeof proxy === "string") {
      proxy = url.parse(proxy);
    }
    var isHttps = proxy && proxy.protocol === "https:" || this.uri.protocol === "https:";
    if (isHttps) {
      if (options.ca) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ca;
      }
      if (typeof options.rejectUnauthorized !== "undefined") {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.rejectUnauthorized;
      }
      if (options.cert) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.cert.toString("ascii") + options.key.toString("ascii");
      }
      if (options.pfx) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.pfx.toString("ascii");
      }
      if (options.ciphers) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ciphers;
      }
      if (options.secureProtocol) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureProtocol;
      }
      if (options.secureOptions) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureOptions;
      }
    }
    if (self2.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self2.httpModule.globalAgent) {
      return self2.httpModule.globalAgent;
    }
    poolKey = self2.uri.protocol + poolKey;
    if (!self2.pool[poolKey]) {
      self2.pool[poolKey] = new Agent(options);
      if (self2.pool.maxSockets) {
        self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
      }
    }
    return self2.pool[poolKey];
  };
  Request.prototype.start = function() {
    var self2 = this;
    if (self2.timing) {
      var startTime = new Date().getTime();
      var startTimeNow = now();
    }
    if (self2._aborted) {
      return;
    }
    self2._started = true;
    self2.method = self2.method || "GET";
    self2.href = self2.uri.href;
    if (self2.src && self2.src.stat && self2.src.stat.size && !self2.hasHeader("content-length")) {
      self2.setHeader("content-length", self2.src.stat.size);
    }
    if (self2._aws) {
      self2.aws(self2._aws, true);
    }
    var reqOptions = copy(self2);
    delete reqOptions.auth;
    debug("make request", self2.uri.href);
    delete reqOptions.timeout;
    try {
      self2.req = self2.httpModule.request(reqOptions);
    } catch (err) {
      self2.emit("error", err);
      return;
    }
    if (self2.timing) {
      self2.startTime = startTime;
      self2.startTimeNow = startTimeNow;
      self2.timings = {};
    }
    var timeout;
    if (self2.timeout && !self2.timeoutTimer) {
      if (self2.timeout < 0) {
        timeout = 0;
      } else if (typeof self2.timeout === "number" && isFinite(self2.timeout)) {
        timeout = self2.timeout;
      }
    }
    self2.req.on("response", self2.onRequestResponse.bind(self2));
    self2.req.on("error", self2.onRequestError.bind(self2));
    self2.req.on("drain", function() {
      self2.emit("drain");
    });
    self2.req.on("socket", function(socket) {
      var isConnecting = socket._connecting || socket.connecting;
      if (self2.timing) {
        self2.timings.socket = now() - self2.startTimeNow;
        if (isConnecting) {
          var onLookupTiming = function() {
            self2.timings.lookup = now() - self2.startTimeNow;
          };
          var onConnectTiming = function() {
            self2.timings.connect = now() - self2.startTimeNow;
          };
          socket.once("lookup", onLookupTiming);
          socket.once("connect", onConnectTiming);
          self2.req.once("error", function() {
            socket.removeListener("lookup", onLookupTiming);
            socket.removeListener("connect", onConnectTiming);
          });
        }
      }
      var setReqTimeout = function() {
        self2.req.setTimeout(timeout, function() {
          if (self2.req) {
            self2.abort();
            var e = new Error("ESOCKETTIMEDOUT");
            e.code = "ESOCKETTIMEDOUT";
            e.connect = false;
            self2.emit("error", e);
          }
        });
      };
      if (timeout !== void 0) {
        if (isConnecting) {
          var onReqSockConnect = function() {
            socket.removeListener("connect", onReqSockConnect);
            clearTimeout(self2.timeoutTimer);
            self2.timeoutTimer = null;
            setReqTimeout();
          };
          socket.on("connect", onReqSockConnect);
          self2.req.on("error", function(err) {
            socket.removeListener("connect", onReqSockConnect);
          });
          self2.timeoutTimer = setTimeout(function() {
            socket.removeListener("connect", onReqSockConnect);
            self2.abort();
            var e = new Error("ETIMEDOUT");
            e.code = "ETIMEDOUT";
            e.connect = true;
            self2.emit("error", e);
          }, timeout);
        } else {
          setReqTimeout();
        }
      }
      self2.emit("socket", socket);
    });
    self2.emit("request", self2.req);
  };
  Request.prototype.onRequestError = function(error) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (self2.req && self2.req._reusedSocket && error.code === "ECONNRESET" && self2.agent.addRequestNoreuse) {
      self2.agent = {addRequest: self2.agent.addRequestNoreuse.bind(self2.agent)};
      self2.start();
      self2.req.end();
      return;
    }
    if (self2.timeout && self2.timeoutTimer) {
      clearTimeout(self2.timeoutTimer);
      self2.timeoutTimer = null;
    }
    self2.emit("error", error);
  };
  Request.prototype.onRequestResponse = function(response) {
    var self2 = this;
    if (self2.timing) {
      self2.timings.response = now() - self2.startTimeNow;
    }
    debug("onRequestResponse", self2.uri.href, response.statusCode, response.headers);
    response.on("end", function() {
      if (self2.timing) {
        self2.timings.end = now() - self2.startTimeNow;
        response.timingStart = self2.startTime;
        if (!self2.timings.socket) {
          self2.timings.socket = 0;
        }
        if (!self2.timings.lookup) {
          self2.timings.lookup = self2.timings.socket;
        }
        if (!self2.timings.connect) {
          self2.timings.connect = self2.timings.lookup;
        }
        if (!self2.timings.response) {
          self2.timings.response = self2.timings.connect;
        }
        debug("elapsed time", self2.timings.end);
        self2.elapsedTime += Math.round(self2.timings.end);
        response.elapsedTime = self2.elapsedTime;
        response.timings = self2.timings;
        response.timingPhases = {
          wait: self2.timings.socket,
          dns: self2.timings.lookup - self2.timings.socket,
          tcp: self2.timings.connect - self2.timings.lookup,
          firstByte: self2.timings.response - self2.timings.connect,
          download: self2.timings.end - self2.timings.response,
          total: self2.timings.end
        };
      }
      debug("response end", self2.uri.href, response.statusCode, response.headers);
    });
    if (self2._aborted) {
      debug("aborted", self2.uri.href);
      response.resume();
      return;
    }
    self2.response = response;
    response.request = self2;
    response.toJSON = responseToJSON;
    if (self2.httpModule === https && self2.strictSSL && (!response.hasOwnProperty("socket") || !response.socket.authorized)) {
      debug("strict ssl error", self2.uri.href);
      var sslErr = response.hasOwnProperty("socket") ? response.socket.authorizationError : self2.uri.href + " does not support SSL";
      self2.emit("error", new Error("SSL Error: " + sslErr));
      return;
    }
    self2.originalHost = self2.getHeader("host");
    if (!self2.originalHostHeaderName) {
      self2.originalHostHeaderName = self2.hasHeader("host");
    }
    if (self2.setHost) {
      self2.removeHeader("host");
    }
    if (self2.timeout && self2.timeoutTimer) {
      clearTimeout(self2.timeoutTimer);
      self2.timeoutTimer = null;
    }
    var targetCookieJar = self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
    var addCookie = function(cookie) {
      try {
        targetCookieJar.setCookie(cookie, self2.uri.href, {ignoreError: true});
      } catch (e) {
        self2.emit("error", e);
      }
    };
    response.caseless = caseless(response.headers);
    if (response.caseless.has("set-cookie") && !self2._disableCookies) {
      var headerName = response.caseless.has("set-cookie");
      if (Array.isArray(response.headers[headerName])) {
        response.headers[headerName].forEach(addCookie);
      } else {
        addCookie(response.headers[headerName]);
      }
    }
    if (self2._redirect.onResponse(response)) {
      return;
    } else {
      response.on("close", function() {
        if (!self2._ended) {
          self2.response.emit("end");
        }
      });
      response.once("end", function() {
        self2._ended = true;
      });
      var noBody = function(code) {
        return self2.method === "HEAD" || code >= 100 && code < 200 || code === 204 || code === 304;
      };
      var responseContent;
      if (self2.gzip && !noBody(response.statusCode)) {
        var contentEncoding = response.headers["content-encoding"] || "identity";
        contentEncoding = contentEncoding.trim().toLowerCase();
        var zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (contentEncoding === "gzip") {
          responseContent = zlib.createGunzip(zlibOptions);
          response.pipe(responseContent);
        } else if (contentEncoding === "deflate") {
          responseContent = zlib.createInflate(zlibOptions);
          response.pipe(responseContent);
        } else {
          if (contentEncoding !== "identity") {
            debug("ignoring unrecognized Content-Encoding " + contentEncoding);
          }
          responseContent = response;
        }
      } else {
        responseContent = response;
      }
      if (self2.encoding) {
        if (self2.dests.length !== 0) {
          console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.");
        } else {
          responseContent.setEncoding(self2.encoding);
        }
      }
      if (self2._paused) {
        responseContent.pause();
      }
      self2.responseContent = responseContent;
      self2.emit("response", response);
      self2.dests.forEach(function(dest) {
        self2.pipeDest(dest);
      });
      responseContent.on("data", function(chunk) {
        if (self2.timing && !self2.responseStarted) {
          self2.responseStartTime = new Date().getTime();
          response.responseStartTime = self2.responseStartTime;
        }
        self2._destdata = true;
        self2.emit("data", chunk);
      });
      responseContent.once("end", function(chunk) {
        self2.emit("end", chunk);
      });
      responseContent.on("error", function(error) {
        self2.emit("error", error);
      });
      responseContent.on("close", function() {
        self2.emit("close");
      });
      if (self2.callback) {
        self2.readResponseBody(response);
      } else {
        self2.on("end", function() {
          if (self2._aborted) {
            debug("aborted", self2.uri.href);
            return;
          }
          self2.emit("complete", response);
        });
      }
    }
    debug("finish init function", self2.uri.href);
  };
  Request.prototype.readResponseBody = function(response) {
    var self2 = this;
    debug("reading response's body");
    var buffers = [];
    var bufferLength = 0;
    var strings = [];
    self2.on("data", function(chunk) {
      if (!Buffer2.isBuffer(chunk)) {
        strings.push(chunk);
      } else if (chunk.length) {
        bufferLength += chunk.length;
        buffers.push(chunk);
      }
    });
    self2.on("end", function() {
      debug("end event", self2.uri.href);
      if (self2._aborted) {
        debug("aborted", self2.uri.href);
        buffers = [];
        bufferLength = 0;
        return;
      }
      if (bufferLength) {
        debug("has body", self2.uri.href, bufferLength);
        response.body = Buffer2.concat(buffers, bufferLength);
        if (self2.encoding !== null) {
          response.body = response.body.toString(self2.encoding);
        }
        buffers = [];
        bufferLength = 0;
      } else if (strings.length) {
        if (self2.encoding === "utf8" && strings[0].length > 0 && strings[0][0] === "\uFEFF") {
          strings[0] = strings[0].substring(1);
        }
        response.body = strings.join("");
      }
      if (self2._json) {
        try {
          response.body = JSON.parse(response.body, self2._jsonReviver);
        } catch (e) {
          debug("invalid JSON received", self2.uri.href);
        }
      }
      debug("emitting complete", self2.uri.href);
      if (typeof response.body === "undefined" && !self2._json) {
        response.body = self2.encoding === null ? Buffer2.alloc(0) : "";
      }
      self2.emit("complete", response, response.body);
    });
  };
  Request.prototype.abort = function() {
    var self2 = this;
    self2._aborted = true;
    if (self2.req) {
      self2.req.abort();
    } else if (self2.response) {
      self2.response.destroy();
    }
    self2.emit("abort");
  };
  Request.prototype.pipeDest = function(dest) {
    var self2 = this;
    var response = self2.response;
    if (dest.headers && !dest.headersSent) {
      if (response.caseless.has("content-type")) {
        var ctname = response.caseless.has("content-type");
        if (dest.setHeader) {
          dest.setHeader(ctname, response.headers[ctname]);
        } else {
          dest.headers[ctname] = response.headers[ctname];
        }
      }
      if (response.caseless.has("content-length")) {
        var clname = response.caseless.has("content-length");
        if (dest.setHeader) {
          dest.setHeader(clname, response.headers[clname]);
        } else {
          dest.headers[clname] = response.headers[clname];
        }
      }
    }
    if (dest.setHeader && !dest.headersSent) {
      for (var i in response.headers) {
        if (!self2.gzip || i !== "content-encoding") {
          dest.setHeader(i, response.headers[i]);
        }
      }
      dest.statusCode = response.statusCode;
    }
    if (self2.pipefilter) {
      self2.pipefilter(response, dest);
    }
  };
  Request.prototype.qs = function(q2, clobber) {
    var self2 = this;
    var base;
    if (!clobber && self2.uri.query) {
      base = self2._qs.parse(self2.uri.query);
    } else {
      base = {};
    }
    for (var i in q2) {
      base[i] = q2[i];
    }
    var qs = self2._qs.stringify(base);
    if (qs === "") {
      return self2;
    }
    self2.uri = url.parse(self2.uri.href.split("?")[0] + "?" + qs);
    self2.url = self2.uri;
    self2.path = self2.uri.path;
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    return self2;
  };
  Request.prototype.form = function(form) {
    var self2 = this;
    if (form) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
        self2.setHeader("content-type", "application/x-www-form-urlencoded");
      }
      self2.body = typeof form === "string" ? self2._qs.rfc3986(form.toString("utf8")) : self2._qs.stringify(form).toString("utf8");
      return self2;
    }
    self2._form = new FormData();
    self2._form.on("error", function(err) {
      err.message = "form-data: " + err.message;
      self2.emit("error", err);
      self2.abort();
    });
    return self2._form;
  };
  Request.prototype.multipart = function(multipart) {
    var self2 = this;
    self2._multipart.onRequest(multipart);
    if (!self2._multipart.chunked) {
      self2.body = self2._multipart.body;
    }
    return self2;
  };
  Request.prototype.json = function(val) {
    var self2 = this;
    if (!self2.hasHeader("accept")) {
      self2.setHeader("accept", "application/json");
    }
    if (typeof self2.jsonReplacer === "function") {
      self2._jsonReplacer = self2.jsonReplacer;
    }
    self2._json = true;
    if (typeof val === "boolean") {
      if (self2.body !== void 0) {
        if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
          self2.body = safeStringify(self2.body, self2._jsonReplacer);
        } else {
          self2.body = self2._qs.rfc3986(self2.body);
        }
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
      }
    } else {
      self2.body = safeStringify(val, self2._jsonReplacer);
      if (!self2.hasHeader("content-type")) {
        self2.setHeader("content-type", "application/json");
      }
    }
    if (typeof self2.jsonReviver === "function") {
      self2._jsonReviver = self2.jsonReviver;
    }
    return self2;
  };
  Request.prototype.getHeader = function(name, headers) {
    var self2 = this;
    var result, re, match;
    if (!headers) {
      headers = self2.headers;
    }
    Object.keys(headers).forEach(function(key) {
      if (key.length !== name.length) {
        return;
      }
      re = new RegExp(name, "i");
      match = key.match(re);
      if (match) {
        result = headers[key];
      }
    });
    return result;
  };
  Request.prototype.enableUnixSocket = function() {
    var unixParts = this.uri.path.split(":");
    var host = unixParts[0];
    var path = unixParts[1];
    this.socketPath = host;
    this.uri.pathname = path;
    this.uri.path = path;
    this.uri.host = host;
    this.uri.hostname = host;
    this.uri.isUnix = true;
  };
  Request.prototype.auth = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    self2._auth.onRequest(user, pass, sendImmediately, bearer);
    return self2;
  };
  Request.prototype.aws = function(opts, now2) {
    var self2 = this;
    if (!now2) {
      self2._aws = opts;
      return self2;
    }
    if (opts.sign_version === 4 || opts.sign_version === "4") {
      var options = {
        host: self2.uri.host,
        path: self2.uri.path,
        method: self2.method,
        headers: self2.headers,
        body: self2.body
      };
      if (opts.service) {
        options.service = opts.service;
      }
      var signRes = aws4.sign(options, {
        accessKeyId: opts.key,
        secretAccessKey: opts.secret,
        sessionToken: opts.session
      });
      self2.setHeader("authorization", signRes.headers.Authorization);
      self2.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]);
      if (signRes.headers["X-Amz-Security-Token"]) {
        self2.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
      }
    } else {
      var date = new Date();
      self2.setHeader("date", date.toUTCString());
      var auth = {
        key: opts.key,
        secret: opts.secret,
        verb: self2.method.toUpperCase(),
        date,
        contentType: self2.getHeader("content-type") || "",
        md5: self2.getHeader("content-md5") || "",
        amazonHeaders: aws2.canonicalizeHeaders(self2.headers)
      };
      var path = self2.uri.path;
      if (opts.bucket && path) {
        auth.resource = "/" + opts.bucket + path;
      } else if (opts.bucket && !path) {
        auth.resource = "/" + opts.bucket;
      } else if (!opts.bucket && path) {
        auth.resource = path;
      } else if (!opts.bucket && !path) {
        auth.resource = "/";
      }
      auth.resource = aws2.canonicalizeResource(auth.resource);
      self2.setHeader("authorization", aws2.authorization(auth));
    }
    return self2;
  };
  Request.prototype.httpSignature = function(opts) {
    var self2 = this;
    httpSignature.signRequest({
      getHeader: function(header) {
        return self2.getHeader(header, self2.headers);
      },
      setHeader: function(header, value) {
        self2.setHeader(header, value);
      },
      method: self2.method,
      path: self2.path
    }, opts);
    debug("httpSignature authorization", self2.getHeader("authorization"));
    return self2;
  };
  Request.prototype.hawk = function(opts) {
    var self2 = this;
    self2.setHeader("Authorization", hawk.header(self2.uri, self2.method, opts));
  };
  Request.prototype.oauth = function(_oauth) {
    var self2 = this;
    self2._oauth.onRequest(_oauth);
    return self2;
  };
  Request.prototype.jar = function(jar) {
    var self2 = this;
    var cookies2;
    if (self2._redirect.redirectsFollowed === 0) {
      self2.originalCookieHeader = self2.getHeader("cookie");
    }
    if (!jar) {
      cookies2 = false;
      self2._disableCookies = true;
    } else {
      var targetCookieJar = jar && jar.getCookieString ? jar : globalCookieJar;
      var urihref = self2.uri.href;
      if (targetCookieJar) {
        cookies2 = targetCookieJar.getCookieString(urihref);
      }
    }
    if (cookies2 && cookies2.length) {
      if (self2.originalCookieHeader) {
        self2.setHeader("cookie", self2.originalCookieHeader + "; " + cookies2);
      } else {
        self2.setHeader("cookie", cookies2);
      }
    }
    self2._jar = jar;
    return self2;
  };
  Request.prototype.pipe = function(dest, opts) {
    var self2 = this;
    if (self2.response) {
      if (self2._destdata) {
        self2.emit("error", new Error("You cannot pipe after data has been emitted from the response."));
      } else if (self2._ended) {
        self2.emit("error", new Error("You cannot pipe after the response has been ended."));
      } else {
        stream.Stream.prototype.pipe.call(self2, dest, opts);
        self2.pipeDest(dest);
        return dest;
      }
    } else {
      self2.dests.push(dest);
      stream.Stream.prototype.pipe.call(self2, dest, opts);
      return dest;
    }
  };
  Request.prototype.write = function() {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      return self2.req.write.apply(self2.req, arguments);
    }
  };
  Request.prototype.end = function(chunk) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (chunk) {
      self2.write(chunk);
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      self2.req.end();
    }
  };
  Request.prototype.pause = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = true;
    } else {
      self2.responseContent.pause.apply(self2.responseContent, arguments);
    }
  };
  Request.prototype.resume = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = false;
    } else {
      self2.responseContent.resume.apply(self2.responseContent, arguments);
    }
  };
  Request.prototype.destroy = function() {
    var self2 = this;
    if (!self2._ended) {
      self2.end();
    } else if (self2.response) {
      self2.response.destroy();
    }
  };
  Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
  Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
  Request.prototype.toJSON = requestToJSON;
  module2.exports = Request;
});

// node_modules/request/index.js
var require_request3 = __commonJS((exports2, module2) => {
  "use strict";
  var extend2 = require_extend();
  var cookies = require_cookies();
  var helpers = require_helpers();
  var paramsHaveRequestBody = helpers.paramsHaveRequestBody;
  function initParams(uri, options, callback) {
    if (typeof options === "function") {
      callback = options;
    }
    var params = {};
    if (typeof options === "object") {
      extend2(params, options, {uri});
    } else if (typeof uri === "string") {
      extend2(params, {uri});
    } else {
      extend2(params, uri);
    }
    params.callback = callback || params.callback;
    return params;
  }
  function request(uri, options, callback) {
    if (typeof uri === "undefined") {
      throw new Error("undefined is not a valid uri or options object.");
    }
    var params = initParams(uri, options, callback);
    if (params.method === "HEAD" && paramsHaveRequestBody(params)) {
      throw new Error("HTTP HEAD requests MUST NOT include a request body.");
    }
    return new request.Request(params);
  }
  function verbFunc(verb) {
    var method = verb.toUpperCase();
    return function(uri, options, callback) {
      var params = initParams(uri, options, callback);
      params.method = method;
      return request(params, params.callback);
    };
  }
  request.get = verbFunc("get");
  request.head = verbFunc("head");
  request.options = verbFunc("options");
  request.post = verbFunc("post");
  request.put = verbFunc("put");
  request.patch = verbFunc("patch");
  request.del = verbFunc("delete");
  request["delete"] = verbFunc("delete");
  request.jar = function(store) {
    return cookies.jar(store);
  };
  request.cookie = function(str) {
    return cookies.parse(str);
  };
  function wrapRequestMethod(method, options, requester, verb) {
    return function(uri, opts, callback) {
      var params = initParams(uri, opts, callback);
      var target = {};
      extend2(true, target, options, params);
      target.pool = params.pool || options.pool;
      if (verb) {
        target.method = verb.toUpperCase();
      }
      if (typeof requester === "function") {
        method = requester;
      }
      return method(target, target.callback);
    };
  }
  request.defaults = function(options, requester) {
    var self2 = this;
    options = options || {};
    if (typeof options === "function") {
      requester = options;
      options = {};
    }
    var defaults = wrapRequestMethod(self2, options, requester);
    var verbs = ["get", "head", "post", "put", "patch", "del", "delete"];
    verbs.forEach(function(verb) {
      defaults[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
    });
    defaults.cookie = wrapRequestMethod(self2.cookie, options, requester);
    defaults.jar = self2.jar;
    defaults.defaults = self2.defaults;
    return defaults;
  };
  request.forever = function(agentOptions, optionsArg) {
    var options = {};
    if (optionsArg) {
      extend2(options, optionsArg);
    }
    if (agentOptions) {
      options.agentOptions = agentOptions;
    }
    options.forever = true;
    return request.defaults(options);
  };
  module2.exports = request;
  request.Request = require_request2();
  request.initParams = initParams;
  Object.defineProperty(request, "debug", {
    enumerable: true,
    get: function() {
      return request.Request.debug;
    },
    set: function(debug) {
      request.Request.debug = debug;
    }
  });
});

// node_modules/solargraph-utils/out/Server.js
var require_Server = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var cmd = require_commands();
  var request = require_request3();
  var timers_1 = require("timers");
  var Server = class {
    constructor(config) {
      this.child = null;
      this._port = null;
      this.pid = null;
      this.configure(config);
    }
    isRunning() {
      return this.child != null && this.port != null && this.pid != null;
    }
    get port() {
      return this._port;
    }
    get url() {
      return "http://localhost:" + this.port;
    }
    configure(config) {
      this.configuration = config;
    }
    start() {
      return new Promise((resolve, reject) => {
        var started = false;
        if (this.child) {
          console.warn("There is already a process running for the Solargraph server.");
        } else {
          console.log("Starting the server");
          var args = ["server", "--port", "0"];
          if (this.configuration.viewsPath) {
            args.push("--views", this.configuration.viewsPath);
          }
          this.child = cmd.solargraphCommand(args, this.configuration);
          this.child.stderr.on("data", (data) => {
            var out = data.toString();
            console.log(out);
            if (!this.port) {
              var match = out.match(/port=([0-9]*)/);
              if (match) {
                this._port = parseInt(match[1]);
              }
              match = out.match(/pid=([0-9]*)/);
              if (match) {
                this.pid = parseInt(match[1]);
              }
            }
            if (this.isRunning() && !started) {
              started = true;
              resolve();
            }
          });
          this.child.on("exit", () => {
            this._port = null;
            if (!started) {
              reject();
            }
          });
        }
      });
    }
    update(filename, workspace4) {
      return new Promise((resolve, reject) => {
        request.post({url: this.url + "/update", form: {
          filename,
          workspace: workspace4
        }}, function(err, httpResponse, body) {
          if (err) {
            reject();
          } else {
            if (httpResponse.statusCode == 200) {
              resolve(JSON.parse(body));
            } else {
              reject("Server responded with " + httpResponse.statusCode);
            }
          }
        });
      });
    }
    stop() {
      if (!this.child) {
        console.warn("The server is not running.");
      } else {
        this.child.kill();
        if (this.pid) {
          process.kill(this.pid);
        }
        this.pid = null;
        this._port = null;
        this.child = null;
      }
    }
    restart() {
      this.stop();
      return this.start();
    }
    wait() {
      return new Promise((resolve) => {
        if (this.isRunning()) {
          resolve(true);
        } else {
          var interval = setInterval(() => {
            if (this.isRunning()) {
              timers_1.clearInterval(interval);
              resolve(true);
            }
          }, 100);
        }
      });
    }
    post(path, params) {
      return new Promise((resolve, reject) => {
        request.post({
          url: this.url + path,
          form: params
        }, function(err, response, body) {
          if (err) {
            reject();
          } else {
            if (response.headers["content-type"] && response.headers["content-type"].includes("json")) {
              resolve(JSON.parse(body));
            } else {
              resolve(body);
            }
          }
        });
      });
    }
    prepare(workspace4) {
      return new Promise((resolve, reject) => {
        request.post({url: this.url + "/prepare", form: {
          workspace: workspace4
        }}, function(err, response, body) {
          if (err) {
            reject();
          } else {
            resolve();
          }
        });
      });
    }
    suggest(text, line, column, filename, workspace4, withSnippets) {
      return new Promise((resolve, reject) => {
        if (this.isRunning()) {
          request.post({
            url: this.url + "/suggest",
            form: {
              text,
              line,
              column,
              filename: filename || null,
              workspace: workspace4 || null,
              with_snippets: withSnippets || false
            }
          }, function(err, httpResponse, body) {
            if (err) {
              reject({status: "err", message: err});
            } else {
              if (httpResponse.statusCode == 200) {
                resolve(JSON.parse(body));
              } else {
                reject("Server responded with " + httpResponse.statusCode);
              }
            }
          });
        } else {
          reject({status: "err", message: "The server is not running"});
        }
      });
    }
    define(text, line, column, filename, workspace4) {
      return new Promise((resolve, reject) => {
        if (this.isRunning()) {
          request.post({url: this.url + "/hover", form: {
            text,
            line,
            column,
            filename: filename || null,
            workspace: workspace4 || null
          }}, function(err, httpResponse, body) {
            if (err) {
              reject(err);
            } else {
              if (httpResponse.statusCode == 200) {
                resolve(JSON.parse(body));
              } else {
                reject("Server responded with " + httpResponse.statusCode);
              }
            }
          });
        } else {
          reject();
        }
      });
    }
    hover(text, line, column, filename, workspace4) {
      return this.define(text, line, column, filename, workspace4);
    }
    resolve(path, workspace4) {
      return new Promise((resolve, reject) => {
        if (this.isRunning()) {
          request.post({url: this.url + "/resolve", form: {
            path,
            workspace: workspace4 || null
          }}, function(err, httpResponse, body) {
            if (err) {
              reject(err);
            } else {
              if (httpResponse.statusCode == 200) {
                resolve(JSON.parse(body));
              } else {
                reject("Server responded with " + httpResponse.statusCode);
              }
            }
          });
        } else {
          reject();
        }
      });
    }
    signify(text, line, column, filename, workspace4) {
      return new Promise((resolve, reject) => {
        if (this.isRunning()) {
          request.post({
            url: this.url + "/signify",
            form: {
              text,
              filename: filename || null,
              line,
              column,
              workspace: workspace4 || null
            }
          }, function(err, httpResponse, body) {
            if (err) {
              console.log(err);
            } else {
              if (httpResponse.statusCode == 200) {
                resolve(JSON.parse(body));
              } else {
              }
            }
          });
        }
      });
    }
  };
  exports2.Server = Server;
});

// node_modules/solargraph-utils/out/SocketProvider.js
var require_SocketProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var commands_1 = require_commands();
  var SocketProvider2 = class {
    constructor(configuration) {
      this.configuration = configuration;
      this.listening = false;
    }
    start() {
      return new Promise((resolve, reject) => {
        this.child = commands_1.solargraphCommand(["socket", "--port", "0"], this.configuration);
        let buffer = "";
        let that = this;
        this.child.stderr.on("data", (data) => {
          console.log(data.toString());
          if (!that.isListening()) {
            buffer += data.toString();
            var match = buffer.match(/PORT=([0-9]*)[\s]+PID=([0-9]*)/);
            if (match) {
              that.listening = true;
              that._port = parseInt(match[1]);
              that._pid = parseInt(match[2]);
              resolve();
            }
          }
        });
        this.child.on("error", (err) => {
          if (!that.isListening()) {
            reject(err);
          }
        });
        this.child.on("exit", (code) => {
          if (!that.isListening()) {
            reject(buffer);
          }
        });
      });
    }
    stop() {
      if (!this.child) {
        console.warn("The server is not running.");
      } else {
        this.child.kill();
        if (this._pid) {
          process.kill(this._pid);
        }
        this._pid = null;
        this._port = null;
        this.child = null;
        this.listening = false;
      }
    }
    restart() {
      this.stop();
      return this.start();
    }
    isListening() {
      return this.listening;
    }
    get port() {
      return this._port;
    }
    get process() {
      return this.child;
    }
  };
  exports2.SocketProvider = SocketProvider2;
});

// node_modules/solargraph-utils/out/index.js
var require_out2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Configuration_1 = require_Configuration();
  exports2.Configuration = Configuration_1.Configuration;
  var Server_1 = require_Server();
  exports2.Server = Server_1.Server;
  var SocketProvider_1 = require_SocketProvider();
  exports2.SocketProvider = SocketProvider_1.SocketProvider;
  var commands4 = require_commands();
  exports2.commands = commands4;
  var path = require("path");
  var fs = require("fs");
  function nearestWorkspace(file, parent) {
    var result = null;
    var cursor = path.dirname(file);
    if (parent == cursor) {
      result = cursor;
    } else {
      var root2 = parent || cursor;
      while (cursor.startsWith(root2)) {
        var sy = path.join(cursor, ".solargraph.yml");
        if (fs.existsSync(sy) && fs.lstatSync(sy).isFile()) {
          result = cursor;
          break;
        }
        cursor = path.dirname(cursor);
      }
      if (!result)
        result = parent;
    }
    return result;
  }
  exports2.nearestWorkspace = nearestWorkspace;
  function verifyGemIsInstalled(configuration) {
    return new Promise((resolve, reject) => {
      var solargraphTest = commands4.solargraphCommand(["help"], configuration);
      solargraphTest.on("exit", (code) => {
        if (code == 0) {
          resolve(true);
        } else {
          resolve(false);
        }
      });
      solargraphTest.on("error", (err) => {
        console.log(err);
        resolve(false);
      });
    });
  }
  exports2.verifyGemIsInstalled = verifyGemIsInstalled;
  function verifyGemIsCurrent(configuration) {
    return new Promise((resolve, reject) => {
      let child = commands4.gemCommand(["outdated"], configuration);
      let result = "\n";
      child.stdout.on("data", (data) => {
        result += data.toString();
      });
      child.on("exit", (code) => {
        if (code == 0) {
          if (result.match(/[\s]solargraph[\s]/)) {
            resolve(false);
          } else {
            resolve(true);
          }
        } else {
          reject();
        }
      });
    });
  }
  exports2.verifyGemIsCurrent = verifyGemIsCurrent;
  function writeConfigFile(configuration) {
    return new Promise((resolve, reject) => {
      var child = commands4.solargraphCommand(["config", "."], configuration);
      child.on("exit", (code) => {
        if (code == 0) {
          resolve(true);
        } else {
          reject(false);
        }
      });
    });
  }
  exports2.writeConfigFile = writeConfigFile;
  function updateGemDocumentation(configuration) {
    console.log("Updating gem yardocs");
    commands4.yardCommand(["gems"], configuration);
  }
  exports2.updateGemDocumentation = updateGemDocumentation;
  function installGem2(configuration) {
    return new Promise((resolve, reject) => {
      var child = commands4.gemCommand(["install", "solargraph"], configuration);
      child.on("exit", (code) => {
        if (code == 0) {
          resolve(true);
        } else {
          reject(false);
        }
      });
    });
  }
  exports2.installGem = installGem2;
  function updateGem(configuration) {
    return new Promise((resolve, reject) => {
      var child = commands4.gemCommand(["update", "solargraph"], configuration);
      child.on("exit", (code) => {
        if (code == 0) {
          resolve(true);
        } else {
          reject(false);
        }
      });
    });
  }
  exports2.updateGem = updateGem;
});

// node_modules/domino/lib/Event.js
var require_Event = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Event;
  Event.CAPTURING_PHASE = 1;
  Event.AT_TARGET = 2;
  Event.BUBBLING_PHASE = 3;
  function Event(type, dictionary) {
    this.type = "";
    this.target = null;
    this.currentTarget = null;
    this.eventPhase = Event.AT_TARGET;
    this.bubbles = false;
    this.cancelable = false;
    this.isTrusted = false;
    this.defaultPrevented = false;
    this.timeStamp = Date.now();
    this._propagationStopped = false;
    this._immediatePropagationStopped = false;
    this._initialized = true;
    this._dispatching = false;
    if (type)
      this.type = type;
    if (dictionary) {
      for (var p in dictionary) {
        this[p] = dictionary[p];
      }
    }
  }
  Event.prototype = Object.create(Object.prototype, {
    constructor: {value: Event},
    stopPropagation: {value: function stopPropagation() {
      this._propagationStopped = true;
    }},
    stopImmediatePropagation: {value: function stopImmediatePropagation() {
      this._propagationStopped = true;
      this._immediatePropagationStopped = true;
    }},
    preventDefault: {value: function preventDefault() {
      if (this.cancelable)
        this.defaultPrevented = true;
    }},
    initEvent: {value: function initEvent(type, bubbles, cancelable) {
      this._initialized = true;
      if (this._dispatching)
        return;
      this._propagationStopped = false;
      this._immediatePropagationStopped = false;
      this.defaultPrevented = false;
      this.isTrusted = false;
      this.target = null;
      this.type = type;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
    }}
  });
});

// node_modules/domino/lib/UIEvent.js
var require_UIEvent = __commonJS((exports2, module2) => {
  "use strict";
  var Event = require_Event();
  module2.exports = UIEvent;
  function UIEvent() {
    Event.call(this);
    this.view = null;
    this.detail = 0;
  }
  UIEvent.prototype = Object.create(Event.prototype, {
    constructor: {value: UIEvent},
    initUIEvent: {value: function(type, bubbles, cancelable, view, detail) {
      this.initEvent(type, bubbles, cancelable);
      this.view = view;
      this.detail = detail;
    }}
  });
});

// node_modules/domino/lib/MouseEvent.js
var require_MouseEvent = __commonJS((exports2, module2) => {
  "use strict";
  var UIEvent = require_UIEvent();
  module2.exports = MouseEvent;
  function MouseEvent() {
    UIEvent.call(this);
    this.screenX = this.screenY = this.clientX = this.clientY = 0;
    this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;
    this.button = 0;
    this.buttons = 1;
    this.relatedTarget = null;
  }
  MouseEvent.prototype = Object.create(UIEvent.prototype, {
    constructor: {value: MouseEvent},
    initMouseEvent: {value: function(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      this.initEvent(type, bubbles, cancelable, view, detail);
      this.screenX = screenX;
      this.screenY = screenY;
      this.clientX = clientX;
      this.clientY = clientY;
      this.ctrlKey = ctrlKey;
      this.altKey = altKey;
      this.shiftKey = shiftKey;
      this.metaKey = metaKey;
      this.button = button;
      switch (button) {
        case 0:
          this.buttons = 1;
          break;
        case 1:
          this.buttons = 4;
          break;
        case 2:
          this.buttons = 2;
          break;
        default:
          this.buttons = 0;
          break;
      }
      this.relatedTarget = relatedTarget;
    }},
    getModifierState: {value: function(key) {
      switch (key) {
        case "Alt":
          return this.altKey;
        case "Control":
          return this.ctrlKey;
        case "Shift":
          return this.shiftKey;
        case "Meta":
          return this.metaKey;
        default:
          return false;
      }
    }}
  });
});

// node_modules/domino/lib/DOMException.js
var require_DOMException = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = DOMException;
  var INDEX_SIZE_ERR = 1;
  var HIERARCHY_REQUEST_ERR = 3;
  var WRONG_DOCUMENT_ERR = 4;
  var INVALID_CHARACTER_ERR = 5;
  var NO_MODIFICATION_ALLOWED_ERR = 7;
  var NOT_FOUND_ERR = 8;
  var NOT_SUPPORTED_ERR = 9;
  var INVALID_STATE_ERR = 11;
  var SYNTAX_ERR = 12;
  var INVALID_MODIFICATION_ERR = 13;
  var NAMESPACE_ERR = 14;
  var INVALID_ACCESS_ERR = 15;
  var TYPE_MISMATCH_ERR = 17;
  var SECURITY_ERR = 18;
  var NETWORK_ERR = 19;
  var ABORT_ERR = 20;
  var URL_MISMATCH_ERR = 21;
  var QUOTA_EXCEEDED_ERR = 22;
  var TIMEOUT_ERR = 23;
  var INVALID_NODE_TYPE_ERR = 24;
  var DATA_CLONE_ERR = 25;
  var names = [
    null,
    "INDEX_SIZE_ERR",
    null,
    "HIERARCHY_REQUEST_ERR",
    "WRONG_DOCUMENT_ERR",
    "INVALID_CHARACTER_ERR",
    null,
    "NO_MODIFICATION_ALLOWED_ERR",
    "NOT_FOUND_ERR",
    "NOT_SUPPORTED_ERR",
    "INUSE_ATTRIBUTE_ERR",
    "INVALID_STATE_ERR",
    "SYNTAX_ERR",
    "INVALID_MODIFICATION_ERR",
    "NAMESPACE_ERR",
    "INVALID_ACCESS_ERR",
    null,
    "TYPE_MISMATCH_ERR",
    "SECURITY_ERR",
    "NETWORK_ERR",
    "ABORT_ERR",
    "URL_MISMATCH_ERR",
    "QUOTA_EXCEEDED_ERR",
    "TIMEOUT_ERR",
    "INVALID_NODE_TYPE_ERR",
    "DATA_CLONE_ERR"
  ];
  var messages = [
    null,
    "INDEX_SIZE_ERR (1): the index is not in the allowed range",
    null,
    "HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model",
    "WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required",
    "INVALID_CHARACTER_ERR (5): the string contains invalid characters",
    null,
    "NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified",
    "NOT_FOUND_ERR (8): the object can not be found here",
    "NOT_SUPPORTED_ERR (9): this operation is not supported",
    "INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute",
    "INVALID_STATE_ERR (11): the object is in an invalid state",
    "SYNTAX_ERR (12): the string did not match the expected pattern",
    "INVALID_MODIFICATION_ERR (13): the object can not be modified in this way",
    "NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML",
    "INVALID_ACCESS_ERR (15): the object does not support the operation or argument",
    null,
    "TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type",
    "SECURITY_ERR (18): the operation is insecure",
    "NETWORK_ERR (19): a network error occurred",
    "ABORT_ERR (20): the user aborted an operation",
    "URL_MISMATCH_ERR (21): the given URL does not match another URL",
    "QUOTA_EXCEEDED_ERR (22): the quota has been exceeded",
    "TIMEOUT_ERR (23): a timeout occurred",
    "INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation",
    "DATA_CLONE_ERR (25): the object can not be cloned."
  ];
  var constants = {
    INDEX_SIZE_ERR,
    DOMSTRING_SIZE_ERR: 2,
    HIERARCHY_REQUEST_ERR,
    WRONG_DOCUMENT_ERR,
    INVALID_CHARACTER_ERR,
    NO_DATA_ALLOWED_ERR: 6,
    NO_MODIFICATION_ALLOWED_ERR,
    NOT_FOUND_ERR,
    NOT_SUPPORTED_ERR,
    INUSE_ATTRIBUTE_ERR: 10,
    INVALID_STATE_ERR,
    SYNTAX_ERR,
    INVALID_MODIFICATION_ERR,
    NAMESPACE_ERR,
    INVALID_ACCESS_ERR,
    VALIDATION_ERR: 16,
    TYPE_MISMATCH_ERR,
    SECURITY_ERR,
    NETWORK_ERR,
    ABORT_ERR,
    URL_MISMATCH_ERR,
    QUOTA_EXCEEDED_ERR,
    TIMEOUT_ERR,
    INVALID_NODE_TYPE_ERR,
    DATA_CLONE_ERR
  };
  function DOMException(code) {
    Error.call(this);
    Error.captureStackTrace(this, this.constructor);
    this.code = code;
    this.message = messages[code];
    this.name = names[code];
  }
  DOMException.prototype.__proto__ = Error.prototype;
  for (var c in constants) {
    v = {value: constants[c]};
    Object.defineProperty(DOMException, c, v);
    Object.defineProperty(DOMException.prototype, c, v);
  }
  var v;
});

// node_modules/domino/lib/config.js
var require_config = __commonJS((exports2) => {
  exports2.isApiWritable = !global.__domino_frozen__;
});

// node_modules/domino/lib/utils.js
var require_utils4 = __commonJS((exports2) => {
  "use strict";
  var DOMException = require_DOMException();
  var ERR = DOMException;
  var isApiWritable = require_config().isApiWritable;
  exports2.NAMESPACE = {
    HTML: "http://www.w3.org/1999/xhtml",
    XML: "http://www.w3.org/XML/1998/namespace",
    XMLNS: "http://www.w3.org/2000/xmlns/",
    MATHML: "http://www.w3.org/1998/Math/MathML",
    SVG: "http://www.w3.org/2000/svg",
    XLINK: "http://www.w3.org/1999/xlink"
  };
  exports2.IndexSizeError = function() {
    throw new DOMException(ERR.INDEX_SIZE_ERR);
  };
  exports2.HierarchyRequestError = function() {
    throw new DOMException(ERR.HIERARCHY_REQUEST_ERR);
  };
  exports2.WrongDocumentError = function() {
    throw new DOMException(ERR.WRONG_DOCUMENT_ERR);
  };
  exports2.InvalidCharacterError = function() {
    throw new DOMException(ERR.INVALID_CHARACTER_ERR);
  };
  exports2.NoModificationAllowedError = function() {
    throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR);
  };
  exports2.NotFoundError = function() {
    throw new DOMException(ERR.NOT_FOUND_ERR);
  };
  exports2.NotSupportedError = function() {
    throw new DOMException(ERR.NOT_SUPPORTED_ERR);
  };
  exports2.InvalidStateError = function() {
    throw new DOMException(ERR.INVALID_STATE_ERR);
  };
  exports2.SyntaxError = function() {
    throw new DOMException(ERR.SYNTAX_ERR);
  };
  exports2.InvalidModificationError = function() {
    throw new DOMException(ERR.INVALID_MODIFICATION_ERR);
  };
  exports2.NamespaceError = function() {
    throw new DOMException(ERR.NAMESPACE_ERR);
  };
  exports2.InvalidAccessError = function() {
    throw new DOMException(ERR.INVALID_ACCESS_ERR);
  };
  exports2.TypeMismatchError = function() {
    throw new DOMException(ERR.TYPE_MISMATCH_ERR);
  };
  exports2.SecurityError = function() {
    throw new DOMException(ERR.SECURITY_ERR);
  };
  exports2.NetworkError = function() {
    throw new DOMException(ERR.NETWORK_ERR);
  };
  exports2.AbortError = function() {
    throw new DOMException(ERR.ABORT_ERR);
  };
  exports2.UrlMismatchError = function() {
    throw new DOMException(ERR.URL_MISMATCH_ERR);
  };
  exports2.QuotaExceededError = function() {
    throw new DOMException(ERR.QUOTA_EXCEEDED_ERR);
  };
  exports2.TimeoutError = function() {
    throw new DOMException(ERR.TIMEOUT_ERR);
  };
  exports2.InvalidNodeTypeError = function() {
    throw new DOMException(ERR.INVALID_NODE_TYPE_ERR);
  };
  exports2.DataCloneError = function() {
    throw new DOMException(ERR.DATA_CLONE_ERR);
  };
  exports2.nyi = function() {
    throw new Error("NotYetImplemented");
  };
  exports2.shouldOverride = function() {
    throw new Error("Abstract function; should be overriding in subclass.");
  };
  exports2.assert = function(expr, msg) {
    if (!expr) {
      throw new Error("Assertion failed: " + (msg || "") + "\n" + new Error().stack);
    }
  };
  exports2.expose = function(src, c) {
    for (var n in src) {
      Object.defineProperty(c.prototype, n, {value: src[n], writable: isApiWritable});
    }
  };
  exports2.merge = function(a, b) {
    for (var n in b) {
      a[n] = b[n];
    }
  };
  exports2.documentOrder = function(n, m) {
    return 3 - (n.compareDocumentPosition(m) & 6);
  };
  exports2.toASCIILowerCase = function(s) {
    return s.replace(/[A-Z]+/g, function(c) {
      return c.toLowerCase();
    });
  };
  exports2.toASCIIUpperCase = function(s) {
    return s.replace(/[a-z]+/g, function(c) {
      return c.toUpperCase();
    });
  };
});

// node_modules/domino/lib/EventTarget.js
var require_EventTarget = __commonJS((exports2, module2) => {
  "use strict";
  var Event = require_Event();
  var MouseEvent = require_MouseEvent();
  var utils = require_utils4();
  module2.exports = EventTarget;
  function EventTarget() {
  }
  EventTarget.prototype = {
    addEventListener: function addEventListener(type, listener, capture) {
      if (!listener)
        return;
      if (capture === void 0)
        capture = false;
      if (!this._listeners)
        this._listeners = Object.create(null);
      if (!this._listeners[type])
        this._listeners[type] = [];
      var list = this._listeners[type];
      for (var i = 0, n = list.length; i < n; i++) {
        var l = list[i];
        if (l.listener === listener && l.capture === capture)
          return;
      }
      var obj = {listener, capture};
      if (typeof listener === "function")
        obj.f = listener;
      list.push(obj);
    },
    removeEventListener: function removeEventListener(type, listener, capture) {
      if (capture === void 0)
        capture = false;
      if (this._listeners) {
        var list = this._listeners[type];
        if (list) {
          for (var i = 0, n = list.length; i < n; i++) {
            var l = list[i];
            if (l.listener === listener && l.capture === capture) {
              if (list.length === 1) {
                this._listeners[type] = void 0;
              } else {
                list.splice(i, 1);
              }
              return;
            }
          }
        }
      }
    },
    dispatchEvent: function dispatchEvent(event) {
      return this._dispatchEvent(event, false);
    },
    _dispatchEvent: function _dispatchEvent(event, trusted) {
      if (typeof trusted !== "boolean")
        trusted = false;
      function invoke(target, event2) {
        var type = event2.type, phase = event2.eventPhase;
        event2.currentTarget = target;
        if (phase !== Event.CAPTURING_PHASE && target._handlers && target._handlers[type]) {
          var handler = target._handlers[type];
          var rv;
          if (typeof handler === "function") {
            rv = handler.call(event2.currentTarget, event2);
          } else {
            var f = handler.handleEvent;
            if (typeof f !== "function")
              throw new TypeError("handleEvent property of event handler object isnot a function.");
            rv = f.call(handler, event2);
          }
          switch (event2.type) {
            case "mouseover":
              if (rv === true)
                event2.preventDefault();
              break;
            case "beforeunload":
            default:
              if (rv === false)
                event2.preventDefault();
              break;
          }
        }
        var list = target._listeners && target._listeners[type];
        if (!list)
          return;
        list = list.slice();
        for (var i2 = 0, n2 = list.length; i2 < n2; i2++) {
          if (event2._immediatePropagationStopped)
            return;
          var l = list[i2];
          if (phase === Event.CAPTURING_PHASE && !l.capture || phase === Event.BUBBLING_PHASE && l.capture)
            continue;
          if (l.f) {
            l.f.call(event2.currentTarget, event2);
          } else {
            var fn = l.listener.handleEvent;
            if (typeof fn !== "function")
              throw new TypeError("handleEvent property of event listener object is not a function.");
            fn.call(l.listener, event2);
          }
        }
      }
      if (!event._initialized || event._dispatching)
        utils.InvalidStateError();
      event.isTrusted = trusted;
      event._dispatching = true;
      event.target = this;
      var ancestors = [];
      for (var n = this.parentNode; n; n = n.parentNode)
        ancestors.push(n);
      event.eventPhase = Event.CAPTURING_PHASE;
      for (var i = ancestors.length - 1; i >= 0; i--) {
        invoke(ancestors[i], event);
        if (event._propagationStopped)
          break;
      }
      if (!event._propagationStopped) {
        event.eventPhase = Event.AT_TARGET;
        invoke(this, event);
      }
      if (event.bubbles && !event._propagationStopped) {
        event.eventPhase = Event.BUBBLING_PHASE;
        for (var ii = 0, nn = ancestors.length; ii < nn; ii++) {
          invoke(ancestors[ii], event);
          if (event._propagationStopped)
            break;
        }
      }
      event._dispatching = false;
      event.eventPhase = Event.AT_TARGET;
      event.currentTarget = null;
      if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {
        switch (event.type) {
          case "mousedown":
            this._armed = {
              x: event.clientX,
              y: event.clientY,
              t: event.timeStamp
            };
            break;
          case "mouseout":
          case "mouseover":
            this._armed = null;
            break;
          case "mouseup":
            if (this._isClick(event))
              this._doClick(event);
            this._armed = null;
            break;
        }
      }
      return !event.defaultPrevented;
    },
    _isClick: function(event) {
      return this._armed !== null && event.type === "mouseup" && event.isTrusted && event.button === 0 && event.timeStamp - this._armed.t < 1e3 && Math.abs(event.clientX - this._armed.x) < 10 && Math.abs(event.clientY - this._armed.Y) < 10;
    },
    _doClick: function(event) {
      if (this._click_in_progress)
        return;
      this._click_in_progress = true;
      var activated = this;
      while (activated && !activated._post_click_activation_steps)
        activated = activated.parentNode;
      if (activated && activated._pre_click_activation_steps) {
        activated._pre_click_activation_steps();
      }
      var click = this.ownerDocument.createEvent("MouseEvent");
      click.initMouseEvent("click", true, true, this.ownerDocument.defaultView, 1, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, null);
      var result = this._dispatchEvent(click, true);
      if (activated) {
        if (result) {
          if (activated._post_click_activation_steps)
            activated._post_click_activation_steps(click);
        } else {
          if (activated._cancelled_activation_steps)
            activated._cancelled_activation_steps();
        }
      }
    },
    _setEventHandler: function _setEventHandler(type, handler) {
      if (!this._handlers)
        this._handlers = Object.create(null);
      this._handlers[type] = handler;
    },
    _getEventHandler: function _getEventHandler(type) {
      return this._handlers && this._handlers[type] || null;
    }
  };
});

// node_modules/domino/lib/LinkedList.js
var require_LinkedList = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  var LinkedList = module2.exports = {
    valid: function(a) {
      utils.assert(a, "list falsy");
      utils.assert(a._previousSibling, "previous falsy");
      utils.assert(a._nextSibling, "next falsy");
      return true;
    },
    insertBefore: function(a, b) {
      utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
      var a_first = a, a_last = a._previousSibling;
      var b_first = b, b_last = b._previousSibling;
      a_first._previousSibling = b_last;
      a_last._nextSibling = b_first;
      b_last._nextSibling = a_first;
      b_first._previousSibling = a_last;
      utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
    },
    replace: function(a, b) {
      utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
      if (b !== null) {
        LinkedList.insertBefore(b, a);
      }
      LinkedList.remove(a);
      utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
    },
    remove: function(a) {
      utils.assert(LinkedList.valid(a));
      var prev = a._previousSibling;
      if (prev === a) {
        return;
      }
      var next2 = a._nextSibling;
      prev._nextSibling = next2;
      next2._previousSibling = prev;
      a._previousSibling = a._nextSibling = a;
      utils.assert(LinkedList.valid(a));
    }
  };
});

// node_modules/domino/lib/NodeUtils.js
var require_NodeUtils = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    serializeOne
  };
  var utils = require_utils4();
  var NAMESPACE = utils.NAMESPACE;
  var hasRawContent = {
    STYLE: true,
    SCRIPT: true,
    XMP: true,
    IFRAME: true,
    NOEMBED: true,
    NOFRAMES: true,
    PLAINTEXT: true
  };
  var emptyElements = {
    area: true,
    base: true,
    basefont: true,
    bgsound: true,
    br: true,
    col: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var extraNewLine = {};
  function escape(s) {
    return s.replace(/[&<>\u00A0]/g, function(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\xA0":
          return "&nbsp;";
      }
    });
  }
  function escapeAttr(s) {
    var toEscape = /[&"\u00A0]/g;
    if (!toEscape.test(s)) {
      return s;
    } else {
      return s.replace(toEscape, function(c) {
        switch (c) {
          case "&":
            return "&amp;";
          case '"':
            return "&quot;";
          case "\xA0":
            return "&nbsp;";
        }
      });
    }
  }
  function attrname(a) {
    var ns = a.namespaceURI;
    if (!ns)
      return a.localName;
    if (ns === NAMESPACE.XML)
      return "xml:" + a.localName;
    if (ns === NAMESPACE.XLINK)
      return "xlink:" + a.localName;
    if (ns === NAMESPACE.XMLNS) {
      if (a.localName === "xmlns")
        return "xmlns";
      else
        return "xmlns:" + a.localName;
    }
    return a.name;
  }
  function serializeOne(kid, parent) {
    var s = "";
    switch (kid.nodeType) {
      case 1:
        var ns = kid.namespaceURI;
        var html = ns === NAMESPACE.HTML;
        var tagname = html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML ? kid.localName : kid.tagName;
        s += "<" + tagname;
        for (var j = 0, k = kid._numattrs; j < k; j++) {
          var a = kid._attr(j);
          s += " " + attrname(a);
          if (a.value !== void 0)
            s += '="' + escapeAttr(a.value) + '"';
        }
        s += ">";
        if (!(html && emptyElements[tagname])) {
          var ss = kid.serialize();
          if (html && extraNewLine[tagname] && ss.charAt(0) === "\n")
            s += "\n";
          s += ss;
          s += "</" + tagname + ">";
        }
        break;
      case 3:
      case 4:
        var parenttag;
        if (parent.nodeType === 1 && parent.namespaceURI === NAMESPACE.HTML)
          parenttag = parent.tagName;
        else
          parenttag = "";
        if (hasRawContent[parenttag] || parenttag === "NOSCRIPT" && parent.ownerDocument._scripting_enabled) {
          s += kid.data;
        } else {
          s += escape(kid.data);
        }
        break;
      case 8:
        s += "<!--" + kid.data + "-->";
        break;
      case 7:
        s += "<?" + kid.target + " " + kid.data + "?>";
        break;
      case 10:
        s += "<!DOCTYPE " + kid.name;
        if (false) {
          if (kid.publicID) {
            s += ' PUBLIC "' + kid.publicId + '"';
          }
          if (kid.systemId) {
            s += ' "' + kid.systemId + '"';
          }
        }
        s += ">";
        break;
      default:
        utils.InvalidStateError();
    }
    return s;
  }
});

// node_modules/domino/lib/Node.js
var require_Node = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Node2;
  var EventTarget = require_EventTarget();
  var LinkedList = require_LinkedList();
  var NodeUtils = require_NodeUtils();
  var utils = require_utils4();
  function Node2() {
    EventTarget.call(this);
    this.parentNode = null;
    this._nextSibling = this._previousSibling = this;
    this._index = void 0;
  }
  var ELEMENT_NODE = Node2.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = Node2.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = Node2.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = Node2.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = Node2.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = Node2.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = Node2.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = Node2.COMMENT_NODE = 8;
  var DOCUMENT_NODE = Node2.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = Node2.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = Node2.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = Node2.NOTATION_NODE = 12;
  var DOCUMENT_POSITION_DISCONNECTED = Node2.DOCUMENT_POSITION_DISCONNECTED = 1;
  var DOCUMENT_POSITION_PRECEDING = Node2.DOCUMENT_POSITION_PRECEDING = 2;
  var DOCUMENT_POSITION_FOLLOWING = Node2.DOCUMENT_POSITION_FOLLOWING = 4;
  var DOCUMENT_POSITION_CONTAINS = Node2.DOCUMENT_POSITION_CONTAINS = 8;
  var DOCUMENT_POSITION_CONTAINED_BY = Node2.DOCUMENT_POSITION_CONTAINED_BY = 16;
  var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  Node2.prototype = Object.create(EventTarget.prototype, {
    baseURI: {get: utils.nyi},
    parentElement: {get: function() {
      return this.parentNode && this.parentNode.nodeType === ELEMENT_NODE ? this.parentNode : null;
    }},
    hasChildNodes: {value: utils.shouldOverride},
    firstChild: {get: utils.shouldOverride},
    lastChild: {get: utils.shouldOverride},
    previousSibling: {get: function() {
      var parent = this.parentNode;
      if (!parent)
        return null;
      if (this === parent.firstChild)
        return null;
      return this._previousSibling;
    }},
    nextSibling: {get: function() {
      var parent = this.parentNode, next2 = this._nextSibling;
      if (!parent)
        return null;
      if (next2 === parent.firstChild)
        return null;
      return next2;
    }},
    textContent: {
      get: function() {
        return null;
      },
      set: function(v) {
      }
    },
    _countChildrenOfType: {value: function(type) {
      var sum = 0;
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        if (kid.nodeType === type)
          sum++;
      }
      return sum;
    }},
    _ensureInsertValid: {value: function _ensureInsertValid(node, child, isPreinsert) {
      var parent = this, i, kid;
      if (!node.nodeType)
        throw new TypeError("not a node");
      switch (parent.nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
        case ELEMENT_NODE:
          break;
        default:
          utils.HierarchyRequestError();
      }
      if (node.isAncestor(parent))
        utils.HierarchyRequestError();
      if (child !== null || !isPreinsert) {
        if (child.parentNode !== parent)
          utils.NotFoundError();
      }
      switch (node.nodeType) {
        case DOCUMENT_FRAGMENT_NODE:
        case DOCUMENT_TYPE_NODE:
        case ELEMENT_NODE:
        case TEXT_NODE:
        case PROCESSING_INSTRUCTION_NODE:
        case COMMENT_NODE:
          break;
        default:
          utils.HierarchyRequestError();
      }
      if (parent.nodeType === DOCUMENT_NODE) {
        switch (node.nodeType) {
          case TEXT_NODE:
            utils.HierarchyRequestError();
            break;
          case DOCUMENT_FRAGMENT_NODE:
            if (node._countChildrenOfType(TEXT_NODE) > 0)
              utils.HierarchyRequestError();
            switch (node._countChildrenOfType(ELEMENT_NODE)) {
              case 0:
                break;
              case 1:
                if (child !== null) {
                  if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
                    utils.HierarchyRequestError();
                  for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                    if (kid.nodeType === DOCUMENT_TYPE_NODE)
                      utils.HierarchyRequestError();
                  }
                }
                i = parent._countChildrenOfType(ELEMENT_NODE);
                if (isPreinsert) {
                  if (i > 0)
                    utils.HierarchyRequestError();
                } else {
                  if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE)
                    utils.HierarchyRequestError();
                }
                break;
              default:
                utils.HierarchyRequestError();
            }
            break;
          case ELEMENT_NODE:
            if (child !== null) {
              if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
                utils.HierarchyRequestError();
              for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                if (kid.nodeType === DOCUMENT_TYPE_NODE)
                  utils.HierarchyRequestError();
              }
            }
            i = parent._countChildrenOfType(ELEMENT_NODE);
            if (isPreinsert) {
              if (i > 0)
                utils.HierarchyRequestError();
            } else {
              if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE)
                utils.HierarchyRequestError();
            }
            break;
          case DOCUMENT_TYPE_NODE:
            if (child === null) {
              if (parent._countChildrenOfType(ELEMENT_NODE))
                utils.HierarchyRequestError();
            } else {
              for (kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
                if (kid === child)
                  break;
                if (kid.nodeType === ELEMENT_NODE)
                  utils.HierarchyRequestError();
              }
            }
            i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);
            if (isPreinsert) {
              if (i > 0)
                utils.HierarchyRequestError();
            } else {
              if (i > 1 || i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE)
                utils.HierarchyRequestError();
            }
            break;
        }
      } else {
        if (node.nodeType === DOCUMENT_TYPE_NODE)
          utils.HierarchyRequestError();
      }
    }},
    insertBefore: {value: function insertBefore(node, child) {
      var parent = this;
      parent._ensureInsertValid(node, child, true);
      var refChild = child;
      if (refChild === node) {
        refChild = node.nextSibling;
      }
      parent.doc.adoptNode(node);
      node._insertOrReplace(parent, refChild, false);
      return node;
    }},
    appendChild: {value: function(child) {
      return this.insertBefore(child, null);
    }},
    _appendChild: {value: function(child) {
      child._insertOrReplace(this, null, false);
    }},
    removeChild: {value: function removeChild(child) {
      var parent = this;
      if (!child.nodeType)
        throw new TypeError("not a node");
      if (child.parentNode !== parent)
        utils.NotFoundError();
      child.remove();
      return child;
    }},
    replaceChild: {value: function replaceChild(node, child) {
      var parent = this;
      parent._ensureInsertValid(node, child, false);
      if (node.doc !== parent.doc) {
        parent.doc.adoptNode(node);
      }
      node._insertOrReplace(parent, child, true);
      return child;
    }},
    contains: {value: function contains(node) {
      if (node === null) {
        return false;
      }
      if (this === node) {
        return true;
      }
      return (this.compareDocumentPosition(node) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
    }},
    compareDocumentPosition: {value: function compareDocumentPosition(that) {
      if (this === that)
        return 0;
      if (this.doc !== that.doc || this.rooted !== that.rooted)
        return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
      var these = [], those = [];
      for (var n = this; n !== null; n = n.parentNode)
        these.push(n);
      for (n = that; n !== null; n = n.parentNode)
        those.push(n);
      these.reverse();
      those.reverse();
      if (these[0] !== those[0])
        return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
      n = Math.min(these.length, those.length);
      for (var i = 1; i < n; i++) {
        if (these[i] !== those[i]) {
          if (these[i].index < those[i].index)
            return DOCUMENT_POSITION_FOLLOWING;
          else
            return DOCUMENT_POSITION_PRECEDING;
        }
      }
      if (these.length < those.length)
        return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY;
      else
        return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS;
    }},
    isSameNode: {value: function isSameNode(node) {
      return this === node;
    }},
    isEqualNode: {value: function isEqualNode(node) {
      if (!node)
        return false;
      if (node.nodeType !== this.nodeType)
        return false;
      if (!this.isEqual(node))
        return false;
      for (var c1 = this.firstChild, c2 = node.firstChild; c1 && c2; c1 = c1.nextSibling, c2 = c2.nextSibling) {
        if (!c1.isEqualNode(c2))
          return false;
      }
      return c1 === null && c2 === null;
    }},
    cloneNode: {value: function(deep) {
      var clone = this.clone();
      if (deep) {
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          clone._appendChild(kid.cloneNode(true));
        }
      }
      return clone;
    }},
    lookupPrefix: {value: function lookupPrefix(ns) {
      var e;
      if (ns === "" || ns === null || ns === void 0)
        return null;
      switch (this.nodeType) {
        case ELEMENT_NODE:
          return this._lookupNamespacePrefix(ns, this);
        case DOCUMENT_NODE:
          e = this.documentElement;
          return e ? e.lookupPrefix(ns) : null;
        case ENTITY_NODE:
        case NOTATION_NODE:
        case DOCUMENT_FRAGMENT_NODE:
        case DOCUMENT_TYPE_NODE:
          return null;
        case ATTRIBUTE_NODE:
          e = this.ownerElement;
          return e ? e.lookupPrefix(ns) : null;
        default:
          e = this.parentElement;
          return e ? e.lookupPrefix(ns) : null;
      }
    }},
    lookupNamespaceURI: {value: function lookupNamespaceURI(prefix) {
      if (prefix === "" || prefix === void 0) {
        prefix = null;
      }
      var e;
      switch (this.nodeType) {
        case ELEMENT_NODE:
          return utils.shouldOverride();
        case DOCUMENT_NODE:
          e = this.documentElement;
          return e ? e.lookupNamespaceURI(prefix) : null;
        case ENTITY_NODE:
        case NOTATION_NODE:
        case DOCUMENT_TYPE_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          return null;
        case ATTRIBUTE_NODE:
          e = this.ownerElement;
          return e ? e.lookupNamespaceURI(prefix) : null;
        default:
          e = this.parentElement;
          return e ? e.lookupNamespaceURI(prefix) : null;
      }
    }},
    isDefaultNamespace: {value: function isDefaultNamespace(ns) {
      if (ns === "" || ns === void 0) {
        ns = null;
      }
      var defaultNamespace = this.lookupNamespaceURI(null);
      return defaultNamespace === ns;
    }},
    index: {get: function() {
      var parent = this.parentNode;
      if (this === parent.firstChild)
        return 0;
      var kids = parent.childNodes;
      if (this._index === void 0 || kids[this._index] !== this) {
        for (var i = 0; i < kids.length; i++) {
          kids[i]._index = i;
        }
        utils.assert(kids[this._index] === this);
      }
      return this._index;
    }},
    isAncestor: {value: function(that) {
      if (this.doc !== that.doc)
        return false;
      if (this.rooted !== that.rooted)
        return false;
      for (var e = that; e; e = e.parentNode) {
        if (e === this)
          return true;
      }
      return false;
    }},
    ensureSameDoc: {value: function(that) {
      if (that.ownerDocument === null) {
        that.ownerDocument = this.doc;
      } else if (that.ownerDocument !== this.doc) {
        utils.WrongDocumentError();
      }
    }},
    removeChildren: {value: utils.shouldOverride},
    _insertOrReplace: {value: function _insertOrReplace(parent, before, isReplace) {
      var child = this, before_index, i;
      if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {
        utils.HierarchyRequestError();
      }
      if (parent._childNodes) {
        before_index = before === null ? parent._childNodes.length : before.index;
        if (child.parentNode === parent) {
          var child_index = child.index;
          if (child_index < before_index) {
            before_index--;
          }
        }
      }
      if (isReplace) {
        if (before.rooted)
          before.doc.mutateRemove(before);
        before.parentNode = null;
      }
      var n = before;
      if (n === null) {
        n = parent.firstChild;
      }
      var bothRooted = child.rooted && parent.rooted;
      if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var spliceArgs = [0, isReplace ? 1 : 0], next2;
        for (var kid = child.firstChild; kid !== null; kid = next2) {
          next2 = kid.nextSibling;
          spliceArgs.push(kid);
          kid.parentNode = parent;
        }
        var len = spliceArgs.length;
        if (isReplace) {
          LinkedList.replace(n, len > 2 ? spliceArgs[2] : null);
        } else if (len > 2 && n !== null) {
          LinkedList.insertBefore(spliceArgs[2], n);
        }
        if (parent._childNodes) {
          spliceArgs[0] = before === null ? parent._childNodes.length : before._index;
          parent._childNodes.splice.apply(parent._childNodes, spliceArgs);
          for (i = 2; i < len; i++) {
            spliceArgs[i]._index = spliceArgs[0] + (i - 2);
          }
        } else if (parent._firstChild === before) {
          if (len > 2) {
            parent._firstChild = spliceArgs[2];
          } else if (isReplace) {
            parent._firstChild = null;
          }
        }
        if (child._childNodes) {
          child._childNodes.length = 0;
        } else {
          child._firstChild = null;
        }
        if (parent.rooted) {
          parent.modify();
          for (i = 2; i < len; i++) {
            parent.doc.mutateInsert(spliceArgs[i]);
          }
        }
      } else {
        if (before === child) {
          return;
        }
        if (bothRooted) {
          child._remove();
        } else if (child.parentNode) {
          child.remove();
        }
        child.parentNode = parent;
        if (isReplace) {
          LinkedList.replace(n, child);
          if (parent._childNodes) {
            child._index = before_index;
            parent._childNodes[before_index] = child;
          } else if (parent._firstChild === before) {
            parent._firstChild = child;
          }
        } else {
          if (n !== null) {
            LinkedList.insertBefore(child, n);
          }
          if (parent._childNodes) {
            child._index = before_index;
            parent._childNodes.splice(before_index, 0, child);
          } else if (parent._firstChild === before) {
            parent._firstChild = child;
          }
        }
        if (bothRooted) {
          parent.modify();
          parent.doc.mutateMove(child);
        } else if (parent.rooted) {
          parent.modify();
          parent.doc.mutateInsert(child);
        }
      }
    }},
    lastModTime: {get: function() {
      if (!this._lastModTime) {
        this._lastModTime = this.doc.modclock;
      }
      return this._lastModTime;
    }},
    modify: {value: function() {
      if (this.doc.modclock) {
        var time = ++this.doc.modclock;
        for (var n = this; n; n = n.parentElement) {
          if (n._lastModTime) {
            n._lastModTime = time;
          }
        }
      }
    }},
    doc: {get: function() {
      return this.ownerDocument || this;
    }},
    rooted: {get: function() {
      return !!this._nid;
    }},
    normalize: {value: function() {
      var next2;
      for (var child = this.firstChild; child !== null; child = next2) {
        next2 = child.nextSibling;
        if (child.normalize) {
          child.normalize();
        }
        if (child.nodeType !== Node2.TEXT_NODE) {
          continue;
        }
        if (child.nodeValue === "") {
          this.removeChild(child);
          continue;
        }
        var prevChild = child.previousSibling;
        if (prevChild === null) {
          continue;
        } else if (prevChild.nodeType === Node2.TEXT_NODE) {
          prevChild.appendData(child.nodeValue);
          this.removeChild(child);
        }
      }
    }},
    serialize: {value: function() {
      var s = "";
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        s += NodeUtils.serializeOne(kid, this);
      }
      return s;
    }},
    outerHTML: {
      get: function() {
        return NodeUtils.serializeOne(this, {nodeType: 0});
      },
      set: utils.nyi
    },
    ELEMENT_NODE: {value: ELEMENT_NODE},
    ATTRIBUTE_NODE: {value: ATTRIBUTE_NODE},
    TEXT_NODE: {value: TEXT_NODE},
    CDATA_SECTION_NODE: {value: CDATA_SECTION_NODE},
    ENTITY_REFERENCE_NODE: {value: ENTITY_REFERENCE_NODE},
    ENTITY_NODE: {value: ENTITY_NODE},
    PROCESSING_INSTRUCTION_NODE: {value: PROCESSING_INSTRUCTION_NODE},
    COMMENT_NODE: {value: COMMENT_NODE},
    DOCUMENT_NODE: {value: DOCUMENT_NODE},
    DOCUMENT_TYPE_NODE: {value: DOCUMENT_TYPE_NODE},
    DOCUMENT_FRAGMENT_NODE: {value: DOCUMENT_FRAGMENT_NODE},
    NOTATION_NODE: {value: NOTATION_NODE},
    DOCUMENT_POSITION_DISCONNECTED: {value: DOCUMENT_POSITION_DISCONNECTED},
    DOCUMENT_POSITION_PRECEDING: {value: DOCUMENT_POSITION_PRECEDING},
    DOCUMENT_POSITION_FOLLOWING: {value: DOCUMENT_POSITION_FOLLOWING},
    DOCUMENT_POSITION_CONTAINS: {value: DOCUMENT_POSITION_CONTAINS},
    DOCUMENT_POSITION_CONTAINED_BY: {value: DOCUMENT_POSITION_CONTAINED_BY},
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: {value: DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}
  });
});

// node_modules/domino/lib/NodeList.es6.js
var require_NodeList_es6 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = class NodeList extends Array {
    constructor(a) {
      super(a && a.length || 0);
      if (a) {
        for (var idx in a) {
          this[idx] = a[idx];
        }
      }
    }
    item(i) {
      return this[i] || null;
    }
  };
});

// node_modules/domino/lib/NodeList.es5.js
var require_NodeList_es5 = __commonJS((exports2, module2) => {
  "use strict";
  function item(i) {
    return this[i] || null;
  }
  function NodeList(a) {
    if (!a)
      a = [];
    a.item = item;
    return a;
  }
  module2.exports = NodeList;
});

// node_modules/domino/lib/NodeList.js
var require_NodeList = __commonJS((exports2, module2) => {
  "use strict";
  var NodeList;
  try {
    NodeList = require_NodeList_es6();
  } catch (e) {
    NodeList = require_NodeList_es5();
  }
  module2.exports = NodeList;
});

// node_modules/domino/lib/ContainerNode.js
var require_ContainerNode = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = ContainerNode;
  var Node2 = require_Node();
  var NodeList = require_NodeList();
  function ContainerNode() {
    Node2.call(this);
    this._firstChild = this._childNodes = null;
  }
  ContainerNode.prototype = Object.create(Node2.prototype, {
    hasChildNodes: {value: function() {
      if (this._childNodes) {
        return this._childNodes.length > 0;
      }
      return this._firstChild !== null;
    }},
    childNodes: {get: function() {
      this._ensureChildNodes();
      return this._childNodes;
    }},
    firstChild: {get: function() {
      if (this._childNodes) {
        return this._childNodes.length === 0 ? null : this._childNodes[0];
      }
      return this._firstChild;
    }},
    lastChild: {get: function() {
      var kids = this._childNodes, first;
      if (kids) {
        return kids.length === 0 ? null : kids[kids.length - 1];
      }
      first = this._firstChild;
      if (first === null) {
        return null;
      }
      return first._previousSibling;
    }},
    _ensureChildNodes: {value: function() {
      if (this._childNodes) {
        return;
      }
      var first = this._firstChild, kid = first, childNodes = this._childNodes = new NodeList();
      if (first)
        do {
          childNodes.push(kid);
          kid = kid._nextSibling;
        } while (kid !== first);
      this._firstChild = null;
    }},
    removeChildren: {value: function removeChildren() {
      var root2 = this.rooted ? this.ownerDocument : null, next2 = this.firstChild, kid;
      while (next2 !== null) {
        kid = next2;
        next2 = kid.nextSibling;
        if (root2)
          root2.mutateRemove(kid);
        kid.parentNode = null;
      }
      if (this._childNodes) {
        this._childNodes.length = 0;
      } else {
        this._firstChild = null;
      }
      this.modify();
    }}
  });
});

// node_modules/domino/lib/xmlnames.js
var require_xmlnames = __commonJS((exports2) => {
  "use strict";
  exports2.isValidName = isValidName;
  exports2.isValidQName = isValidQName;
  var simplename = /^[_:A-Za-z][-.:\w]+$/;
  var simpleqname = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/;
  var ncnamestartchars = "_A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
  var ncnamechars = "-._A-Za-z0-9\xB7\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
  var ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
  var namestartchars = ncnamestartchars + ":";
  var namechars = ncnamechars + ":";
  var name = new RegExp("^[" + namestartchars + "][" + namechars + "]*$");
  var qname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");
  var hassurrogates = /[\uD800-\uDB7F\uDC00-\uDFFF]/;
  var surrogatechars = /[\uD800-\uDB7F\uDC00-\uDFFF]/g;
  var surrogatepairs = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;
  ncnamestartchars += "\uD800-\u{EFC00}-\uDFFF";
  ncnamechars += "\uD800-\u{EFC00}-\uDFFF";
  ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
  namestartchars = ncnamestartchars + ":";
  namechars = ncnamechars + ":";
  var surrogatename = new RegExp("^[" + namestartchars + "][" + namechars + "]*$");
  var surrogateqname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");
  function isValidName(s) {
    if (simplename.test(s))
      return true;
    if (name.test(s))
      return true;
    if (!hassurrogates.test(s))
      return false;
    if (!surrogatename.test(s))
      return false;
    var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
    return pairs !== null && 2 * pairs.length === chars.length;
  }
  function isValidQName(s) {
    if (simpleqname.test(s))
      return true;
    if (qname.test(s))
      return true;
    if (!hassurrogates.test(s))
      return false;
    if (!surrogateqname.test(s))
      return false;
    var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
    return pairs !== null && 2 * pairs.length === chars.length;
  }
});

// node_modules/domino/lib/attributes.js
var require_attributes = __commonJS((exports2) => {
  "use strict";
  var utils = require_utils4();
  exports2.property = function(attr) {
    if (Array.isArray(attr.type)) {
      var valid = Object.create(null);
      attr.type.forEach(function(val) {
        valid[val.value || val] = val.alias || val;
      });
      var missingValueDefault = attr.missing;
      if (missingValueDefault === void 0) {
        missingValueDefault = null;
      }
      var invalidValueDefault = attr.invalid;
      if (invalidValueDefault === void 0) {
        invalidValueDefault = missingValueDefault;
      }
      return {
        get: function() {
          var v = this._getattr(attr.name);
          if (v === null)
            return missingValueDefault;
          v = valid[v.toLowerCase()];
          if (v !== void 0)
            return v;
          if (invalidValueDefault !== null)
            return invalidValueDefault;
          return v;
        },
        set: function(v) {
          this._setattr(attr.name, v);
        }
      };
    } else if (attr.type === Boolean) {
      return {
        get: function() {
          return this.hasAttribute(attr.name);
        },
        set: function(v) {
          if (v) {
            this._setattr(attr.name, "");
          } else {
            this.removeAttribute(attr.name);
          }
        }
      };
    } else if (attr.type === Number || attr.type === "long" || attr.type === "unsigned long" || attr.type === "limited unsigned long with fallback") {
      return numberPropDesc(attr);
    } else if (!attr.type || attr.type === String) {
      return {
        get: function() {
          return this._getattr(attr.name) || "";
        },
        set: function(v) {
          if (attr.treatNullAsEmptyString && v === null) {
            v = "";
          }
          this._setattr(attr.name, v);
        }
      };
    } else if (typeof attr.type === "function") {
      return attr.type(attr.name, attr);
    }
    throw new Error("Invalid attribute definition");
  };
  function numberPropDesc(a) {
    var def;
    if (typeof a.default === "function") {
      def = a.default;
    } else if (typeof a.default === "number") {
      def = function() {
        return a.default;
      };
    } else {
      def = function() {
        utils.assert(false, typeof a.default);
      };
    }
    var unsigned_long = a.type === "unsigned long";
    var signed_long = a.type === "long";
    var unsigned_fallback = a.type === "limited unsigned long with fallback";
    var min = a.min, max = a.max, setmin = a.setmin;
    if (min === void 0) {
      if (unsigned_long)
        min = 0;
      if (signed_long)
        min = -2147483648;
      if (unsigned_fallback)
        min = 1;
    }
    if (max === void 0) {
      if (unsigned_long || signed_long || unsigned_fallback)
        max = 2147483647;
    }
    return {
      get: function() {
        var v = this._getattr(a.name);
        var n = a.float ? parseFloat(v) : parseInt(v, 10);
        if (v === null || !isFinite(n) || min !== void 0 && n < min || max !== void 0 && n > max) {
          return def.call(this);
        }
        if (unsigned_long || signed_long || unsigned_fallback) {
          if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(v)) {
            return def.call(this);
          }
          n = n | 0;
        }
        return n;
      },
      set: function(v) {
        if (!a.float) {
          v = Math.floor(v);
        }
        if (setmin !== void 0 && v < setmin) {
          utils.IndexSizeError(a.name + " set to " + v);
        }
        if (unsigned_long) {
          v = v < 0 || v > 2147483647 ? def.call(this) : v | 0;
        } else if (unsigned_fallback) {
          v = v < 1 || v > 2147483647 ? def.call(this) : v | 0;
        } else if (signed_long) {
          v = v < -2147483648 || v > 2147483647 ? def.call(this) : v | 0;
        }
        this._setattr(a.name, String(v));
      }
    };
  }
  exports2.registerChangeHandler = function(c, name, handler) {
    var p = c.prototype;
    if (!Object.prototype.hasOwnProperty.call(p, "_attributeChangeHandlers")) {
      p._attributeChangeHandlers = Object.create(p._attributeChangeHandlers || null);
    }
    p._attributeChangeHandlers[name] = handler;
  };
});

// node_modules/domino/lib/FilteredElementList.js
var require_FilteredElementList = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = FilteredElementList;
  var Node2 = require_Node();
  function FilteredElementList(root2, filter) {
    this.root = root2;
    this.filter = filter;
    this.lastModTime = root2.lastModTime;
    this.done = false;
    this.cache = [];
    this.traverse();
  }
  FilteredElementList.prototype = Object.create(Object.prototype, {
    length: {get: function() {
      this.checkcache();
      if (!this.done)
        this.traverse();
      return this.cache.length;
    }},
    item: {value: function(n) {
      this.checkcache();
      if (!this.done && n >= this.cache.length) {
        this.traverse();
      }
      return this.cache[n];
    }},
    checkcache: {value: function() {
      if (this.lastModTime !== this.root.lastModTime) {
        for (var i = this.cache.length - 1; i >= 0; i--) {
          this[i] = void 0;
        }
        this.cache.length = 0;
        this.done = false;
        this.lastModTime = this.root.lastModTime;
      }
    }},
    traverse: {value: function(n) {
      if (n !== void 0)
        n++;
      var elt;
      while ((elt = this.next()) !== null) {
        this[this.cache.length] = elt;
        this.cache.push(elt);
        if (n && this.cache.length === n)
          return;
      }
      this.done = true;
    }},
    next: {value: function() {
      var start = this.cache.length === 0 ? this.root : this.cache[this.cache.length - 1];
      var elt;
      if (start.nodeType === Node2.DOCUMENT_NODE)
        elt = start.documentElement;
      else
        elt = start.nextElement(this.root);
      while (elt) {
        if (this.filter(elt)) {
          return elt;
        }
        elt = elt.nextElement(this.root);
      }
      return null;
    }}
  });
});

// node_modules/domino/lib/DOMTokenList.js
var require_DOMTokenList = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  module2.exports = DOMTokenList;
  function DOMTokenList(getter, setter) {
    this._getString = getter;
    this._setString = setter;
    this._length = 0;
    this._lastStringValue = "";
    this._update();
  }
  Object.defineProperties(DOMTokenList.prototype, {
    length: {get: function() {
      return this._length;
    }},
    item: {value: function(index) {
      var list = getList(this);
      if (index < 0 || index >= list.length) {
        return null;
      }
      return list[index];
    }},
    contains: {value: function(token) {
      token = String(token);
      var list = getList(this);
      return list.indexOf(token) > -1;
    }},
    add: {value: function() {
      var list = getList(this);
      for (var i = 0, len = arguments.length; i < len; i++) {
        var token = handleErrors(arguments[i]);
        if (list.indexOf(token) < 0) {
          list.push(token);
        }
      }
      this._update(list);
    }},
    remove: {value: function() {
      var list = getList(this);
      for (var i = 0, len = arguments.length; i < len; i++) {
        var token = handleErrors(arguments[i]);
        var index = list.indexOf(token);
        if (index > -1) {
          list.splice(index, 1);
        }
      }
      this._update(list);
    }},
    toggle: {value: function toggle(token, force) {
      token = handleErrors(token);
      if (this.contains(token)) {
        if (force === void 0 || force === false) {
          this.remove(token);
          return false;
        }
        return true;
      } else {
        if (force === void 0 || force === true) {
          this.add(token);
          return true;
        }
        return false;
      }
    }},
    replace: {value: function replace(token, newToken) {
      if (String(newToken) === "") {
        utils.SyntaxError();
      }
      token = handleErrors(token);
      newToken = handleErrors(newToken);
      var list = getList(this);
      var idx = list.indexOf(token);
      if (idx < 0) {
        return false;
      }
      var idx2 = list.indexOf(newToken);
      if (idx2 < 0) {
        list[idx] = newToken;
      } else {
        if (idx < idx2) {
          list[idx] = newToken;
          list.splice(idx2, 1);
        } else {
          list.splice(idx, 1);
        }
      }
      this._update(list);
      return true;
    }},
    toString: {value: function() {
      return this._getString();
    }},
    value: {
      get: function() {
        return this._getString();
      },
      set: function(v) {
        this._setString(v);
        this._update();
      }
    },
    _update: {value: function(list) {
      if (list) {
        fixIndex(this, list);
        this._setString(list.join(" ").trim());
      } else {
        fixIndex(this, getList(this));
      }
      this._lastStringValue = this._getString();
    }}
  });
  function fixIndex(clist, list) {
    var oldLength = clist._length;
    var i;
    clist._length = list.length;
    for (i = 0; i < list.length; i++) {
      clist[i] = list[i];
    }
    for (; i < oldLength; i++) {
      clist[i] = void 0;
    }
  }
  function handleErrors(token) {
    token = String(token);
    if (token === "") {
      utils.SyntaxError();
    }
    if (/[ \t\r\n\f]/.test(token)) {
      utils.InvalidCharacterError();
    }
    return token;
  }
  function toArray(clist) {
    var length = clist._length;
    var arr = Array(length);
    for (var i = 0; i < length; i++) {
      arr[i] = clist[i];
    }
    return arr;
  }
  function getList(clist) {
    var strProp = clist._getString();
    if (strProp === clist._lastStringValue) {
      return toArray(clist);
    }
    var str = strProp.replace(/(^[ \t\r\n\f]+)|([ \t\r\n\f]+$)/g, "");
    if (str === "") {
      return [];
    } else {
      var seen = Object.create(null);
      return str.split(/[ \t\r\n\f]+/g).filter(function(n) {
        var key = "$" + n;
        if (seen[key]) {
          return false;
        }
        seen[key] = true;
        return true;
      });
    }
  }
});

// node_modules/domino/lib/select.js
var require_select = __commonJS((exports2, module2) => {
  "use strict";
  var window4 = Object.create(null, {
    location: {get: function() {
      throw new Error("window.location is not supported.");
    }}
  });
  var compareDocumentPosition = function(a, b) {
    return a.compareDocumentPosition(b);
  };
  var order = function(a, b) {
    return compareDocumentPosition(a, b) & 2 ? 1 : -1;
  };
  var next2 = function(el) {
    while ((el = el.nextSibling) && el.nodeType !== 1)
      ;
    return el;
  };
  var prev = function(el) {
    while ((el = el.previousSibling) && el.nodeType !== 1)
      ;
    return el;
  };
  var child = function(el) {
    if (el = el.firstChild) {
      while (el.nodeType !== 1 && (el = el.nextSibling))
        ;
    }
    return el;
  };
  var lastChild = function(el) {
    if (el = el.lastChild) {
      while (el.nodeType !== 1 && (el = el.previousSibling))
        ;
    }
    return el;
  };
  var parentIsElement = function(n) {
    if (!n.parentNode) {
      return false;
    }
    var nodeType = n.parentNode.nodeType;
    return nodeType === 1 || nodeType === 9;
  };
  var unquote = function(str) {
    if (!str)
      return str;
    var ch = str[0];
    if (ch === '"' || ch === "'") {
      if (str[str.length - 1] === ch) {
        str = str.slice(1, -1);
      } else {
        str = str.slice(1);
      }
      return str.replace(rules2.str_escape, function(s) {
        var m = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(s);
        if (!m) {
          return s.slice(1);
        }
        if (m[2]) {
          return "";
        }
        var cp = parseInt(m[1], 16);
        return String.fromCodePoint ? String.fromCodePoint(cp) : String.fromCharCode(cp);
      });
    } else if (rules2.ident.test(str)) {
      return decodeid(str);
    } else {
      return str;
    }
  };
  var decodeid = function(str) {
    return str.replace(rules2.escape, function(s) {
      var m = /^\\([0-9A-Fa-f]+)/.exec(s);
      if (!m) {
        return s[1];
      }
      var cp = parseInt(m[1], 16);
      return String.fromCodePoint ? String.fromCodePoint(cp) : String.fromCharCode(cp);
    });
  };
  var indexOf = function() {
    if (Array.prototype.indexOf) {
      return Array.prototype.indexOf;
    }
    return function(obj, item) {
      var i = this.length;
      while (i--) {
        if (this[i] === item)
          return i;
      }
      return -1;
    };
  }();
  var makeInside = function(start, end) {
    var regex = rules2.inside.source.replace(/</g, start).replace(/>/g, end);
    return new RegExp(regex);
  };
  var replace = function(regex, name, val) {
    regex = regex.source;
    regex = regex.replace(name, val.source || val);
    return new RegExp(regex);
  };
  var truncateUrl = function(url, num) {
    return url.replace(/^(?:\w+:\/\/|\/+)/, "").replace(/(?:\/+|\/*#.*?)$/, "").split("/", num).join("/");
  };
  var parseNth = function(param_, test) {
    var param = param_.replace(/\s+/g, ""), cap;
    if (param === "even") {
      param = "2n+0";
    } else if (param === "odd") {
      param = "2n+1";
    } else if (param.indexOf("n") === -1) {
      param = "0n" + param;
    }
    cap = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(param);
    return {
      group: cap[1] === "-" ? -(cap[2] || 1) : +(cap[2] || 1),
      offset: cap[4] ? cap[3] === "-" ? -cap[4] : +cap[4] : 0
    };
  };
  var nth = function(param_, test, last) {
    var param = parseNth(param_), group = param.group, offset = param.offset, find2 = !last ? child : lastChild, advance = !last ? next2 : prev;
    return function(el) {
      if (!parentIsElement(el))
        return;
      var rel = find2(el.parentNode), pos = 0;
      while (rel) {
        if (test(rel, el))
          pos++;
        if (rel === el) {
          pos -= offset;
          return group && pos ? pos % group === 0 && pos < 0 === group < 0 : !pos;
        }
        rel = advance(rel);
      }
    };
  };
  var selectors = {
    "*": function() {
      if (false) {
        return function(el) {
          if (el.nodeType === 1)
            return true;
        };
      }
      return function() {
        return true;
      };
    }(),
    type: function(type) {
      type = type.toLowerCase();
      return function(el) {
        return el.nodeName.toLowerCase() === type;
      };
    },
    attr: function(key, op, val, i) {
      op = operators[op];
      return function(el) {
        var attr;
        switch (key) {
          case "for":
            attr = el.htmlFor;
            break;
          case "class":
            attr = el.className;
            if (attr === "" && el.getAttribute("class") == null) {
              attr = null;
            }
            break;
          case "href":
          case "src":
            attr = el.getAttribute(key, 2);
            break;
          case "title":
            attr = el.getAttribute("title") || null;
            break;
          case "id":
          case "lang":
          case "dir":
          case "accessKey":
          case "hidden":
          case "tabIndex":
          case "style":
            if (el.getAttribute) {
              attr = el.getAttribute(key);
              break;
            }
          default:
            if (el.hasAttribute && !el.hasAttribute(key)) {
              break;
            }
            attr = el[key] != null ? el[key] : el.getAttribute && el.getAttribute(key);
            break;
        }
        if (attr == null)
          return;
        attr = attr + "";
        if (i) {
          attr = attr.toLowerCase();
          val = val.toLowerCase();
        }
        return op(attr, val);
      };
    },
    ":first-child": function(el) {
      return !prev(el) && parentIsElement(el);
    },
    ":last-child": function(el) {
      return !next2(el) && parentIsElement(el);
    },
    ":only-child": function(el) {
      return !prev(el) && !next2(el) && parentIsElement(el);
    },
    ":nth-child": function(param, last) {
      return nth(param, function() {
        return true;
      }, last);
    },
    ":nth-last-child": function(param) {
      return selectors[":nth-child"](param, true);
    },
    ":root": function(el) {
      return el.ownerDocument.documentElement === el;
    },
    ":empty": function(el) {
      return !el.firstChild;
    },
    ":not": function(sel) {
      var test = compileGroup(sel);
      return function(el) {
        return !test(el);
      };
    },
    ":first-of-type": function(el) {
      if (!parentIsElement(el))
        return;
      var type = el.nodeName;
      while (el = prev(el)) {
        if (el.nodeName === type)
          return;
      }
      return true;
    },
    ":last-of-type": function(el) {
      if (!parentIsElement(el))
        return;
      var type = el.nodeName;
      while (el = next2(el)) {
        if (el.nodeName === type)
          return;
      }
      return true;
    },
    ":only-of-type": function(el) {
      return selectors[":first-of-type"](el) && selectors[":last-of-type"](el);
    },
    ":nth-of-type": function(param, last) {
      return nth(param, function(rel, el) {
        return rel.nodeName === el.nodeName;
      }, last);
    },
    ":nth-last-of-type": function(param) {
      return selectors[":nth-of-type"](param, true);
    },
    ":checked": function(el) {
      return !!(el.checked || el.selected);
    },
    ":indeterminate": function(el) {
      return !selectors[":checked"](el);
    },
    ":enabled": function(el) {
      return !el.disabled && el.type !== "hidden";
    },
    ":disabled": function(el) {
      return !!el.disabled;
    },
    ":target": function(el) {
      return el.id === window4.location.hash.substring(1);
    },
    ":focus": function(el) {
      return el === el.ownerDocument.activeElement;
    },
    ":is": function(sel) {
      return compileGroup(sel);
    },
    ":matches": function(sel) {
      return selectors[":is"](sel);
    },
    ":nth-match": function(param, last) {
      var args = param.split(/\s*,\s*/), arg = args.shift(), test = compileGroup(args.join(","));
      return nth(arg, test, last);
    },
    ":nth-last-match": function(param) {
      return selectors[":nth-match"](param, true);
    },
    ":links-here": function(el) {
      return el + "" === window4.location + "";
    },
    ":lang": function(param) {
      return function(el) {
        while (el) {
          if (el.lang)
            return el.lang.indexOf(param) === 0;
          el = el.parentNode;
        }
      };
    },
    ":dir": function(param) {
      return function(el) {
        while (el) {
          if (el.dir)
            return el.dir === param;
          el = el.parentNode;
        }
      };
    },
    ":scope": function(el, con) {
      var context = con || el.ownerDocument;
      if (context.nodeType === 9) {
        return el === context.documentElement;
      }
      return el === context;
    },
    ":any-link": function(el) {
      return typeof el.href === "string";
    },
    ":local-link": function(el) {
      if (el.nodeName) {
        return el.href && el.host === window4.location.host;
      }
      var param = +el + 1;
      return function(el2) {
        if (!el2.href)
          return;
        var url = window4.location + "", href = el2 + "";
        return truncateUrl(url, param) === truncateUrl(href, param);
      };
    },
    ":default": function(el) {
      return !!el.defaultSelected;
    },
    ":valid": function(el) {
      return el.willValidate || el.validity && el.validity.valid;
    },
    ":invalid": function(el) {
      return !selectors[":valid"](el);
    },
    ":in-range": function(el) {
      return el.value > el.min && el.value <= el.max;
    },
    ":out-of-range": function(el) {
      return !selectors[":in-range"](el);
    },
    ":required": function(el) {
      return !!el.required;
    },
    ":optional": function(el) {
      return !el.required;
    },
    ":read-only": function(el) {
      if (el.readOnly)
        return true;
      var attr = el.getAttribute("contenteditable"), prop = el.contentEditable, name = el.nodeName.toLowerCase();
      name = name !== "input" && name !== "textarea";
      return (name || el.disabled) && attr == null && prop !== "true";
    },
    ":read-write": function(el) {
      return !selectors[":read-only"](el);
    },
    ":hover": function() {
      throw new Error(":hover is not supported.");
    },
    ":active": function() {
      throw new Error(":active is not supported.");
    },
    ":link": function() {
      throw new Error(":link is not supported.");
    },
    ":visited": function() {
      throw new Error(":visited is not supported.");
    },
    ":column": function() {
      throw new Error(":column is not supported.");
    },
    ":nth-column": function() {
      throw new Error(":nth-column is not supported.");
    },
    ":nth-last-column": function() {
      throw new Error(":nth-last-column is not supported.");
    },
    ":current": function() {
      throw new Error(":current is not supported.");
    },
    ":past": function() {
      throw new Error(":past is not supported.");
    },
    ":future": function() {
      throw new Error(":future is not supported.");
    },
    ":contains": function(param) {
      return function(el) {
        var text = el.innerText || el.textContent || el.value || "";
        return text.indexOf(param) !== -1;
      };
    },
    ":has": function(param) {
      return function(el) {
        return find(param, el).length > 0;
      };
    }
  };
  var operators = {
    "-": function() {
      return true;
    },
    "=": function(attr, val) {
      return attr === val;
    },
    "*=": function(attr, val) {
      return attr.indexOf(val) !== -1;
    },
    "~=": function(attr, val) {
      var i, s, f, l;
      for (s = 0; true; s = i + 1) {
        i = attr.indexOf(val, s);
        if (i === -1)
          return false;
        f = attr[i - 1];
        l = attr[i + val.length];
        if ((!f || f === " ") && (!l || l === " "))
          return true;
      }
    },
    "|=": function(attr, val) {
      var i = attr.indexOf(val), l;
      if (i !== 0)
        return;
      l = attr[i + val.length];
      return l === "-" || !l;
    },
    "^=": function(attr, val) {
      return attr.indexOf(val) === 0;
    },
    "$=": function(attr, val) {
      var i = attr.lastIndexOf(val);
      return i !== -1 && i + val.length === attr.length;
    },
    "!=": function(attr, val) {
      return attr !== val;
    }
  };
  var combinators = {
    " ": function(test) {
      return function(el) {
        while (el = el.parentNode) {
          if (test(el))
            return el;
        }
      };
    },
    ">": function(test) {
      return function(el) {
        if (el = el.parentNode) {
          return test(el) && el;
        }
      };
    },
    "+": function(test) {
      return function(el) {
        if (el = prev(el)) {
          return test(el) && el;
        }
      };
    },
    "~": function(test) {
      return function(el) {
        while (el = prev(el)) {
          if (test(el))
            return el;
        }
      };
    },
    noop: function(test) {
      return function(el) {
        return test(el) && el;
      };
    },
    ref: function(test, name) {
      var node;
      function ref(el) {
        var doc = el.ownerDocument, nodes = doc.getElementsByTagName("*"), i = nodes.length;
        while (i--) {
          node = nodes[i];
          if (ref.test(el)) {
            node = null;
            return true;
          }
        }
        node = null;
      }
      ref.combinator = function(el) {
        if (!node || !node.getAttribute)
          return;
        var attr = node.getAttribute(name) || "";
        if (attr[0] === "#")
          attr = attr.substring(1);
        if (attr === el.id && test(node)) {
          return node;
        }
      };
      return ref;
    }
  };
  var rules2 = {
    escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
    str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
    nonascii: /[\u00A0-\uFFFF]/,
    cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
    qname: /^ *(cssid|\*)/,
    simple: /^(?:([.#]cssid)|pseudo|attr)/,
    ref: /^ *\/(cssid)\/ */,
    combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
    attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
    pseudo: /^(:cssid)(?:\((inside)\))?/,
    inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
    ident: /^(cssid)$/
  };
  rules2.cssid = replace(rules2.cssid, "nonascii", rules2.nonascii);
  rules2.cssid = replace(rules2.cssid, "escape", rules2.escape);
  rules2.qname = replace(rules2.qname, "cssid", rules2.cssid);
  rules2.simple = replace(rules2.simple, "cssid", rules2.cssid);
  rules2.ref = replace(rules2.ref, "cssid", rules2.cssid);
  rules2.attr = replace(rules2.attr, "cssid", rules2.cssid);
  rules2.pseudo = replace(rules2.pseudo, "cssid", rules2.cssid);
  rules2.inside = replace(rules2.inside, `[^"'>]*`, rules2.inside);
  rules2.attr = replace(rules2.attr, "inside", makeInside("\\[", "\\]"));
  rules2.pseudo = replace(rules2.pseudo, "inside", makeInside("\\(", "\\)"));
  rules2.simple = replace(rules2.simple, "pseudo", rules2.pseudo);
  rules2.simple = replace(rules2.simple, "attr", rules2.attr);
  rules2.ident = replace(rules2.ident, "cssid", rules2.cssid);
  rules2.str_escape = replace(rules2.str_escape, "escape", rules2.escape);
  var compile = function(sel_) {
    var sel = sel_.replace(/^\s+|\s+$/g, ""), test, filter = [], buff = [], subject, qname, cap, op, ref;
    while (sel) {
      if (cap = rules2.qname.exec(sel)) {
        sel = sel.substring(cap[0].length);
        qname = decodeid(cap[1]);
        buff.push(tok(qname, true));
      } else if (cap = rules2.simple.exec(sel)) {
        sel = sel.substring(cap[0].length);
        qname = "*";
        buff.push(tok(qname, true));
        buff.push(tok(cap));
      } else {
        throw new SyntaxError("Invalid selector.");
      }
      while (cap = rules2.simple.exec(sel)) {
        sel = sel.substring(cap[0].length);
        buff.push(tok(cap));
      }
      if (sel[0] === "!") {
        sel = sel.substring(1);
        subject = makeSubject();
        subject.qname = qname;
        buff.push(subject.simple);
      }
      if (cap = rules2.ref.exec(sel)) {
        sel = sel.substring(cap[0].length);
        ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));
        filter.push(ref.combinator);
        buff = [];
        continue;
      }
      if (cap = rules2.combinator.exec(sel)) {
        sel = sel.substring(cap[0].length);
        op = cap[1] || cap[2] || cap[3];
        if (op === ",") {
          filter.push(combinators.noop(makeSimple(buff)));
          break;
        }
      } else {
        op = "noop";
      }
      if (!combinators[op]) {
        throw new SyntaxError("Bad combinator.");
      }
      filter.push(combinators[op](makeSimple(buff)));
      buff = [];
    }
    test = makeTest(filter);
    test.qname = qname;
    test.sel = sel;
    if (subject) {
      subject.lname = test.qname;
      subject.test = test;
      subject.qname = subject.qname;
      subject.sel = test.sel;
      test = subject;
    }
    if (ref) {
      ref.test = test;
      ref.qname = test.qname;
      ref.sel = test.sel;
      test = ref;
    }
    return test;
  };
  var tok = function(cap, qname) {
    if (qname) {
      return cap === "*" ? selectors["*"] : selectors.type(cap);
    }
    if (cap[1]) {
      return cap[1][0] === "." ? selectors.attr("class", "~=", decodeid(cap[1].substring(1)), false) : selectors.attr("id", "=", decodeid(cap[1].substring(1)), false);
    }
    if (cap[2]) {
      return cap[3] ? selectors[decodeid(cap[2])](unquote(cap[3])) : selectors[decodeid(cap[2])];
    }
    if (cap[4]) {
      var value = cap[6];
      var i = /["'\s]\s*I$/i.test(value);
      if (i) {
        value = value.replace(/\s*I$/i, "");
      }
      return selectors.attr(decodeid(cap[4]), cap[5] || "-", unquote(value), i);
    }
    throw new SyntaxError("Unknown Selector.");
  };
  var makeSimple = function(func) {
    var l = func.length, i;
    if (l < 2)
      return func[0];
    return function(el) {
      if (!el)
        return;
      for (i = 0; i < l; i++) {
        if (!func[i](el))
          return;
      }
      return true;
    };
  };
  var makeTest = function(func) {
    if (func.length < 2) {
      return function(el) {
        return !!func[0](el);
      };
    }
    return function(el) {
      var i = func.length;
      while (i--) {
        if (!(el = func[i](el)))
          return;
      }
      return true;
    };
  };
  var makeSubject = function() {
    var target;
    function subject(el) {
      var node = el.ownerDocument, scope = node.getElementsByTagName(subject.lname), i = scope.length;
      while (i--) {
        if (subject.test(scope[i]) && target === el) {
          target = null;
          return true;
        }
      }
      target = null;
    }
    subject.simple = function(el) {
      target = el;
      return true;
    };
    return subject;
  };
  var compileGroup = function(sel) {
    var test = compile(sel), tests = [test];
    while (test.sel) {
      test = compile(test.sel);
      tests.push(test);
    }
    if (tests.length < 2)
      return test;
    return function(el) {
      var l = tests.length, i = 0;
      for (; i < l; i++) {
        if (tests[i](el))
          return true;
      }
    };
  };
  var find = function(sel, node) {
    var results = [], test = compile(sel), scope = node.getElementsByTagName(test.qname), i = 0, el;
    while (el = scope[i++]) {
      if (test(el))
        results.push(el);
    }
    if (test.sel) {
      while (test.sel) {
        test = compile(test.sel);
        scope = node.getElementsByTagName(test.qname);
        i = 0;
        while (el = scope[i++]) {
          if (test(el) && indexOf.call(results, el) === -1) {
            results.push(el);
          }
        }
      }
      results.sort(order);
    }
    return results;
  };
  module2.exports = exports2 = function(sel, context) {
    var id, r;
    if (context.nodeType !== 11 && sel.indexOf(" ") === -1) {
      if (sel[0] === "#" && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {
        if (context.doc._hasMultipleElementsWithId) {
          id = sel.substring(1);
          if (!context.doc._hasMultipleElementsWithId(id)) {
            r = context.doc.getElementById(id);
            return r ? [r] : [];
          }
        }
      }
      if (sel[0] === "." && /^\.\w+$/.test(sel)) {
        return context.getElementsByClassName(sel.substring(1));
      }
      if (/^\w+$/.test(sel)) {
        return context.getElementsByTagName(sel);
      }
    }
    return find(sel, context);
  };
  exports2.selectors = selectors;
  exports2.operators = operators;
  exports2.combinators = combinators;
  exports2.matches = function(el, sel) {
    var test = {sel};
    do {
      test = compile(test.sel);
      if (test(el)) {
        return true;
      }
    } while (test.sel);
    return false;
  };
});

// node_modules/domino/lib/ChildNode.js
var require_ChildNode = __commonJS((exports2, module2) => {
  "use strict";
  var Node2 = require_Node();
  var LinkedList = require_LinkedList();
  var createDocumentFragmentFromArguments = function(document, args) {
    var docFrag = document.createDocumentFragment();
    for (var i = 0; i < args.length; i++) {
      var argItem = args[i];
      var isNode = argItem instanceof Node2;
      docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
    }
    return docFrag;
  };
  var ChildNode = {
    after: {value: function after() {
      var argArr = Array.prototype.slice.call(arguments);
      var parentNode = this.parentNode, nextSibling = this.nextSibling;
      if (parentNode === null) {
        return;
      }
      while (nextSibling && argArr.some(function(v) {
        return v === nextSibling;
      }))
        nextSibling = nextSibling.nextSibling;
      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
      parentNode.insertBefore(docFrag, nextSibling);
    }},
    before: {value: function before() {
      var argArr = Array.prototype.slice.call(arguments);
      var parentNode = this.parentNode, prevSibling = this.previousSibling;
      if (parentNode === null) {
        return;
      }
      while (prevSibling && argArr.some(function(v) {
        return v === prevSibling;
      }))
        prevSibling = prevSibling.previousSibling;
      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
      var nextSibling = prevSibling ? prevSibling.nextSibling : parentNode.firstChild;
      parentNode.insertBefore(docFrag, nextSibling);
    }},
    remove: {value: function remove2() {
      if (this.parentNode === null)
        return;
      if (this.doc) {
        this.doc._preremoveNodeIterators(this);
        if (this.rooted) {
          this.doc.mutateRemove(this);
        }
      }
      this._remove();
      this.parentNode = null;
    }},
    _remove: {value: function _remove() {
      var parent = this.parentNode;
      if (parent === null)
        return;
      if (parent._childNodes) {
        parent._childNodes.splice(this.index, 1);
      } else if (parent._firstChild === this) {
        if (this._nextSibling === this) {
          parent._firstChild = null;
        } else {
          parent._firstChild = this._nextSibling;
        }
      }
      LinkedList.remove(this);
      parent.modify();
    }},
    replaceWith: {value: function replaceWith() {
      var argArr = Array.prototype.slice.call(arguments);
      var parentNode = this.parentNode, nextSibling = this.nextSibling;
      if (parentNode === null) {
        return;
      }
      while (nextSibling && argArr.some(function(v) {
        return v === nextSibling;
      }))
        nextSibling = nextSibling.nextSibling;
      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
      if (this.parentNode === parentNode) {
        parentNode.replaceChild(docFrag, this);
      } else {
        parentNode.insertBefore(docFrag, nextSibling);
      }
    }}
  };
  module2.exports = ChildNode;
});

// node_modules/domino/lib/NonDocumentTypeChildNode.js
var require_NonDocumentTypeChildNode = __commonJS((exports2, module2) => {
  "use strict";
  var Node2 = require_Node();
  var NonDocumentTypeChildNode = {
    nextElementSibling: {get: function() {
      if (this.parentNode) {
        for (var kid = this.nextSibling; kid !== null; kid = kid.nextSibling) {
          if (kid.nodeType === Node2.ELEMENT_NODE)
            return kid;
        }
      }
      return null;
    }},
    previousElementSibling: {get: function() {
      if (this.parentNode) {
        for (var kid = this.previousSibling; kid !== null; kid = kid.previousSibling) {
          if (kid.nodeType === Node2.ELEMENT_NODE)
            return kid;
        }
      }
      return null;
    }}
  };
  module2.exports = NonDocumentTypeChildNode;
});

// node_modules/domino/lib/NamedNodeMap.js
var require_NamedNodeMap = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = NamedNodeMap;
  var utils = require_utils4();
  function NamedNodeMap(element) {
    this.element = element;
  }
  Object.defineProperties(NamedNodeMap.prototype, {
    length: {get: utils.shouldOverride},
    item: {value: utils.shouldOverride},
    getNamedItem: {value: function getNamedItem(qualifiedName) {
      return this.element.getAttributeNode(qualifiedName);
    }},
    getNamedItemNS: {value: function getNamedItemNS(namespace, localName) {
      return this.element.getAttributeNodeNS(namespace, localName);
    }},
    setNamedItem: {value: utils.nyi},
    setNamedItemNS: {value: utils.nyi},
    removeNamedItem: {value: function removeNamedItem(qualifiedName) {
      var attr = this.element.getAttributeNode(qualifiedName);
      if (attr) {
        this.element.removeAttribute(qualifiedName);
        return attr;
      }
      utils.NotFoundError();
    }},
    removeNamedItemNS: {value: function removeNamedItemNS(ns, lname) {
      var attr = this.element.getAttributeNodeNS(ns, lname);
      if (attr) {
        this.element.removeAttributeNS(ns, lname);
        return attr;
      }
      utils.NotFoundError();
    }}
  });
});

// node_modules/domino/lib/Element.js
var require_Element = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Element;
  var xml = require_xmlnames();
  var utils = require_utils4();
  var NAMESPACE = utils.NAMESPACE;
  var attributes = require_attributes();
  var Node2 = require_Node();
  var NodeList = require_NodeList();
  var NodeUtils = require_NodeUtils();
  var FilteredElementList = require_FilteredElementList();
  var DOMException = require_DOMException();
  var DOMTokenList = require_DOMTokenList();
  var select = require_select();
  var ContainerNode = require_ContainerNode();
  var ChildNode = require_ChildNode();
  var NonDocumentTypeChildNode = require_NonDocumentTypeChildNode();
  var NamedNodeMap = require_NamedNodeMap();
  var uppercaseCache = Object.create(null);
  function Element(doc, localName, namespaceURI, prefix) {
    ContainerNode.call(this);
    this.nodeType = Node2.ELEMENT_NODE;
    this.ownerDocument = doc;
    this.localName = localName;
    this.namespaceURI = namespaceURI;
    this.prefix = prefix;
    this._tagName = void 0;
    this._attrsByQName = Object.create(null);
    this._attrsByLName = Object.create(null);
    this._attrKeys = [];
  }
  function recursiveGetText(node, a) {
    if (node.nodeType === Node2.TEXT_NODE) {
      a.push(node._data);
    } else {
      for (var i = 0, n = node.childNodes.length; i < n; i++)
        recursiveGetText(node.childNodes[i], a);
    }
  }
  Element.prototype = Object.create(ContainerNode.prototype, {
    isHTML: {get: function isHTML() {
      return this.namespaceURI === NAMESPACE.HTML && this.ownerDocument.isHTML;
    }},
    tagName: {get: function tagName() {
      if (this._tagName === void 0) {
        var tn;
        if (this.prefix === null) {
          tn = this.localName;
        } else {
          tn = this.prefix + ":" + this.localName;
        }
        if (this.isHTML) {
          var up = uppercaseCache[tn];
          if (!up) {
            uppercaseCache[tn] = up = utils.toASCIIUpperCase(tn);
          }
          tn = up;
        }
        this._tagName = tn;
      }
      return this._tagName;
    }},
    nodeName: {get: function() {
      return this.tagName;
    }},
    nodeValue: {
      get: function() {
        return null;
      },
      set: function() {
      }
    },
    textContent: {
      get: function() {
        var strings = [];
        recursiveGetText(this, strings);
        return strings.join("");
      },
      set: function(newtext) {
        this.removeChildren();
        if (newtext !== null && newtext !== void 0 && newtext !== "") {
          this._appendChild(this.ownerDocument.createTextNode(newtext));
        }
      }
    },
    innerHTML: {
      get: function() {
        return this.serialize();
      },
      set: utils.nyi
    },
    outerHTML: {
      get: function() {
        return NodeUtils.serializeOne(this, {nodeType: 0});
      },
      set: function(v) {
        var document = this.ownerDocument;
        var parent = this.parentNode;
        if (parent === null) {
          return;
        }
        if (parent.nodeType === Node2.DOCUMENT_NODE) {
          utils.NoModificationAllowedError();
        }
        if (parent.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
          parent = parent.ownerDocument.createElement("body");
        }
        var parser = document.implementation.mozHTMLParser(document._address, parent);
        parser.parse(v === null ? "" : String(v), true);
        this.replaceWith(parser._asDocumentFragment());
      }
    },
    _insertAdjacent: {value: function _insertAdjacent(position, node) {
      var first = false;
      switch (position) {
        case "beforebegin":
          first = true;
        case "afterend":
          var parent = this.parentNode;
          if (parent === null) {
            return null;
          }
          return parent.insertBefore(node, first ? this : this.nextSibling);
        case "afterbegin":
          first = true;
        case "beforeend":
          return this.insertBefore(node, first ? this.firstChild : null);
        default:
          return utils.SyntaxError();
      }
    }},
    insertAdjacentElement: {value: function insertAdjacentElement(position, element) {
      if (element.nodeType !== Node2.ELEMENT_NODE) {
        throw new TypeError("not an element");
      }
      position = utils.toASCIILowerCase(String(position));
      return this._insertAdjacent(position, element);
    }},
    insertAdjacentText: {value: function insertAdjacentText(position, data) {
      var textNode = this.ownerDocument.createTextNode(data);
      position = utils.toASCIILowerCase(String(position));
      this._insertAdjacent(position, textNode);
    }},
    insertAdjacentHTML: {value: function insertAdjacentHTML(position, text) {
      position = utils.toASCIILowerCase(String(position));
      text = String(text);
      var context;
      switch (position) {
        case "beforebegin":
        case "afterend":
          context = this.parentNode;
          if (context === null || context.nodeType === Node2.DOCUMENT_NODE) {
            utils.NoModificationAllowedError();
          }
          break;
        case "afterbegin":
        case "beforeend":
          context = this;
          break;
        default:
          utils.SyntaxError();
      }
      if (!(context instanceof Element) || context.ownerDocument.isHTML && context.localName === "html" && context.namespaceURI === NAMESPACE.HTML) {
        context = context.ownerDocument.createElementNS(NAMESPACE.HTML, "body");
      }
      var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, context);
      parser.parse(text, true);
      this._insertAdjacent(position, parser._asDocumentFragment());
    }},
    children: {get: function() {
      if (!this._children) {
        this._children = new ChildrenCollection(this);
      }
      return this._children;
    }},
    attributes: {get: function() {
      if (!this._attributes) {
        this._attributes = new AttributesArray(this);
      }
      return this._attributes;
    }},
    firstElementChild: {get: function() {
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        if (kid.nodeType === Node2.ELEMENT_NODE)
          return kid;
      }
      return null;
    }},
    lastElementChild: {get: function() {
      for (var kid = this.lastChild; kid !== null; kid = kid.previousSibling) {
        if (kid.nodeType === Node2.ELEMENT_NODE)
          return kid;
      }
      return null;
    }},
    childElementCount: {get: function() {
      return this.children.length;
    }},
    nextElement: {value: function(root2) {
      if (!root2)
        root2 = this.ownerDocument.documentElement;
      var next2 = this.firstElementChild;
      if (!next2) {
        if (this === root2)
          return null;
        next2 = this.nextElementSibling;
      }
      if (next2)
        return next2;
      for (var parent = this.parentElement; parent && parent !== root2; parent = parent.parentElement) {
        next2 = parent.nextElementSibling;
        if (next2)
          return next2;
      }
      return null;
    }},
    getElementsByTagName: {value: function getElementsByTagName(lname) {
      var filter;
      if (!lname)
        return new NodeList();
      if (lname === "*")
        filter = function() {
          return true;
        };
      else if (this.isHTML)
        filter = htmlLocalNameElementFilter(lname);
      else
        filter = localNameElementFilter(lname);
      return new FilteredElementList(this, filter);
    }},
    getElementsByTagNameNS: {value: function getElementsByTagNameNS(ns, lname) {
      var filter;
      if (ns === "*" && lname === "*")
        filter = function() {
          return true;
        };
      else if (ns === "*")
        filter = localNameElementFilter(lname);
      else if (lname === "*")
        filter = namespaceElementFilter(ns);
      else
        filter = namespaceLocalNameElementFilter(ns, lname);
      return new FilteredElementList(this, filter);
    }},
    getElementsByClassName: {value: function getElementsByClassName(names) {
      names = String(names).trim();
      if (names === "") {
        var result = new NodeList();
        return result;
      }
      names = names.split(/[ \t\r\n\f]+/);
      return new FilteredElementList(this, classNamesElementFilter(names));
    }},
    getElementsByName: {value: function getElementsByName(name) {
      return new FilteredElementList(this, elementNameFilter(String(name)));
    }},
    clone: {value: function clone() {
      var e;
      if (this.namespaceURI !== NAMESPACE.HTML || this.prefix || !this.ownerDocument.isHTML) {
        e = this.ownerDocument.createElementNS(this.namespaceURI, this.prefix !== null ? this.prefix + ":" + this.localName : this.localName);
      } else {
        e = this.ownerDocument.createElement(this.localName);
      }
      for (var i = 0, n = this._attrKeys.length; i < n; i++) {
        var lname = this._attrKeys[i];
        var a = this._attrsByLName[lname];
        var b = a.cloneNode();
        b._setOwnerElement(e);
        e._attrsByLName[lname] = b;
        e._addQName(b);
      }
      e._attrKeys = this._attrKeys.concat();
      return e;
    }},
    isEqual: {value: function isEqual(that) {
      if (this.localName !== that.localName || this.namespaceURI !== that.namespaceURI || this.prefix !== that.prefix || this._numattrs !== that._numattrs)
        return false;
      for (var i = 0, n = this._numattrs; i < n; i++) {
        var a = this._attr(i);
        if (!that.hasAttributeNS(a.namespaceURI, a.localName))
          return false;
        if (that.getAttributeNS(a.namespaceURI, a.localName) !== a.value)
          return false;
      }
      return true;
    }},
    _lookupNamespacePrefix: {value: function _lookupNamespacePrefix(ns, originalElement) {
      if (this.namespaceURI && this.namespaceURI === ns && this.prefix !== null && originalElement.lookupNamespaceURI(this.prefix) === ns) {
        return this.prefix;
      }
      for (var i = 0, n = this._numattrs; i < n; i++) {
        var a = this._attr(i);
        if (a.prefix === "xmlns" && a.value === ns && originalElement.lookupNamespaceURI(a.localName) === ns) {
          return a.localName;
        }
      }
      var parent = this.parentElement;
      return parent ? parent._lookupNamespacePrefix(ns, originalElement) : null;
    }},
    lookupNamespaceURI: {value: function lookupNamespaceURI(prefix) {
      if (prefix === "" || prefix === void 0) {
        prefix = null;
      }
      if (this.namespaceURI !== null && this.prefix === prefix)
        return this.namespaceURI;
      for (var i = 0, n = this._numattrs; i < n; i++) {
        var a = this._attr(i);
        if (a.namespaceURI === NAMESPACE.XMLNS) {
          if (a.prefix === "xmlns" && a.localName === prefix || prefix === null && a.prefix === null && a.localName === "xmlns") {
            return a.value || null;
          }
        }
      }
      var parent = this.parentElement;
      return parent ? parent.lookupNamespaceURI(prefix) : null;
    }},
    getAttribute: {value: function getAttribute(qname) {
      var attr = this.getAttributeNode(qname);
      return attr ? attr.value : null;
    }},
    getAttributeNS: {value: function getAttributeNS(ns, lname) {
      var attr = this.getAttributeNodeNS(ns, lname);
      return attr ? attr.value : null;
    }},
    getAttributeNode: {value: function getAttributeNode(qname) {
      qname = String(qname);
      if (/[A-Z]/.test(qname) && this.isHTML)
        qname = utils.toASCIILowerCase(qname);
      var attr = this._attrsByQName[qname];
      if (!attr)
        return null;
      if (Array.isArray(attr))
        attr = attr[0];
      return attr;
    }},
    getAttributeNodeNS: {value: function getAttributeNodeNS(ns, lname) {
      ns = ns === void 0 || ns === null ? "" : String(ns);
      lname = String(lname);
      var attr = this._attrsByLName[ns + "|" + lname];
      return attr ? attr : null;
    }},
    hasAttribute: {value: function hasAttribute(qname) {
      qname = String(qname);
      if (/[A-Z]/.test(qname) && this.isHTML)
        qname = utils.toASCIILowerCase(qname);
      return this._attrsByQName[qname] !== void 0;
    }},
    hasAttributeNS: {value: function hasAttributeNS(ns, lname) {
      ns = ns === void 0 || ns === null ? "" : String(ns);
      lname = String(lname);
      var key = ns + "|" + lname;
      return this._attrsByLName[key] !== void 0;
    }},
    hasAttributes: {value: function hasAttributes() {
      return this._numattrs > 0;
    }},
    toggleAttribute: {value: function toggleAttribute(qname, force) {
      qname = String(qname);
      if (!xml.isValidName(qname))
        utils.InvalidCharacterError();
      if (/[A-Z]/.test(qname) && this.isHTML)
        qname = utils.toASCIILowerCase(qname);
      var a = this._attrsByQName[qname];
      if (a === void 0) {
        if (force === void 0 || force === true) {
          this._setAttribute(qname, "");
          return true;
        }
        return false;
      } else {
        if (force === void 0 || force === false) {
          this.removeAttribute(qname);
          return false;
        }
        return true;
      }
    }},
    _setAttribute: {value: function _setAttribute(qname, value) {
      var attr = this._attrsByQName[qname];
      var isnew;
      if (!attr) {
        attr = this._newattr(qname);
        isnew = true;
      } else {
        if (Array.isArray(attr))
          attr = attr[0];
      }
      attr.value = value;
      if (this._attributes)
        this._attributes[qname] = attr;
      if (isnew && this._newattrhook)
        this._newattrhook(qname, value);
    }},
    setAttribute: {value: function setAttribute(qname, value) {
      qname = String(qname);
      if (!xml.isValidName(qname))
        utils.InvalidCharacterError();
      if (/[A-Z]/.test(qname) && this.isHTML)
        qname = utils.toASCIILowerCase(qname);
      this._setAttribute(qname, String(value));
    }},
    _setAttributeNS: {value: function _setAttributeNS(ns, qname, value) {
      var pos = qname.indexOf(":"), prefix, lname;
      if (pos < 0) {
        prefix = null;
        lname = qname;
      } else {
        prefix = qname.substring(0, pos);
        lname = qname.substring(pos + 1);
      }
      if (ns === "" || ns === void 0)
        ns = null;
      var key = (ns === null ? "" : ns) + "|" + lname;
      var attr = this._attrsByLName[key];
      var isnew;
      if (!attr) {
        attr = new Attr(this, lname, prefix, ns);
        isnew = true;
        this._attrsByLName[key] = attr;
        if (this._attributes) {
          this._attributes[this._attrKeys.length] = attr;
        }
        this._attrKeys.push(key);
        this._addQName(attr);
      } else if (false) {
        if (attr.prefix !== prefix) {
          this._removeQName(attr);
          attr.prefix = prefix;
          this._addQName(attr);
        }
      }
      attr.value = value;
      if (isnew && this._newattrhook)
        this._newattrhook(qname, value);
    }},
    setAttributeNS: {value: function setAttributeNS(ns, qname, value) {
      ns = ns === null || ns === void 0 || ns === "" ? null : String(ns);
      qname = String(qname);
      if (!xml.isValidQName(qname))
        utils.InvalidCharacterError();
      var pos = qname.indexOf(":");
      var prefix = pos < 0 ? null : qname.substring(0, pos);
      if (prefix !== null && ns === null || prefix === "xml" && ns !== NAMESPACE.XML || (qname === "xmlns" || prefix === "xmlns") && ns !== NAMESPACE.XMLNS || ns === NAMESPACE.XMLNS && !(qname === "xmlns" || prefix === "xmlns"))
        utils.NamespaceError();
      this._setAttributeNS(ns, qname, String(value));
    }},
    setAttributeNode: {value: function setAttributeNode(attr) {
      if (attr.ownerElement !== null && attr.ownerElement !== this) {
        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
      }
      var result = null;
      var oldAttrs = this._attrsByQName[attr.name];
      if (oldAttrs) {
        if (!Array.isArray(oldAttrs)) {
          oldAttrs = [oldAttrs];
        }
        if (oldAttrs.some(function(a) {
          return a === attr;
        })) {
          return attr;
        } else if (attr.ownerElement !== null) {
          throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
        }
        oldAttrs.forEach(function(a) {
          this.removeAttributeNode(a);
        }, this);
        result = oldAttrs[0];
      }
      this.setAttributeNodeNS(attr);
      return result;
    }},
    setAttributeNodeNS: {value: function setAttributeNodeNS(attr) {
      if (attr.ownerElement !== null) {
        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
      }
      var ns = attr.namespaceURI;
      var key = (ns === null ? "" : ns) + "|" + attr.localName;
      var oldAttr = this._attrsByLName[key];
      if (oldAttr) {
        this.removeAttributeNode(oldAttr);
      }
      attr._setOwnerElement(this);
      this._attrsByLName[key] = attr;
      if (this._attributes) {
        this._attributes[this._attrKeys.length] = attr;
      }
      this._attrKeys.push(key);
      this._addQName(attr);
      if (this._newattrhook)
        this._newattrhook(attr.name, attr.value);
      return oldAttr || null;
    }},
    removeAttribute: {value: function removeAttribute(qname) {
      qname = String(qname);
      if (/[A-Z]/.test(qname) && this.isHTML)
        qname = utils.toASCIILowerCase(qname);
      var attr = this._attrsByQName[qname];
      if (!attr)
        return;
      if (Array.isArray(attr)) {
        if (attr.length > 2) {
          attr = attr.shift();
        } else {
          this._attrsByQName[qname] = attr[1];
          attr = attr[0];
        }
      } else {
        this._attrsByQName[qname] = void 0;
      }
      var ns = attr.namespaceURI;
      var key = (ns === null ? "" : ns) + "|" + attr.localName;
      this._attrsByLName[key] = void 0;
      var i = this._attrKeys.indexOf(key);
      if (this._attributes) {
        Array.prototype.splice.call(this._attributes, i, 1);
        this._attributes[qname] = void 0;
      }
      this._attrKeys.splice(i, 1);
      var onchange = attr.onchange;
      attr._setOwnerElement(null);
      if (onchange) {
        onchange.call(attr, this, attr.localName, attr.value, null);
      }
      if (this.rooted)
        this.ownerDocument.mutateRemoveAttr(attr);
    }},
    removeAttributeNS: {value: function removeAttributeNS(ns, lname) {
      ns = ns === void 0 || ns === null ? "" : String(ns);
      lname = String(lname);
      var key = ns + "|" + lname;
      var attr = this._attrsByLName[key];
      if (!attr)
        return;
      this._attrsByLName[key] = void 0;
      var i = this._attrKeys.indexOf(key);
      if (this._attributes) {
        Array.prototype.splice.call(this._attributes, i, 1);
      }
      this._attrKeys.splice(i, 1);
      this._removeQName(attr);
      var onchange = attr.onchange;
      attr._setOwnerElement(null);
      if (onchange) {
        onchange.call(attr, this, attr.localName, attr.value, null);
      }
      if (this.rooted)
        this.ownerDocument.mutateRemoveAttr(attr);
    }},
    removeAttributeNode: {value: function removeAttributeNode(attr) {
      var ns = attr.namespaceURI;
      var key = (ns === null ? "" : ns) + "|" + attr.localName;
      if (this._attrsByLName[key] !== attr) {
        utils.NotFoundError();
      }
      this.removeAttributeNS(ns, attr.localName);
      return attr;
    }},
    getAttributeNames: {value: function getAttributeNames() {
      var elt = this;
      return this._attrKeys.map(function(key) {
        return elt._attrsByLName[key].name;
      });
    }},
    _getattr: {value: function _getattr(qname) {
      var attr = this._attrsByQName[qname];
      return attr ? attr.value : null;
    }},
    _setattr: {value: function _setattr(qname, value) {
      var attr = this._attrsByQName[qname];
      var isnew;
      if (!attr) {
        attr = this._newattr(qname);
        isnew = true;
      }
      attr.value = String(value);
      if (this._attributes)
        this._attributes[qname] = attr;
      if (isnew && this._newattrhook)
        this._newattrhook(qname, value);
    }},
    _newattr: {value: function _newattr(qname) {
      var attr = new Attr(this, qname, null, null);
      var key = "|" + qname;
      this._attrsByQName[qname] = attr;
      this._attrsByLName[key] = attr;
      if (this._attributes) {
        this._attributes[this._attrKeys.length] = attr;
      }
      this._attrKeys.push(key);
      return attr;
    }},
    _addQName: {value: function(attr) {
      var qname = attr.name;
      var existing = this._attrsByQName[qname];
      if (!existing) {
        this._attrsByQName[qname] = attr;
      } else if (Array.isArray(existing)) {
        existing.push(attr);
      } else {
        this._attrsByQName[qname] = [existing, attr];
      }
      if (this._attributes)
        this._attributes[qname] = attr;
    }},
    _removeQName: {value: function(attr) {
      var qname = attr.name;
      var target = this._attrsByQName[qname];
      if (Array.isArray(target)) {
        var idx = target.indexOf(attr);
        utils.assert(idx !== -1);
        if (target.length === 2) {
          this._attrsByQName[qname] = target[1 - idx];
          if (this._attributes) {
            this._attributes[qname] = this._attrsByQName[qname];
          }
        } else {
          target.splice(idx, 1);
          if (this._attributes && this._attributes[qname] === attr) {
            this._attributes[qname] = target[0];
          }
        }
      } else {
        utils.assert(target === attr);
        this._attrsByQName[qname] = void 0;
        if (this._attributes) {
          this._attributes[qname] = void 0;
        }
      }
    }},
    _numattrs: {get: function() {
      return this._attrKeys.length;
    }},
    _attr: {value: function(n) {
      return this._attrsByLName[this._attrKeys[n]];
    }},
    id: attributes.property({name: "id"}),
    className: attributes.property({name: "class"}),
    classList: {get: function() {
      var self2 = this;
      if (this._classList) {
        return this._classList;
      }
      var dtlist = new DOMTokenList(function() {
        return self2.className || "";
      }, function(v) {
        self2.className = v;
      });
      this._classList = dtlist;
      return dtlist;
    }, set: function(v) {
      this.className = v;
    }},
    matches: {value: function(selector) {
      return select.matches(this, selector);
    }},
    closest: {value: function(selector) {
      var el = this;
      do {
        if (el.matches && el.matches(selector)) {
          return el;
        }
        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType === Node2.ELEMENT_NODE);
      return null;
    }},
    querySelector: {value: function(selector) {
      return select(selector, this)[0];
    }},
    querySelectorAll: {value: function(selector) {
      var nodes = select(selector, this);
      return nodes.item ? nodes : new NodeList(nodes);
    }}
  });
  Object.defineProperties(Element.prototype, ChildNode);
  Object.defineProperties(Element.prototype, NonDocumentTypeChildNode);
  attributes.registerChangeHandler(Element, "id", function(element, lname, oldval, newval) {
    if (element.rooted) {
      if (oldval) {
        element.ownerDocument.delId(oldval, element);
      }
      if (newval) {
        element.ownerDocument.addId(newval, element);
      }
    }
  });
  attributes.registerChangeHandler(Element, "class", function(element, lname, oldval, newval) {
    if (element._classList) {
      element._classList._update();
    }
  });
  function Attr(elt, lname, prefix, namespace, value) {
    this.localName = lname;
    this.prefix = prefix === null || prefix === "" ? null : "" + prefix;
    this.namespaceURI = namespace === null || namespace === "" ? null : "" + namespace;
    this.data = value;
    this._setOwnerElement(elt);
  }
  Attr.prototype = Object.create(Object.prototype, {
    ownerElement: {
      get: function() {
        return this._ownerElement;
      }
    },
    _setOwnerElement: {value: function _setOwnerElement(elt) {
      this._ownerElement = elt;
      if (this.prefix === null && this.namespaceURI === null && elt) {
        this.onchange = elt._attributeChangeHandlers[this.localName];
      } else {
        this.onchange = null;
      }
    }},
    name: {get: function() {
      return this.prefix ? this.prefix + ":" + this.localName : this.localName;
    }},
    specified: {get: function() {
      return true;
    }},
    value: {
      get: function() {
        return this.data;
      },
      set: function(value) {
        var oldval = this.data;
        value = value === void 0 ? "" : value + "";
        if (value === oldval)
          return;
        this.data = value;
        if (this.ownerElement) {
          if (this.onchange)
            this.onchange(this.ownerElement, this.localName, oldval, value);
          if (this.ownerElement.rooted)
            this.ownerElement.ownerDocument.mutateAttr(this, oldval);
        }
      }
    },
    cloneNode: {value: function cloneNode(deep) {
      return new Attr(null, this.localName, this.prefix, this.namespaceURI, this.data);
    }},
    nodeType: {get: function() {
      return Node2.ATTRIBUTE_NODE;
    }},
    nodeName: {get: function() {
      return this.name;
    }},
    nodeValue: {
      get: function() {
        return this.value;
      },
      set: function(v) {
        this.value = v;
      }
    },
    textContent: {
      get: function() {
        return this.value;
      },
      set: function(v) {
        if (v === null || v === void 0) {
          v = "";
        }
        this.value = v;
      }
    }
  });
  Element._Attr = Attr;
  function AttributesArray(elt) {
    NamedNodeMap.call(this, elt);
    for (var name in elt._attrsByQName) {
      this[name] = elt._attrsByQName[name];
    }
    for (var i = 0; i < elt._attrKeys.length; i++) {
      this[i] = elt._attrsByLName[elt._attrKeys[i]];
    }
  }
  AttributesArray.prototype = Object.create(NamedNodeMap.prototype, {
    length: {get: function() {
      return this.element._attrKeys.length;
    }, set: function() {
    }},
    item: {value: function(n) {
      n = n >>> 0;
      if (n >= this.length) {
        return null;
      }
      return this.element._attrsByLName[this.element._attrKeys[n]];
    }}
  });
  if (global.Symbol && global.Symbol.iterator) {
    AttributesArray.prototype[global.Symbol.iterator] = function() {
      var i = 0, n = this.length, self2 = this;
      return {
        next: function() {
          if (i < n)
            return {value: self2.item(i++)};
          return {done: true};
        }
      };
    };
  }
  function ChildrenCollection(e) {
    this.element = e;
    this.updateCache();
  }
  ChildrenCollection.prototype = Object.create(Object.prototype, {
    length: {get: function() {
      this.updateCache();
      return this.childrenByNumber.length;
    }},
    item: {value: function item(n) {
      this.updateCache();
      return this.childrenByNumber[n] || null;
    }},
    namedItem: {value: function namedItem(name) {
      this.updateCache();
      return this.childrenByName[name] || null;
    }},
    namedItems: {get: function() {
      this.updateCache();
      return this.childrenByName;
    }},
    updateCache: {value: function updateCache() {
      var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;
      if (this.lastModTime !== this.element.lastModTime) {
        this.lastModTime = this.element.lastModTime;
        var n = this.childrenByNumber && this.childrenByNumber.length || 0;
        for (var i = 0; i < n; i++) {
          this[i] = void 0;
        }
        this.childrenByNumber = [];
        this.childrenByName = Object.create(null);
        for (var c = this.element.firstChild; c !== null; c = c.nextSibling) {
          if (c.nodeType === Node2.ELEMENT_NODE) {
            this[this.childrenByNumber.length] = c;
            this.childrenByNumber.push(c);
            var id = c.getAttribute("id");
            if (id && !this.childrenByName[id])
              this.childrenByName[id] = c;
            var name = c.getAttribute("name");
            if (name && this.element.namespaceURI === NAMESPACE.HTML && namedElts.test(this.element.localName) && !this.childrenByName[name])
              this.childrenByName[id] = c;
          }
        }
      }
    }}
  });
  function localNameElementFilter(lname) {
    return function(e) {
      return e.localName === lname;
    };
  }
  function htmlLocalNameElementFilter(lname) {
    var lclname = utils.toASCIILowerCase(lname);
    if (lclname === lname)
      return localNameElementFilter(lname);
    return function(e) {
      return e.isHTML ? e.localName === lclname : e.localName === lname;
    };
  }
  function namespaceElementFilter(ns) {
    return function(e) {
      return e.namespaceURI === ns;
    };
  }
  function namespaceLocalNameElementFilter(ns, lname) {
    return function(e) {
      return e.namespaceURI === ns && e.localName === lname;
    };
  }
  function classNamesElementFilter(names) {
    return function(e) {
      return names.every(function(n) {
        return e.classList.contains(n);
      });
    };
  }
  function elementNameFilter(name) {
    return function(e) {
      if (e.namespaceURI !== NAMESPACE.HTML) {
        return false;
      }
      return e.getAttribute("name") === name;
    };
  }
});

// node_modules/domino/lib/Leaf.js
var require_Leaf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Leaf;
  var Node2 = require_Node();
  var NodeList = require_NodeList();
  var utils = require_utils4();
  var HierarchyRequestError = utils.HierarchyRequestError;
  var NotFoundError = utils.NotFoundError;
  function Leaf() {
    Node2.call(this);
  }
  Leaf.prototype = Object.create(Node2.prototype, {
    hasChildNodes: {value: function() {
      return false;
    }},
    firstChild: {value: null},
    lastChild: {value: null},
    insertBefore: {value: function(node, child) {
      if (!node.nodeType)
        throw new TypeError("not a node");
      HierarchyRequestError();
    }},
    replaceChild: {value: function(node, child) {
      if (!node.nodeType)
        throw new TypeError("not a node");
      HierarchyRequestError();
    }},
    removeChild: {value: function(node) {
      if (!node.nodeType)
        throw new TypeError("not a node");
      NotFoundError();
    }},
    removeChildren: {value: function() {
    }},
    childNodes: {get: function() {
      if (!this._childNodes)
        this._childNodes = new NodeList();
      return this._childNodes;
    }}
  });
});

// node_modules/domino/lib/CharacterData.js
var require_CharacterData = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = CharacterData;
  var Leaf = require_Leaf();
  var utils = require_utils4();
  var ChildNode = require_ChildNode();
  var NonDocumentTypeChildNode = require_NonDocumentTypeChildNode();
  function CharacterData() {
    Leaf.call(this);
  }
  CharacterData.prototype = Object.create(Leaf.prototype, {
    substringData: {value: function substringData(offset, count) {
      if (arguments.length < 2) {
        throw new TypeError("Not enough arguments");
      }
      offset = offset >>> 0;
      count = count >>> 0;
      if (offset > this.data.length || offset < 0 || count < 0) {
        utils.IndexSizeError();
      }
      return this.data.substring(offset, offset + count);
    }},
    appendData: {value: function appendData(data) {
      if (arguments.length < 1) {
        throw new TypeError("Not enough arguments");
      }
      this.data += String(data);
    }},
    insertData: {value: function insertData(offset, data) {
      return this.replaceData(offset, 0, data);
    }},
    deleteData: {value: function deleteData(offset, count) {
      return this.replaceData(offset, count, "");
    }},
    replaceData: {value: function replaceData(offset, count, data) {
      var curtext = this.data, len = curtext.length;
      offset = offset >>> 0;
      count = count >>> 0;
      data = String(data);
      if (offset > len || offset < 0)
        utils.IndexSizeError();
      if (offset + count > len)
        count = len - offset;
      var prefix = curtext.substring(0, offset), suffix = curtext.substring(offset + count);
      this.data = prefix + data + suffix;
    }},
    isEqual: {value: function isEqual(n) {
      return this._data === n._data;
    }},
    length: {get: function() {
      return this.data.length;
    }}
  });
  Object.defineProperties(CharacterData.prototype, ChildNode);
  Object.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);
});

// node_modules/domino/lib/Text.js
var require_Text = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Text;
  var utils = require_utils4();
  var Node2 = require_Node();
  var CharacterData = require_CharacterData();
  function Text(doc, data) {
    CharacterData.call(this);
    this.nodeType = Node2.TEXT_NODE;
    this.ownerDocument = doc;
    this._data = data;
    this._index = void 0;
  }
  var nodeValue = {
    get: function() {
      return this._data;
    },
    set: function(v) {
      if (v === null || v === void 0) {
        v = "";
      } else {
        v = String(v);
      }
      if (v === this._data)
        return;
      this._data = v;
      if (this.rooted)
        this.ownerDocument.mutateValue(this);
      if (this.parentNode && this.parentNode._textchangehook)
        this.parentNode._textchangehook(this);
    }
  };
  Text.prototype = Object.create(CharacterData.prototype, {
    nodeName: {value: "#text"},
    nodeValue,
    textContent: nodeValue,
    data: {
      get: nodeValue.get,
      set: function(v) {
        nodeValue.set.call(this, v === null ? "" : String(v));
      }
    },
    splitText: {value: function splitText(offset) {
      if (offset > this._data.length || offset < 0)
        utils.IndexSizeError();
      var newdata = this._data.substring(offset), newnode = this.ownerDocument.createTextNode(newdata);
      this.data = this.data.substring(0, offset);
      var parent = this.parentNode;
      if (parent !== null)
        parent.insertBefore(newnode, this.nextSibling);
      return newnode;
    }},
    wholeText: {get: function wholeText() {
      var result = this.textContent;
      for (var next2 = this.nextSibling; next2; next2 = next2.nextSibling) {
        if (next2.nodeType !== Node2.TEXT_NODE) {
          break;
        }
        result += next2.textContent;
      }
      return result;
    }},
    replaceWholeText: {value: utils.nyi},
    clone: {value: function clone() {
      return new Text(this.ownerDocument, this._data);
    }}
  });
});

// node_modules/domino/lib/Comment.js
var require_Comment = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Comment;
  var Node2 = require_Node();
  var CharacterData = require_CharacterData();
  function Comment(doc, data) {
    CharacterData.call(this);
    this.nodeType = Node2.COMMENT_NODE;
    this.ownerDocument = doc;
    this._data = data;
  }
  var nodeValue = {
    get: function() {
      return this._data;
    },
    set: function(v) {
      if (v === null || v === void 0) {
        v = "";
      } else {
        v = String(v);
      }
      this._data = v;
      if (this.rooted)
        this.ownerDocument.mutateValue(this);
    }
  };
  Comment.prototype = Object.create(CharacterData.prototype, {
    nodeName: {value: "#comment"},
    nodeValue,
    textContent: nodeValue,
    data: {
      get: nodeValue.get,
      set: function(v) {
        nodeValue.set.call(this, v === null ? "" : String(v));
      }
    },
    clone: {value: function clone() {
      return new Comment(this.ownerDocument, this._data);
    }}
  });
});

// node_modules/domino/lib/DocumentFragment.js
var require_DocumentFragment = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = DocumentFragment;
  var Node2 = require_Node();
  var NodeList = require_NodeList();
  var ContainerNode = require_ContainerNode();
  var Element = require_Element();
  var select = require_select();
  var utils = require_utils4();
  function DocumentFragment(doc) {
    ContainerNode.call(this);
    this.nodeType = Node2.DOCUMENT_FRAGMENT_NODE;
    this.ownerDocument = doc;
  }
  DocumentFragment.prototype = Object.create(ContainerNode.prototype, {
    nodeName: {value: "#document-fragment"},
    nodeValue: {
      get: function() {
        return null;
      },
      set: function() {
      }
    },
    textContent: Object.getOwnPropertyDescriptor(Element.prototype, "textContent"),
    querySelector: {value: function(selector) {
      var nodes = this.querySelectorAll(selector);
      return nodes.length ? nodes[0] : null;
    }},
    querySelectorAll: {value: function(selector) {
      var context = Object.create(this);
      context.isHTML = true;
      context.getElementsByTagName = Element.prototype.getElementsByTagName;
      context.nextElement = Object.getOwnPropertyDescriptor(Element.prototype, "firstElementChild").get;
      var nodes = select(selector, context);
      return nodes.item ? nodes : new NodeList(nodes);
    }},
    clone: {value: function clone() {
      return new DocumentFragment(this.ownerDocument);
    }},
    isEqual: {value: function isEqual(n) {
      return true;
    }},
    innerHTML: {
      get: function() {
        return this.serialize();
      },
      set: utils.nyi
    },
    outerHTML: {
      get: function() {
        return this.serialize();
      },
      set: utils.nyi
    }
  });
});

// node_modules/domino/lib/ProcessingInstruction.js
var require_ProcessingInstruction = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = ProcessingInstruction;
  var Node2 = require_Node();
  var CharacterData = require_CharacterData();
  function ProcessingInstruction(doc, target, data) {
    CharacterData.call(this);
    this.nodeType = Node2.PROCESSING_INSTRUCTION_NODE;
    this.ownerDocument = doc;
    this.target = target;
    this._data = data;
  }
  var nodeValue = {
    get: function() {
      return this._data;
    },
    set: function(v) {
      if (v === null || v === void 0) {
        v = "";
      } else {
        v = String(v);
      }
      this._data = v;
      if (this.rooted)
        this.ownerDocument.mutateValue(this);
    }
  };
  ProcessingInstruction.prototype = Object.create(CharacterData.prototype, {
    nodeName: {get: function() {
      return this.target;
    }},
    nodeValue,
    textContent: nodeValue,
    data: {
      get: nodeValue.get,
      set: function(v) {
        nodeValue.set.call(this, v === null ? "" : String(v));
      }
    },
    clone: {value: function clone() {
      return new ProcessingInstruction(this.ownerDocument, this.target, this._data);
    }},
    isEqual: {value: function isEqual(n) {
      return this.target === n.target && this._data === n._data;
    }}
  });
});

// node_modules/domino/lib/NodeFilter.js
var require_NodeFilter = __commonJS((exports2, module2) => {
  "use strict";
  var NodeFilter = {
    FILTER_ACCEPT: 1,
    FILTER_REJECT: 2,
    FILTER_SKIP: 3,
    SHOW_ALL: 4294967295,
    SHOW_ELEMENT: 1,
    SHOW_ATTRIBUTE: 2,
    SHOW_TEXT: 4,
    SHOW_CDATA_SECTION: 8,
    SHOW_ENTITY_REFERENCE: 16,
    SHOW_ENTITY: 32,
    SHOW_PROCESSING_INSTRUCTION: 64,
    SHOW_COMMENT: 128,
    SHOW_DOCUMENT: 256,
    SHOW_DOCUMENT_TYPE: 512,
    SHOW_DOCUMENT_FRAGMENT: 1024,
    SHOW_NOTATION: 2048
  };
  module2.exports = NodeFilter.constructor = NodeFilter.prototype = NodeFilter;
});

// node_modules/domino/lib/NodeTraversal.js
var require_NodeTraversal = __commonJS((exports2, module2) => {
  "use strict";
  var NodeTraversal = module2.exports = {
    nextSkippingChildren,
    nextAncestorSibling,
    next: next2,
    previous,
    deepLastChild
  };
  function nextSkippingChildren(node, stayWithin) {
    if (node === stayWithin) {
      return null;
    }
    if (node.nextSibling !== null) {
      return node.nextSibling;
    }
    return nextAncestorSibling(node, stayWithin);
  }
  function nextAncestorSibling(node, stayWithin) {
    for (node = node.parentNode; node !== null; node = node.parentNode) {
      if (node === stayWithin) {
        return null;
      }
      if (node.nextSibling !== null) {
        return node.nextSibling;
      }
    }
    return null;
  }
  function next2(node, stayWithin) {
    var n;
    n = node.firstChild;
    if (n !== null) {
      return n;
    }
    if (node === stayWithin) {
      return null;
    }
    n = node.nextSibling;
    if (n !== null) {
      return n;
    }
    return nextAncestorSibling(node, stayWithin);
  }
  function deepLastChild(node) {
    while (node.lastChild) {
      node = node.lastChild;
    }
    return node;
  }
  function previous(node, stayWithin) {
    var p;
    p = node.previousSibling;
    if (p !== null) {
      return deepLastChild(p);
    }
    p = node.parentNode;
    if (p === stayWithin) {
      return null;
    }
    return p;
  }
});

// node_modules/domino/lib/TreeWalker.js
var require_TreeWalker = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = TreeWalker;
  var Node2 = require_Node();
  var NodeFilter = require_NodeFilter();
  var NodeTraversal = require_NodeTraversal();
  var utils = require_utils4();
  var mapChild = {
    first: "firstChild",
    last: "lastChild",
    next: "firstChild",
    previous: "lastChild"
  };
  var mapSibling = {
    first: "nextSibling",
    last: "previousSibling",
    next: "nextSibling",
    previous: "previousSibling"
  };
  function traverseChildren(tw, type) {
    var child, node, parent, result, sibling;
    node = tw._currentNode[mapChild[type]];
    while (node !== null) {
      result = tw._internalFilter(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        tw._currentNode = node;
        return node;
      }
      if (result === NodeFilter.FILTER_SKIP) {
        child = node[mapChild[type]];
        if (child !== null) {
          node = child;
          continue;
        }
      }
      while (node !== null) {
        sibling = node[mapSibling[type]];
        if (sibling !== null) {
          node = sibling;
          break;
        }
        parent = node.parentNode;
        if (parent === null || parent === tw.root || parent === tw._currentNode) {
          return null;
        } else {
          node = parent;
        }
      }
    }
    return null;
  }
  function traverseSiblings(tw, type) {
    var node, result, sibling;
    node = tw._currentNode;
    if (node === tw.root) {
      return null;
    }
    while (true) {
      sibling = node[mapSibling[type]];
      while (sibling !== null) {
        node = sibling;
        result = tw._internalFilter(node);
        if (result === NodeFilter.FILTER_ACCEPT) {
          tw._currentNode = node;
          return node;
        }
        sibling = node[mapChild[type]];
        if (result === NodeFilter.FILTER_REJECT || sibling === null) {
          sibling = node[mapSibling[type]];
        }
      }
      node = node.parentNode;
      if (node === null || node === tw.root) {
        return null;
      }
      if (tw._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
        return null;
      }
    }
  }
  function TreeWalker(root2, whatToShow, filter) {
    if (!root2 || !root2.nodeType) {
      utils.NotSupportedError();
    }
    this._root = root2;
    this._whatToShow = Number(whatToShow) || 0;
    this._filter = filter || null;
    this._active = false;
    this._currentNode = root2;
  }
  Object.defineProperties(TreeWalker.prototype, {
    root: {get: function() {
      return this._root;
    }},
    whatToShow: {get: function() {
      return this._whatToShow;
    }},
    filter: {get: function() {
      return this._filter;
    }},
    currentNode: {
      get: function currentNode() {
        return this._currentNode;
      },
      set: function setCurrentNode(v) {
        if (!(v instanceof Node2)) {
          throw new TypeError("Not a Node");
        }
        this._currentNode = v;
      }
    },
    _internalFilter: {value: function _internalFilter(node) {
      var result, filter;
      if (this._active) {
        utils.InvalidStateError();
      }
      if (!(1 << node.nodeType - 1 & this._whatToShow)) {
        return NodeFilter.FILTER_SKIP;
      }
      filter = this._filter;
      if (filter === null) {
        result = NodeFilter.FILTER_ACCEPT;
      } else {
        this._active = true;
        try {
          if (typeof filter === "function") {
            result = filter(node);
          } else {
            result = filter.acceptNode(node);
          }
        } finally {
          this._active = false;
        }
      }
      return +result;
    }},
    parentNode: {value: function parentNode() {
      var node = this._currentNode;
      while (node !== this.root) {
        node = node.parentNode;
        if (node === null) {
          return null;
        }
        if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
          this._currentNode = node;
          return node;
        }
      }
      return null;
    }},
    firstChild: {value: function firstChild() {
      return traverseChildren(this, "first");
    }},
    lastChild: {value: function lastChild() {
      return traverseChildren(this, "last");
    }},
    previousSibling: {value: function previousSibling() {
      return traverseSiblings(this, "previous");
    }},
    nextSibling: {value: function nextSibling() {
      return traverseSiblings(this, "next");
    }},
    previousNode: {value: function previousNode() {
      var node, result, previousSibling, lastChild;
      node = this._currentNode;
      while (node !== this._root) {
        for (previousSibling = node.previousSibling; previousSibling; previousSibling = node.previousSibling) {
          node = previousSibling;
          result = this._internalFilter(node);
          if (result === NodeFilter.FILTER_REJECT) {
            continue;
          }
          for (lastChild = node.lastChild; lastChild; lastChild = node.lastChild) {
            node = lastChild;
            result = this._internalFilter(node);
            if (result === NodeFilter.FILTER_REJECT) {
              break;
            }
          }
          if (result === NodeFilter.FILTER_ACCEPT) {
            this._currentNode = node;
            return node;
          }
        }
        if (node === this.root || node.parentNode === null) {
          return null;
        }
        node = node.parentNode;
        if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
          this._currentNode = node;
          return node;
        }
      }
      return null;
    }},
    nextNode: {value: function nextNode() {
      var node, result, firstChild, nextSibling;
      node = this._currentNode;
      result = NodeFilter.FILTER_ACCEPT;
      CHILDREN:
        while (true) {
          for (firstChild = node.firstChild; firstChild; firstChild = node.firstChild) {
            node = firstChild;
            result = this._internalFilter(node);
            if (result === NodeFilter.FILTER_ACCEPT) {
              this._currentNode = node;
              return node;
            } else if (result === NodeFilter.FILTER_REJECT) {
              break;
            }
          }
          for (nextSibling = NodeTraversal.nextSkippingChildren(node, this.root); nextSibling; nextSibling = NodeTraversal.nextSkippingChildren(node, this.root)) {
            node = nextSibling;
            result = this._internalFilter(node);
            if (result === NodeFilter.FILTER_ACCEPT) {
              this._currentNode = node;
              return node;
            } else if (result === NodeFilter.FILTER_SKIP) {
              continue CHILDREN;
            }
          }
          return null;
        }
    }},
    toString: {value: function toString() {
      return "[object TreeWalker]";
    }}
  });
});

// node_modules/domino/lib/NodeIterator.js
var require_NodeIterator = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = NodeIterator;
  var NodeFilter = require_NodeFilter();
  var NodeTraversal = require_NodeTraversal();
  var utils = require_utils4();
  function move(node, stayWithin, directionIsNext) {
    if (directionIsNext) {
      return NodeTraversal.next(node, stayWithin);
    } else {
      if (node === stayWithin) {
        return null;
      }
      return NodeTraversal.previous(node, null);
    }
  }
  function isInclusiveAncestor(node, possibleChild) {
    for (; possibleChild; possibleChild = possibleChild.parentNode) {
      if (node === possibleChild) {
        return true;
      }
    }
    return false;
  }
  function traverse(ni, directionIsNext) {
    var node, beforeNode;
    node = ni._referenceNode;
    beforeNode = ni._pointerBeforeReferenceNode;
    while (true) {
      if (beforeNode === directionIsNext) {
        beforeNode = !beforeNode;
      } else {
        node = move(node, ni._root, directionIsNext);
        if (node === null) {
          return null;
        }
      }
      var result = ni._internalFilter(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        break;
      }
    }
    ni._referenceNode = node;
    ni._pointerBeforeReferenceNode = beforeNode;
    return node;
  }
  function NodeIterator(root2, whatToShow, filter) {
    if (!root2 || !root2.nodeType) {
      utils.NotSupportedError();
    }
    this._root = root2;
    this._referenceNode = root2;
    this._pointerBeforeReferenceNode = true;
    this._whatToShow = Number(whatToShow) || 0;
    this._filter = filter || null;
    this._active = false;
    root2.doc._attachNodeIterator(this);
  }
  Object.defineProperties(NodeIterator.prototype, {
    root: {get: function root2() {
      return this._root;
    }},
    referenceNode: {get: function referenceNode() {
      return this._referenceNode;
    }},
    pointerBeforeReferenceNode: {get: function pointerBeforeReferenceNode() {
      return this._pointerBeforeReferenceNode;
    }},
    whatToShow: {get: function whatToShow() {
      return this._whatToShow;
    }},
    filter: {get: function filter() {
      return this._filter;
    }},
    _internalFilter: {value: function _internalFilter(node) {
      var result, filter;
      if (this._active) {
        utils.InvalidStateError();
      }
      if (!(1 << node.nodeType - 1 & this._whatToShow)) {
        return NodeFilter.FILTER_SKIP;
      }
      filter = this._filter;
      if (filter === null) {
        result = NodeFilter.FILTER_ACCEPT;
      } else {
        this._active = true;
        try {
          if (typeof filter === "function") {
            result = filter(node);
          } else {
            result = filter.acceptNode(node);
          }
        } finally {
          this._active = false;
        }
      }
      return +result;
    }},
    _preremove: {value: function _preremove(toBeRemovedNode) {
      if (isInclusiveAncestor(toBeRemovedNode, this._root)) {
        return;
      }
      if (!isInclusiveAncestor(toBeRemovedNode, this._referenceNode)) {
        return;
      }
      if (this._pointerBeforeReferenceNode) {
        var next2 = toBeRemovedNode;
        while (next2.lastChild) {
          next2 = next2.lastChild;
        }
        next2 = NodeTraversal.next(next2, this.root);
        if (next2) {
          this._referenceNode = next2;
          return;
        }
        this._pointerBeforeReferenceNode = false;
      }
      if (toBeRemovedNode.previousSibling === null) {
        this._referenceNode = toBeRemovedNode.parentNode;
      } else {
        this._referenceNode = toBeRemovedNode.previousSibling;
        var lastChild;
        for (lastChild = this._referenceNode.lastChild; lastChild; lastChild = this._referenceNode.lastChild) {
          this._referenceNode = lastChild;
        }
      }
    }},
    nextNode: {value: function nextNode() {
      return traverse(this, true);
    }},
    previousNode: {value: function previousNode() {
      return traverse(this, false);
    }},
    detach: {value: function detach() {
    }},
    toString: {value: function toString() {
      return "[object NodeIterator]";
    }}
  });
});

// node_modules/domino/lib/URL.js
var require_URL = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = URL;
  function URL(url) {
    if (!url)
      return Object.create(URL.prototype);
    this.url = url.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "");
    var match = URL.pattern.exec(this.url);
    if (match) {
      if (match[2])
        this.scheme = match[2];
      if (match[4]) {
        var userinfo = match[4].match(URL.userinfoPattern);
        if (userinfo) {
          this.username = userinfo[1];
          this.password = userinfo[3];
          match[4] = match[4].substring(userinfo[0].length);
        }
        if (match[4].match(URL.portPattern)) {
          var pos = match[4].lastIndexOf(":");
          this.host = match[4].substring(0, pos);
          this.port = match[4].substring(pos + 1);
        } else {
          this.host = match[4];
        }
      }
      if (match[5])
        this.path = match[5];
      if (match[6])
        this.query = match[7];
      if (match[8])
        this.fragment = match[9];
    }
  }
  URL.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/;
  URL.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;
  URL.portPattern = /:\d+$/;
  URL.authorityPattern = /^[^:\/?#]+:\/\//;
  URL.hierarchyPattern = /^[^:\/?#]+:\//;
  URL.percentEncode = function percentEncode(s) {
    var c = s.charCodeAt(0);
    if (c < 256)
      return "%" + c.toString(16);
    else
      throw Error("can't percent-encode codepoints > 255 yet");
  };
  URL.prototype = {
    constructor: URL,
    isAbsolute: function() {
      return !!this.scheme;
    },
    isAuthorityBased: function() {
      return URL.authorityPattern.test(this.url);
    },
    isHierarchical: function() {
      return URL.hierarchyPattern.test(this.url);
    },
    toString: function() {
      var s = "";
      if (this.scheme !== void 0)
        s += this.scheme + ":";
      if (this.isAbsolute()) {
        s += "//";
        if (this.username || this.password) {
          s += this.username || "";
          if (this.password) {
            s += ":" + this.password;
          }
          s += "@";
        }
        if (this.host) {
          s += this.host;
        }
      }
      if (this.port !== void 0)
        s += ":" + this.port;
      if (this.path !== void 0)
        s += this.path;
      if (this.query !== void 0)
        s += "?" + this.query;
      if (this.fragment !== void 0)
        s += "#" + this.fragment;
      return s;
    },
    resolve: function(relative) {
      var base = this;
      var r = new URL(relative);
      var t = new URL();
      if (r.scheme !== void 0) {
        t.scheme = r.scheme;
        t.username = r.username;
        t.password = r.password;
        t.host = r.host;
        t.port = r.port;
        t.path = remove_dot_segments(r.path);
        t.query = r.query;
      } else {
        t.scheme = base.scheme;
        if (r.host !== void 0) {
          t.username = r.username;
          t.password = r.password;
          t.host = r.host;
          t.port = r.port;
          t.path = remove_dot_segments(r.path);
          t.query = r.query;
        } else {
          t.username = base.username;
          t.password = base.password;
          t.host = base.host;
          t.port = base.port;
          if (!r.path) {
            t.path = base.path;
            if (r.query !== void 0)
              t.query = r.query;
            else
              t.query = base.query;
          } else {
            if (r.path.charAt(0) === "/") {
              t.path = remove_dot_segments(r.path);
            } else {
              t.path = merge(base.path, r.path);
              t.path = remove_dot_segments(t.path);
            }
            t.query = r.query;
          }
        }
      }
      t.fragment = r.fragment;
      return t.toString();
      function merge(basepath, refpath) {
        if (base.host !== void 0 && !base.path)
          return "/" + refpath;
        var lastslash = basepath.lastIndexOf("/");
        if (lastslash === -1)
          return refpath;
        else
          return basepath.substring(0, lastslash + 1) + refpath;
      }
      function remove_dot_segments(path) {
        if (!path)
          return path;
        var output = "";
        while (path.length > 0) {
          if (path === "." || path === "..") {
            path = "";
            break;
          }
          var twochars = path.substring(0, 2);
          var threechars = path.substring(0, 3);
          var fourchars = path.substring(0, 4);
          if (threechars === "../") {
            path = path.substring(3);
          } else if (twochars === "./") {
            path = path.substring(2);
          } else if (threechars === "/./") {
            path = "/" + path.substring(3);
          } else if (twochars === "/." && path.length === 2) {
            path = "/";
          } else if (fourchars === "/../" || threechars === "/.." && path.length === 3) {
            path = "/" + path.substring(4);
            output = output.replace(/\/?[^\/]*$/, "");
          } else {
            var segment = path.match(/(\/?([^\/]*))/)[0];
            output += segment;
            path = path.substring(segment.length);
          }
        }
        return output;
      }
    }
  };
});

// node_modules/domino/lib/CustomEvent.js
var require_CustomEvent = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = CustomEvent;
  var Event = require_Event();
  function CustomEvent(type, dictionary) {
    Event.call(this, type, dictionary);
  }
  CustomEvent.prototype = Object.create(Event.prototype, {
    constructor: {value: CustomEvent}
  });
});

// node_modules/domino/lib/events.js
var require_events = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    Event: require_Event(),
    UIEvent: require_UIEvent(),
    MouseEvent: require_MouseEvent(),
    CustomEvent: require_CustomEvent()
  };
});

// node_modules/domino/lib/cssparser.js
var require_cssparser = __commonJS((exports2) => {
  "use strict";
  /*!
  Parser-Lib
  Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
  */
  var parserlib = Object.create(null);
  (function() {
    function EventTarget() {
      this._listeners = Object.create(null);
    }
    EventTarget.prototype = {
      constructor: EventTarget,
      addListener: function(type, listener) {
        if (!this._listeners[type]) {
          this._listeners[type] = [];
        }
        this._listeners[type].push(listener);
      },
      fire: function(event) {
        if (typeof event === "string") {
          event = {type: event};
        }
        if (typeof event.target !== "undefined") {
          event.target = this;
        }
        if (typeof event.type === "undefined") {
          throw new Error("Event object missing 'type' property.");
        }
        if (this._listeners[event.type]) {
          var listeners = this._listeners[event.type].concat();
          for (var i = 0, len = listeners.length; i < len; i++) {
            listeners[i].call(this, event);
          }
        }
      },
      removeListener: function(type, listener) {
        if (this._listeners[type]) {
          var listeners = this._listeners[type];
          for (var i = 0, len = listeners.length; i < len; i++) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              break;
            }
          }
        }
      }
    };
    function StringReader(text) {
      this._input = text.replace(/(\r|\n){1,2}/g, "\n");
      this._line = 1;
      this._col = 1;
      this._cursor = 0;
    }
    StringReader.prototype = {
      constructor: StringReader,
      getCol: function() {
        return this._col;
      },
      getLine: function() {
        return this._line;
      },
      eof: function() {
        return this._cursor === this._input.length;
      },
      peek: function(count) {
        var c = null;
        count = typeof count === "undefined" ? 1 : count;
        if (this._cursor < this._input.length) {
          c = this._input.charAt(this._cursor + count - 1);
        }
        return c;
      },
      read: function() {
        var c = null;
        if (this._cursor < this._input.length) {
          if (this._input.charAt(this._cursor) === "\n") {
            this._line++;
            this._col = 1;
          } else {
            this._col++;
          }
          c = this._input.charAt(this._cursor++);
        }
        return c;
      },
      mark: function() {
        this._bookmark = {
          cursor: this._cursor,
          line: this._line,
          col: this._col
        };
      },
      reset: function() {
        if (this._bookmark) {
          this._cursor = this._bookmark.cursor;
          this._line = this._bookmark.line;
          this._col = this._bookmark.col;
          delete this._bookmark;
        }
      },
      readTo: function(pattern) {
        var buffer = "", c;
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {
          c = this.read();
          if (c) {
            buffer += c;
          } else {
            throw new Error('Expected "' + pattern + '" at line ' + this._line + ", col " + this._col + ".");
          }
        }
        return buffer;
      },
      readWhile: function(filter) {
        var buffer = "", c = this.read();
        while (c !== null && filter(c)) {
          buffer += c;
          c = this.read();
        }
        return buffer;
      },
      readMatch: function(matcher) {
        var source = this._input.substring(this._cursor), value = null;
        if (typeof matcher === "string") {
          if (source.indexOf(matcher) === 0) {
            value = this.readCount(matcher.length);
          }
        } else if (matcher instanceof RegExp) {
          if (matcher.test(source)) {
            value = this.readCount(RegExp.lastMatch.length);
          }
        }
        return value;
      },
      readCount: function(count) {
        var buffer = "";
        while (count--) {
          buffer += this.read();
        }
        return buffer;
      }
    };
    function SyntaxError2(message, line, col) {
      Error.call(this);
      this.name = this.constructor.name;
      this.col = col;
      this.line = line;
      this.message = message;
    }
    SyntaxError2.prototype = Object.create(Error.prototype);
    SyntaxError2.prototype.constructor = SyntaxError2;
    function SyntaxUnit(text, line, col, type) {
      this.col = col;
      this.line = line;
      this.text = text;
      this.type = type;
    }
    SyntaxUnit.fromToken = function(token) {
      return new SyntaxUnit(token.value, token.startLine, token.startCol);
    };
    SyntaxUnit.prototype = {
      constructor: SyntaxUnit,
      valueOf: function() {
        return this.toString();
      },
      toString: function() {
        return this.text;
      }
    };
    function TokenStreamBase(input, tokenData) {
      this._reader = input ? new StringReader(input.toString()) : null;
      this._token = null;
      this._tokenData = tokenData;
      this._lt = [];
      this._ltIndex = 0;
      this._ltIndexCache = [];
    }
    TokenStreamBase.createTokenData = function(tokens) {
      var nameMap = [], typeMap = Object.create(null), tokenData = tokens.concat([]), i = 0, len = tokenData.length + 1;
      tokenData.UNKNOWN = -1;
      tokenData.unshift({name: "EOF"});
      for (; i < len; i++) {
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text) {
          typeMap[tokenData[i].text] = i;
        }
      }
      tokenData.name = function(tt) {
        return nameMap[tt];
      };
      tokenData.type = function(c) {
        return typeMap[c];
      };
      return tokenData;
    };
    TokenStreamBase.prototype = {
      constructor: TokenStreamBase,
      match: function(tokenTypes, channel) {
        if (!(tokenTypes instanceof Array)) {
          tokenTypes = [tokenTypes];
        }
        var tt = this.get(channel), i = 0, len = tokenTypes.length;
        while (i < len) {
          if (tt === tokenTypes[i++]) {
            return true;
          }
        }
        this.unget();
        return false;
      },
      mustMatch: function(tokenTypes, channel) {
        var token;
        if (!(tokenTypes instanceof Array)) {
          tokenTypes = [tokenTypes];
        }
        if (!this.match.apply(this, arguments)) {
          token = this.LT(1);
          throw new SyntaxError2("Expected " + this._tokenData[tokenTypes[0]].name + " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
      },
      advance: function(tokenTypes, channel) {
        while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {
          this.get();
        }
        return this.LA(0);
      },
      get: function(channel) {
        var tokenInfo = this._tokenData, i = 0, token, info;
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length) {
          i++;
          this._token = this._lt[this._ltIndex++];
          info = tokenInfo[this._token.type];
          while (info.channel !== void 0 && channel !== info.channel && this._ltIndex < this._lt.length) {
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];
            i++;
          }
          if ((info.channel === void 0 || channel === info.channel) && this._ltIndex <= this._lt.length) {
            this._ltIndexCache.push(i);
            return this._token.type;
          }
        }
        token = this._getToken();
        if (token.type > -1 && !tokenInfo[token.type].hide) {
          token.channel = tokenInfo[token.type].channel;
          this._token = token;
          this._lt.push(token);
          this._ltIndexCache.push(this._lt.length - this._ltIndex + i);
          if (this._lt.length > 5) {
            this._lt.shift();
          }
          if (this._ltIndexCache.length > 5) {
            this._ltIndexCache.shift();
          }
          this._ltIndex = this._lt.length;
        }
        info = tokenInfo[token.type];
        if (info && (info.hide || info.channel !== void 0 && channel !== info.channel)) {
          return this.get(channel);
        } else {
          return token.type;
        }
      },
      LA: function(index) {
        var total = index, tt;
        if (index > 0) {
          if (index > 5) {
            throw new Error("Too much lookahead.");
          }
          while (total) {
            tt = this.get();
            total--;
          }
          while (total < index) {
            this.unget();
            total++;
          }
        } else if (index < 0) {
          if (this._lt[this._ltIndex + index]) {
            tt = this._lt[this._ltIndex + index].type;
          } else {
            throw new Error("Too much lookbehind.");
          }
        } else {
          tt = this._token.type;
        }
        return tt;
      },
      LT: function(index) {
        this.LA(index);
        return this._lt[this._ltIndex + index - 1];
      },
      peek: function() {
        return this.LA(1);
      },
      token: function() {
        return this._token;
      },
      tokenName: function(tokenType) {
        if (tokenType < 0 || tokenType > this._tokenData.length) {
          return "UNKNOWN_TOKEN";
        } else {
          return this._tokenData[tokenType].name;
        }
      },
      tokenType: function(tokenName) {
        return this._tokenData[tokenName] || -1;
      },
      unget: function() {
        if (this._ltIndexCache.length) {
          this._ltIndex -= this._ltIndexCache.pop();
          this._token = this._lt[this._ltIndex - 1];
        } else {
          throw new Error("Too much lookahead.");
        }
      }
    };
    parserlib.util = {
      __proto__: null,
      StringReader,
      SyntaxError: SyntaxError2,
      SyntaxUnit,
      EventTarget,
      TokenStreamBase
    };
  })();
  (function() {
    var EventTarget = parserlib.util.EventTarget, TokenStreamBase = parserlib.util.TokenStreamBase, StringReader = parserlib.util.StringReader, SyntaxError2 = parserlib.util.SyntaxError, SyntaxUnit = parserlib.util.SyntaxUnit;
    var Colors = {
      __proto__: null,
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgrey: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgrey: "#d3d3d3",
      lightgreen: "#90ee90",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370d8",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#d87093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32",
      currentColor: "The value of the 'color' property.",
      activeBorder: "Active window border.",
      activecaption: "Active window caption.",
      appworkspace: "Background color of multiple document interface.",
      background: "Desktop background.",
      buttonface: "The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
      buttonhighlight: "The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
      buttonshadow: "The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
      buttontext: "Text on push buttons.",
      captiontext: "Text in caption, size box, and scrollbar arrow box.",
      graytext: "Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
      greytext: "Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
      highlight: "Item(s) selected in a control.",
      highlighttext: "Text of item(s) selected in a control.",
      inactiveborder: "Inactive window border.",
      inactivecaption: "Inactive window caption.",
      inactivecaptiontext: "Color of text in an inactive caption.",
      infobackground: "Background color for tooltip controls.",
      infotext: "Text color for tooltip controls.",
      menu: "Menu background.",
      menutext: "Text in menus.",
      scrollbar: "Scroll bar gray area.",
      threeddarkshadow: "The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
      threedface: "The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
      threedhighlight: "The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
      threedlightshadow: "The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
      threedshadow: "The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
      window: "Window background.",
      windowframe: "Window frame.",
      windowtext: "Text in windows."
    };
    function Combinator(text, line, col) {
      SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);
      this.type = "unknown";
      if (/^\s+$/.test(text)) {
        this.type = "descendant";
      } else if (text === ">") {
        this.type = "child";
      } else if (text === "+") {
        this.type = "adjacent-sibling";
      } else if (text === "~") {
        this.type = "sibling";
      }
    }
    Combinator.prototype = new SyntaxUnit();
    Combinator.prototype.constructor = Combinator;
    function MediaFeature(name, value) {
      SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);
      this.name = name;
      this.value = value;
    }
    MediaFeature.prototype = new SyntaxUnit();
    MediaFeature.prototype.constructor = MediaFeature;
    function MediaQuery(modifier, mediaType, features, line, col) {
      SyntaxUnit.call(this, (modifier ? modifier + " " : "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);
      this.modifier = modifier;
      this.mediaType = mediaType;
      this.features = features;
    }
    MediaQuery.prototype = new SyntaxUnit();
    MediaQuery.prototype.constructor = MediaQuery;
    function Parser(options) {
      EventTarget.call(this);
      this.options = options || {};
      this._tokenStream = null;
    }
    Parser.DEFAULT_TYPE = 0;
    Parser.COMBINATOR_TYPE = 1;
    Parser.MEDIA_FEATURE_TYPE = 2;
    Parser.MEDIA_QUERY_TYPE = 3;
    Parser.PROPERTY_NAME_TYPE = 4;
    Parser.PROPERTY_VALUE_TYPE = 5;
    Parser.PROPERTY_VALUE_PART_TYPE = 6;
    Parser.SELECTOR_TYPE = 7;
    Parser.SELECTOR_PART_TYPE = 8;
    Parser.SELECTOR_SUB_PART_TYPE = 9;
    Parser.prototype = function() {
      var proto = new EventTarget(), prop, additions = {
        __proto__: null,
        constructor: Parser,
        DEFAULT_TYPE: 0,
        COMBINATOR_TYPE: 1,
        MEDIA_FEATURE_TYPE: 2,
        MEDIA_QUERY_TYPE: 3,
        PROPERTY_NAME_TYPE: 4,
        PROPERTY_VALUE_TYPE: 5,
        PROPERTY_VALUE_PART_TYPE: 6,
        SELECTOR_TYPE: 7,
        SELECTOR_PART_TYPE: 8,
        SELECTOR_SUB_PART_TYPE: 9,
        _stylesheet: function() {
          var tokenStream = this._tokenStream, count, token, tt;
          this.fire("startstylesheet");
          this._charset();
          this._skipCruft();
          while (tokenStream.peek() === Tokens.IMPORT_SYM) {
            this._import();
            this._skipCruft();
          }
          while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
            this._namespace();
            this._skipCruft();
          }
          tt = tokenStream.peek();
          while (tt > Tokens.EOF) {
            try {
              switch (tt) {
                case Tokens.MEDIA_SYM:
                  this._media();
                  this._skipCruft();
                  break;
                case Tokens.PAGE_SYM:
                  this._page();
                  this._skipCruft();
                  break;
                case Tokens.FONT_FACE_SYM:
                  this._font_face();
                  this._skipCruft();
                  break;
                case Tokens.KEYFRAMES_SYM:
                  this._keyframes();
                  this._skipCruft();
                  break;
                case Tokens.VIEWPORT_SYM:
                  this._viewport();
                  this._skipCruft();
                  break;
                case Tokens.DOCUMENT_SYM:
                  this._document();
                  this._skipCruft();
                  break;
                case Tokens.UNKNOWN_SYM:
                  tokenStream.get();
                  if (!this.options.strict) {
                    this.fire({
                      type: "error",
                      error: null,
                      message: "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                      line: tokenStream.LT(0).startLine,
                      col: tokenStream.LT(0).startCol
                    });
                    count = 0;
                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
                      count++;
                    }
                    while (count) {
                      tokenStream.advance([Tokens.RBRACE]);
                      count--;
                    }
                  } else {
                    throw new SyntaxError2("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                  }
                  break;
                case Tokens.S:
                  this._readWhitespace();
                  break;
                default:
                  if (!this._ruleset()) {
                    switch (tt) {
                      case Tokens.CHARSET_SYM:
                        token = tokenStream.LT(1);
                        this._charset(false);
                        throw new SyntaxError2("@charset not allowed here.", token.startLine, token.startCol);
                      case Tokens.IMPORT_SYM:
                        token = tokenStream.LT(1);
                        this._import(false);
                        throw new SyntaxError2("@import not allowed here.", token.startLine, token.startCol);
                      case Tokens.NAMESPACE_SYM:
                        token = tokenStream.LT(1);
                        this._namespace(false);
                        throw new SyntaxError2("@namespace not allowed here.", token.startLine, token.startCol);
                      default:
                        tokenStream.get();
                        this._unexpectedToken(tokenStream.token());
                    }
                  }
              }
            } catch (ex) {
              if (ex instanceof SyntaxError2 && !this.options.strict) {
                this.fire({
                  type: "error",
                  error: ex,
                  message: ex.message,
                  line: ex.line,
                  col: ex.col
                });
              } else {
                throw ex;
              }
            }
            tt = tokenStream.peek();
          }
          if (tt !== Tokens.EOF) {
            this._unexpectedToken(tokenStream.token());
          }
          this.fire("endstylesheet");
        },
        _charset: function(emit) {
          var tokenStream = this._tokenStream, charset, token, line, col;
          if (tokenStream.match(Tokens.CHARSET_SYM)) {
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.STRING);
            token = tokenStream.token();
            charset = token.value;
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.SEMICOLON);
            if (emit !== false) {
              this.fire({
                type: "charset",
                charset,
                line,
                col
              });
            }
          }
        },
        _import: function(emit) {
          var tokenStream = this._tokenStream, uri, importToken, mediaList = [];
          tokenStream.mustMatch(Tokens.IMPORT_SYM);
          importToken = tokenStream.token();
          this._readWhitespace();
          tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
          uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");
          this._readWhitespace();
          mediaList = this._media_query_list();
          tokenStream.mustMatch(Tokens.SEMICOLON);
          this._readWhitespace();
          if (emit !== false) {
            this.fire({
              type: "import",
              uri,
              media: mediaList,
              line: importToken.startLine,
              col: importToken.startCol
            });
          }
        },
        _namespace: function(emit) {
          var tokenStream = this._tokenStream, line, col, prefix, uri;
          tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
          line = tokenStream.token().startLine;
          col = tokenStream.token().startCol;
          this._readWhitespace();
          if (tokenStream.match(Tokens.IDENT)) {
            prefix = tokenStream.token().value;
            this._readWhitespace();
          }
          tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
          uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");
          this._readWhitespace();
          tokenStream.mustMatch(Tokens.SEMICOLON);
          this._readWhitespace();
          if (emit !== false) {
            this.fire({
              type: "namespace",
              prefix,
              uri,
              line,
              col
            });
          }
        },
        _media: function() {
          var tokenStream = this._tokenStream, line, col, mediaList;
          tokenStream.mustMatch(Tokens.MEDIA_SYM);
          line = tokenStream.token().startLine;
          col = tokenStream.token().startCol;
          this._readWhitespace();
          mediaList = this._media_query_list();
          tokenStream.mustMatch(Tokens.LBRACE);
          this._readWhitespace();
          this.fire({
            type: "startmedia",
            media: mediaList,
            line,
            col
          });
          while (true) {
            if (tokenStream.peek() === Tokens.PAGE_SYM) {
              this._page();
            } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
              this._font_face();
            } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
              this._viewport();
            } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {
              this._document();
            } else if (!this._ruleset()) {
              break;
            }
          }
          tokenStream.mustMatch(Tokens.RBRACE);
          this._readWhitespace();
          this.fire({
            type: "endmedia",
            media: mediaList,
            line,
            col
          });
        },
        _media_query_list: function() {
          var tokenStream = this._tokenStream, mediaList = [];
          this._readWhitespace();
          if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
            mediaList.push(this._media_query());
          }
          while (tokenStream.match(Tokens.COMMA)) {
            this._readWhitespace();
            mediaList.push(this._media_query());
          }
          return mediaList;
        },
        _media_query: function() {
          var tokenStream = this._tokenStream, type = null, ident = null, token = null, expressions = [];
          if (tokenStream.match(Tokens.IDENT)) {
            ident = tokenStream.token().value.toLowerCase();
            if (ident !== "only" && ident !== "not") {
              tokenStream.unget();
              ident = null;
            } else {
              token = tokenStream.token();
            }
          }
          this._readWhitespace();
          if (tokenStream.peek() === Tokens.IDENT) {
            type = this._media_type();
            if (token === null) {
              token = tokenStream.token();
            }
          } else if (tokenStream.peek() === Tokens.LPAREN) {
            if (token === null) {
              token = tokenStream.LT(1);
            }
            expressions.push(this._media_expression());
          }
          if (type === null && expressions.length === 0) {
            return null;
          } else {
            this._readWhitespace();
            while (tokenStream.match(Tokens.IDENT)) {
              if (tokenStream.token().value.toLowerCase() !== "and") {
                this._unexpectedToken(tokenStream.token());
              }
              this._readWhitespace();
              expressions.push(this._media_expression());
            }
          }
          return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
        },
        _media_type: function() {
          return this._media_feature();
        },
        _media_expression: function() {
          var tokenStream = this._tokenStream, feature = null, token, expression = null;
          tokenStream.mustMatch(Tokens.LPAREN);
          feature = this._media_feature();
          this._readWhitespace();
          if (tokenStream.match(Tokens.COLON)) {
            this._readWhitespace();
            token = tokenStream.LT(1);
            expression = this._expression();
          }
          tokenStream.mustMatch(Tokens.RPAREN);
          this._readWhitespace();
          return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
        },
        _media_feature: function() {
          var tokenStream = this._tokenStream;
          this._readWhitespace();
          tokenStream.mustMatch(Tokens.IDENT);
          return SyntaxUnit.fromToken(tokenStream.token());
        },
        _page: function() {
          var tokenStream = this._tokenStream, line, col, identifier = null, pseudoPage = null;
          tokenStream.mustMatch(Tokens.PAGE_SYM);
          line = tokenStream.token().startLine;
          col = tokenStream.token().startCol;
          this._readWhitespace();
          if (tokenStream.match(Tokens.IDENT)) {
            identifier = tokenStream.token().value;
            if (identifier.toLowerCase() === "auto") {
              this._unexpectedToken(tokenStream.token());
            }
          }
          if (tokenStream.peek() === Tokens.COLON) {
            pseudoPage = this._pseudo_page();
          }
          this._readWhitespace();
          this.fire({
            type: "startpage",
            id: identifier,
            pseudo: pseudoPage,
            line,
            col
          });
          this._readDeclarations(true, true);
          this.fire({
            type: "endpage",
            id: identifier,
            pseudo: pseudoPage,
            line,
            col
          });
        },
        _margin: function() {
          var tokenStream = this._tokenStream, line, col, marginSym = this._margin_sym();
          if (marginSym) {
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            this.fire({
              type: "startpagemargin",
              margin: marginSym,
              line,
              col
            });
            this._readDeclarations(true);
            this.fire({
              type: "endpagemargin",
              margin: marginSym,
              line,
              col
            });
            return true;
          } else {
            return false;
          }
        },
        _margin_sym: function() {
          var tokenStream = this._tokenStream;
          if (tokenStream.match([
            Tokens.TOPLEFTCORNER_SYM,
            Tokens.TOPLEFT_SYM,
            Tokens.TOPCENTER_SYM,
            Tokens.TOPRIGHT_SYM,
            Tokens.TOPRIGHTCORNER_SYM,
            Tokens.BOTTOMLEFTCORNER_SYM,
            Tokens.BOTTOMLEFT_SYM,
            Tokens.BOTTOMCENTER_SYM,
            Tokens.BOTTOMRIGHT_SYM,
            Tokens.BOTTOMRIGHTCORNER_SYM,
            Tokens.LEFTTOP_SYM,
            Tokens.LEFTMIDDLE_SYM,
            Tokens.LEFTBOTTOM_SYM,
            Tokens.RIGHTTOP_SYM,
            Tokens.RIGHTMIDDLE_SYM,
            Tokens.RIGHTBOTTOM_SYM
          ])) {
            return SyntaxUnit.fromToken(tokenStream.token());
          } else {
            return null;
          }
        },
        _pseudo_page: function() {
          var tokenStream = this._tokenStream;
          tokenStream.mustMatch(Tokens.COLON);
          tokenStream.mustMatch(Tokens.IDENT);
          return tokenStream.token().value;
        },
        _font_face: function() {
          var tokenStream = this._tokenStream, line, col;
          tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
          line = tokenStream.token().startLine;
          col = tokenStream.token().startCol;
          this._readWhitespace();
          this.fire({
            type: "startfontface",
            line,
            col
          });
          this._readDeclarations(true);
          this.fire({
            type: "endfontface",
            line,
            col
          });
        },
        _viewport: function() {
          var tokenStream = this._tokenStream, line, col;
          tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
          line = tokenStream.token().startLine;
          col = tokenStream.token().startCol;
          this._readWhitespace();
          this.fire({
            type: "startviewport",
            line,
            col
          });
          this._readDeclarations(true);
          this.fire({
            type: "endviewport",
            line,
            col
          });
        },
        _document: function() {
          var tokenStream = this._tokenStream, token, functions = [], prefix = "";
          tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
          token = tokenStream.token();
          if (/^@\-([^\-]+)\-/.test(token.value)) {
            prefix = RegExp.$1;
          }
          this._readWhitespace();
          functions.push(this._document_function());
          while (tokenStream.match(Tokens.COMMA)) {
            this._readWhitespace();
            functions.push(this._document_function());
          }
          tokenStream.mustMatch(Tokens.LBRACE);
          this._readWhitespace();
          this.fire({
            type: "startdocument",
            functions,
            prefix,
            line: token.startLine,
            col: token.startCol
          });
          while (true) {
            if (tokenStream.peek() === Tokens.PAGE_SYM) {
              this._page();
            } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
              this._font_face();
            } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
              this._viewport();
            } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {
              this._media();
            } else if (!this._ruleset()) {
              break;
            }
          }
          tokenStream.mustMatch(Tokens.RBRACE);
          this._readWhitespace();
          this.fire({
            type: "enddocument",
            functions,
            prefix,
            line: token.startLine,
            col: token.startCol
          });
        },
        _document_function: function() {
          var tokenStream = this._tokenStream, value;
          if (tokenStream.match(Tokens.URI)) {
            value = tokenStream.token().value;
            this._readWhitespace();
          } else {
            value = this._function();
          }
          return value;
        },
        _operator: function(inFunction) {
          var tokenStream = this._tokenStream, token = null;
          if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) || inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS])) {
            token = tokenStream.token();
            this._readWhitespace();
          }
          return token ? PropertyValuePart.fromToken(token) : null;
        },
        _combinator: function() {
          var tokenStream = this._tokenStream, value = null, token;
          if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {
            token = tokenStream.token();
            value = new Combinator(token.value, token.startLine, token.startCol);
            this._readWhitespace();
          }
          return value;
        },
        _unary_operator: function() {
          var tokenStream = this._tokenStream;
          if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {
            return tokenStream.token().value;
          } else {
            return null;
          }
        },
        _property: function() {
          var tokenStream = this._tokenStream, value = null, hack = null, tokenValue, token, line, col;
          if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {
            tokenStream.get();
            token = tokenStream.token();
            hack = token.value;
            line = token.startLine;
            col = token.startCol;
          }
          if (tokenStream.match(Tokens.IDENT)) {
            token = tokenStream.token();
            tokenValue = token.value;
            if (tokenValue.charAt(0) === "_" && this.options.underscoreHack) {
              hack = "_";
              tokenValue = tokenValue.substring(1);
            }
            value = new PropertyName(tokenValue, hack, line || token.startLine, col || token.startCol);
            this._readWhitespace();
          }
          return value;
        },
        _ruleset: function() {
          var tokenStream = this._tokenStream, tt, selectors;
          try {
            selectors = this._selectors_group();
          } catch (ex) {
            if (ex instanceof SyntaxError2 && !this.options.strict) {
              this.fire({
                type: "error",
                error: ex,
                message: ex.message,
                line: ex.line,
                col: ex.col
              });
              tt = tokenStream.advance([Tokens.RBRACE]);
              if (tt === Tokens.RBRACE) {
              } else {
                throw ex;
              }
            } else {
              throw ex;
            }
            return true;
          }
          if (selectors) {
            this.fire({
              type: "startrule",
              selectors,
              line: selectors[0].line,
              col: selectors[0].col
            });
            this._readDeclarations(true);
            this.fire({
              type: "endrule",
              selectors,
              line: selectors[0].line,
              col: selectors[0].col
            });
          }
          return selectors;
        },
        _selectors_group: function() {
          var tokenStream = this._tokenStream, selectors = [], selector;
          selector = this._selector();
          if (selector !== null) {
            selectors.push(selector);
            while (tokenStream.match(Tokens.COMMA)) {
              this._readWhitespace();
              selector = this._selector();
              if (selector !== null) {
                selectors.push(selector);
              } else {
                this._unexpectedToken(tokenStream.LT(1));
              }
            }
          }
          return selectors.length ? selectors : null;
        },
        _selector: function() {
          var tokenStream = this._tokenStream, selector = [], nextSelector = null, combinator = null, ws = null;
          nextSelector = this._simple_selector_sequence();
          if (nextSelector === null) {
            return null;
          }
          selector.push(nextSelector);
          do {
            combinator = this._combinator();
            if (combinator !== null) {
              selector.push(combinator);
              nextSelector = this._simple_selector_sequence();
              if (nextSelector === null) {
                this._unexpectedToken(tokenStream.LT(1));
              } else {
                selector.push(nextSelector);
              }
            } else {
              if (this._readWhitespace()) {
                ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);
                combinator = this._combinator();
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null) {
                  if (combinator !== null) {
                    this._unexpectedToken(tokenStream.LT(1));
                  }
                } else {
                  if (combinator !== null) {
                    selector.push(combinator);
                  } else {
                    selector.push(ws);
                  }
                  selector.push(nextSelector);
                }
              } else {
                break;
              }
            }
          } while (true);
          return new Selector(selector, selector[0].line, selector[0].col);
        },
        _simple_selector_sequence: function() {
          var tokenStream = this._tokenStream, elementName = null, modifiers = [], selectorText = "", components = [
            function() {
              return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
            },
            this._class,
            this._attrib,
            this._pseudo,
            this._negation
          ], i = 0, len = components.length, component = null, line, col;
          line = tokenStream.LT(1).startLine;
          col = tokenStream.LT(1).startCol;
          elementName = this._type_selector();
          if (!elementName) {
            elementName = this._universal();
          }
          if (elementName !== null) {
            selectorText += elementName;
          }
          while (true) {
            if (tokenStream.peek() === Tokens.S) {
              break;
            }
            while (i < len && component === null) {
              component = components[i++].call(this);
            }
            if (component === null) {
              if (selectorText === "") {
                return null;
              } else {
                break;
              }
            } else {
              i = 0;
              modifiers.push(component);
              selectorText += component.toString();
              component = null;
            }
          }
          return selectorText !== "" ? new SelectorPart(elementName, modifiers, selectorText, line, col) : null;
        },
        _type_selector: function() {
          var tokenStream = this._tokenStream, ns = this._namespace_prefix(), elementName = this._element_name();
          if (!elementName) {
            if (ns) {
              tokenStream.unget();
              if (ns.length > 1) {
                tokenStream.unget();
              }
            }
            return null;
          } else {
            if (ns) {
              elementName.text = ns + elementName.text;
              elementName.col -= ns.length;
            }
            return elementName;
          }
        },
        _class: function() {
          var tokenStream = this._tokenStream, token;
          if (tokenStream.match(Tokens.DOT)) {
            tokenStream.mustMatch(Tokens.IDENT);
            token = tokenStream.token();
            return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
          } else {
            return null;
          }
        },
        _element_name: function() {
          var tokenStream = this._tokenStream, token;
          if (tokenStream.match(Tokens.IDENT)) {
            token = tokenStream.token();
            return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);
          } else {
            return null;
          }
        },
        _namespace_prefix: function() {
          var tokenStream = this._tokenStream, value = "";
          if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {
            if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
              value += tokenStream.token().value;
            }
            tokenStream.mustMatch(Tokens.PIPE);
            value += "|";
          }
          return value.length ? value : null;
        },
        _universal: function() {
          var tokenStream = this._tokenStream, value = "", ns;
          ns = this._namespace_prefix();
          if (ns) {
            value += ns;
          }
          if (tokenStream.match(Tokens.STAR)) {
            value += "*";
          }
          return value.length ? value : null;
        },
        _attrib: function() {
          var tokenStream = this._tokenStream, value = null, ns, token;
          if (tokenStream.match(Tokens.LBRACKET)) {
            token = tokenStream.token();
            value = token.value;
            value += this._readWhitespace();
            ns = this._namespace_prefix();
            if (ns) {
              value += ns;
            }
            tokenStream.mustMatch(Tokens.IDENT);
            value += tokenStream.token().value;
            value += this._readWhitespace();
            if (tokenStream.match([
              Tokens.PREFIXMATCH,
              Tokens.SUFFIXMATCH,
              Tokens.SUBSTRINGMATCH,
              Tokens.EQUALS,
              Tokens.INCLUDES,
              Tokens.DASHMATCH
            ])) {
              value += tokenStream.token().value;
              value += this._readWhitespace();
              tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
              value += tokenStream.token().value;
              value += this._readWhitespace();
            }
            tokenStream.mustMatch(Tokens.RBRACKET);
            return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
          } else {
            return null;
          }
        },
        _pseudo: function() {
          var tokenStream = this._tokenStream, pseudo = null, colons = ":", line, col;
          if (tokenStream.match(Tokens.COLON)) {
            if (tokenStream.match(Tokens.COLON)) {
              colons += ":";
            }
            if (tokenStream.match(Tokens.IDENT)) {
              pseudo = tokenStream.token().value;
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol - colons.length;
            } else if (tokenStream.peek() === Tokens.FUNCTION) {
              line = tokenStream.LT(1).startLine;
              col = tokenStream.LT(1).startCol - colons.length;
              pseudo = this._functional_pseudo();
            }
            if (pseudo) {
              pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
            }
          }
          return pseudo;
        },
        _functional_pseudo: function() {
          var tokenStream = this._tokenStream, value = null;
          if (tokenStream.match(Tokens.FUNCTION)) {
            value = tokenStream.token().value;
            value += this._readWhitespace();
            value += this._expression();
            tokenStream.mustMatch(Tokens.RPAREN);
            value += ")";
          }
          return value;
        },
        _expression: function() {
          var tokenStream = this._tokenStream, value = "";
          while (tokenStream.match([
            Tokens.PLUS,
            Tokens.MINUS,
            Tokens.DIMENSION,
            Tokens.NUMBER,
            Tokens.STRING,
            Tokens.IDENT,
            Tokens.LENGTH,
            Tokens.FREQ,
            Tokens.ANGLE,
            Tokens.TIME,
            Tokens.RESOLUTION,
            Tokens.SLASH
          ])) {
            value += tokenStream.token().value;
            value += this._readWhitespace();
          }
          return value.length ? value : null;
        },
        _negation: function() {
          var tokenStream = this._tokenStream, line, col, value = "", arg, subpart = null;
          if (tokenStream.match(Tokens.NOT)) {
            value = tokenStream.token().value;
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            value += this._readWhitespace();
            arg = this._negation_arg();
            value += arg;
            value += this._readWhitespace();
            tokenStream.match(Tokens.RPAREN);
            value += tokenStream.token().value;
            subpart = new SelectorSubPart(value, "not", line, col);
            subpart.args.push(arg);
          }
          return subpart;
        },
        _negation_arg: function() {
          var tokenStream = this._tokenStream, args = [
            this._type_selector,
            this._universal,
            function() {
              return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
            },
            this._class,
            this._attrib,
            this._pseudo
          ], arg = null, i = 0, len = args.length, line, col, part;
          line = tokenStream.LT(1).startLine;
          col = tokenStream.LT(1).startCol;
          while (i < len && arg === null) {
            arg = args[i].call(this);
            i++;
          }
          if (arg === null) {
            this._unexpectedToken(tokenStream.LT(1));
          }
          if (arg.type === "elementName") {
            part = new SelectorPart(arg, [], arg.toString(), line, col);
          } else {
            part = new SelectorPart(null, [arg], arg.toString(), line, col);
          }
          return part;
        },
        _declaration: function() {
          var tokenStream = this._tokenStream, property = null, expr = null, prio = null, invalid = null, propertyName = "";
          property = this._property();
          if (property !== null) {
            tokenStream.mustMatch(Tokens.COLON);
            this._readWhitespace();
            expr = this._expr();
            if (!expr || expr.length === 0) {
              this._unexpectedToken(tokenStream.LT(1));
            }
            prio = this._prio();
            propertyName = property.toString();
            if (this.options.starHack && property.hack === "*" || this.options.underscoreHack && property.hack === "_") {
              propertyName = property.text;
            }
            try {
              this._validateProperty(propertyName, expr);
            } catch (ex) {
              invalid = ex;
            }
            this.fire({
              type: "property",
              property,
              value: expr,
              important: prio,
              line: property.line,
              col: property.col,
              invalid
            });
            return true;
          } else {
            return false;
          }
        },
        _prio: function() {
          var tokenStream = this._tokenStream, result = tokenStream.match(Tokens.IMPORTANT_SYM);
          this._readWhitespace();
          return result;
        },
        _expr: function(inFunction) {
          var values = [], value = null, operator = null;
          value = this._term(inFunction);
          if (value !== null) {
            values.push(value);
            do {
              operator = this._operator(inFunction);
              if (operator) {
                values.push(operator);
              }
              value = this._term(inFunction);
              if (value === null) {
                break;
              } else {
                values.push(value);
              }
            } while (true);
          }
          return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
        },
        _term: function(inFunction) {
          var tokenStream = this._tokenStream, unary = null, value = null, endChar = null, token, line, col;
          unary = this._unary_operator();
          if (unary !== null) {
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
          }
          if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {
            value = this._ie_function();
            if (unary === null) {
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol;
            }
          } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {
            token = tokenStream.token();
            endChar = token.endChar;
            value = token.value + this._expr(inFunction).text;
            if (unary === null) {
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol;
            }
            tokenStream.mustMatch(Tokens.type(endChar));
            value += endChar;
            this._readWhitespace();
          } else if (tokenStream.match([
            Tokens.NUMBER,
            Tokens.PERCENTAGE,
            Tokens.LENGTH,
            Tokens.ANGLE,
            Tokens.TIME,
            Tokens.FREQ,
            Tokens.STRING,
            Tokens.IDENT,
            Tokens.URI,
            Tokens.UNICODE_RANGE
          ])) {
            value = tokenStream.token().value;
            if (unary === null) {
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol;
            }
            this._readWhitespace();
          } else {
            token = this._hexcolor();
            if (token === null) {
              if (unary === null) {
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;
              }
              if (value === null) {
                if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {
                  value = this._ie_function();
                } else {
                  value = this._function();
                }
              }
            } else {
              value = token.value;
              if (unary === null) {
                line = token.startLine;
                col = token.startCol;
              }
            }
          }
          return value !== null ? new PropertyValuePart(unary !== null ? unary + value : value, line, col) : null;
        },
        _function: function() {
          var tokenStream = this._tokenStream, functionText = null, expr = null, lt;
          if (tokenStream.match(Tokens.FUNCTION)) {
            functionText = tokenStream.token().value;
            this._readWhitespace();
            expr = this._expr(true);
            functionText += expr;
            if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {
              do {
                if (this._readWhitespace()) {
                  functionText += tokenStream.token().value;
                }
                if (tokenStream.LA(0) === Tokens.COMMA) {
                  functionText += tokenStream.token().value;
                }
                tokenStream.match(Tokens.IDENT);
                functionText += tokenStream.token().value;
                tokenStream.match(Tokens.EQUALS);
                functionText += tokenStream.token().value;
                lt = tokenStream.peek();
                while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                  tokenStream.get();
                  functionText += tokenStream.token().value;
                  lt = tokenStream.peek();
                }
              } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
            }
            tokenStream.match(Tokens.RPAREN);
            functionText += ")";
            this._readWhitespace();
          }
          return functionText;
        },
        _ie_function: function() {
          var tokenStream = this._tokenStream, functionText = null, lt;
          if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {
            functionText = tokenStream.token().value;
            do {
              if (this._readWhitespace()) {
                functionText += tokenStream.token().value;
              }
              if (tokenStream.LA(0) === Tokens.COMMA) {
                functionText += tokenStream.token().value;
              }
              tokenStream.match(Tokens.IDENT);
              functionText += tokenStream.token().value;
              tokenStream.match(Tokens.EQUALS);
              functionText += tokenStream.token().value;
              lt = tokenStream.peek();
              while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                tokenStream.get();
                functionText += tokenStream.token().value;
                lt = tokenStream.peek();
              }
            } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
            tokenStream.match(Tokens.RPAREN);
            functionText += ")";
            this._readWhitespace();
          }
          return functionText;
        },
        _hexcolor: function() {
          var tokenStream = this._tokenStream, token = null, color;
          if (tokenStream.match(Tokens.HASH)) {
            token = tokenStream.token();
            color = token.value;
            if (!/#[a-f0-9]{3,6}/i.test(color)) {
              throw new SyntaxError2("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            }
            this._readWhitespace();
          }
          return token;
        },
        _keyframes: function() {
          var tokenStream = this._tokenStream, token, tt, name, prefix = "";
          tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
          token = tokenStream.token();
          if (/^@\-([^\-]+)\-/.test(token.value)) {
            prefix = RegExp.$1;
          }
          this._readWhitespace();
          name = this._keyframe_name();
          this._readWhitespace();
          tokenStream.mustMatch(Tokens.LBRACE);
          this.fire({
            type: "startkeyframes",
            name,
            prefix,
            line: token.startLine,
            col: token.startCol
          });
          this._readWhitespace();
          tt = tokenStream.peek();
          while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
            this._keyframe_rule();
            this._readWhitespace();
            tt = tokenStream.peek();
          }
          this.fire({
            type: "endkeyframes",
            name,
            prefix,
            line: token.startLine,
            col: token.startCol
          });
          this._readWhitespace();
          tokenStream.mustMatch(Tokens.RBRACE);
        },
        _keyframe_name: function() {
          var tokenStream = this._tokenStream;
          tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
          return SyntaxUnit.fromToken(tokenStream.token());
        },
        _keyframe_rule: function() {
          var keyList = this._key_list();
          this.fire({
            type: "startkeyframerule",
            keys: keyList,
            line: keyList[0].line,
            col: keyList[0].col
          });
          this._readDeclarations(true);
          this.fire({
            type: "endkeyframerule",
            keys: keyList,
            line: keyList[0].line,
            col: keyList[0].col
          });
        },
        _key_list: function() {
          var tokenStream = this._tokenStream, keyList = [];
          keyList.push(this._key());
          this._readWhitespace();
          while (tokenStream.match(Tokens.COMMA)) {
            this._readWhitespace();
            keyList.push(this._key());
            this._readWhitespace();
          }
          return keyList;
        },
        _key: function() {
          var tokenStream = this._tokenStream, token;
          if (tokenStream.match(Tokens.PERCENTAGE)) {
            return SyntaxUnit.fromToken(tokenStream.token());
          } else if (tokenStream.match(Tokens.IDENT)) {
            token = tokenStream.token();
            if (/from|to/i.test(token.value)) {
              return SyntaxUnit.fromToken(token);
            }
            tokenStream.unget();
          }
          this._unexpectedToken(tokenStream.LT(1));
        },
        _skipCruft: function() {
          while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {
          }
        },
        _readDeclarations: function(checkStart, readMargins) {
          var tokenStream = this._tokenStream, tt;
          this._readWhitespace();
          if (checkStart) {
            tokenStream.mustMatch(Tokens.LBRACE);
          }
          this._readWhitespace();
          try {
            while (true) {
              if (tokenStream.match(Tokens.SEMICOLON) || readMargins && this._margin()) {
              } else if (this._declaration()) {
                if (!tokenStream.match(Tokens.SEMICOLON)) {
                  break;
                }
              } else {
                break;
              }
              this._readWhitespace();
            }
            tokenStream.mustMatch(Tokens.RBRACE);
            this._readWhitespace();
          } catch (ex) {
            if (ex instanceof SyntaxError2 && !this.options.strict) {
              this.fire({
                type: "error",
                error: ex,
                message: ex.message,
                line: ex.line,
                col: ex.col
              });
              tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
              if (tt === Tokens.SEMICOLON) {
                this._readDeclarations(false, readMargins);
              } else if (tt !== Tokens.RBRACE) {
                throw ex;
              }
            } else {
              throw ex;
            }
          }
        },
        _readWhitespace: function() {
          var tokenStream = this._tokenStream, ws = "";
          while (tokenStream.match(Tokens.S)) {
            ws += tokenStream.token().value;
          }
          return ws;
        },
        _unexpectedToken: function(token) {
          throw new SyntaxError2("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        },
        _verifyEnd: function() {
          if (this._tokenStream.LA(1) !== Tokens.EOF) {
            this._unexpectedToken(this._tokenStream.LT(1));
          }
        },
        _validateProperty: function(property, value) {
          Validation.validate(property, value);
        },
        parse: function(input) {
          this._tokenStream = new TokenStream(input, Tokens);
          this._stylesheet();
        },
        parseStyleSheet: function(input) {
          return this.parse(input);
        },
        parseMediaQuery: function(input) {
          this._tokenStream = new TokenStream(input, Tokens);
          var result = this._media_query();
          this._verifyEnd();
          return result;
        },
        parsePropertyValue: function(input) {
          this._tokenStream = new TokenStream(input, Tokens);
          this._readWhitespace();
          var result = this._expr();
          this._readWhitespace();
          this._verifyEnd();
          return result;
        },
        parseRule: function(input) {
          this._tokenStream = new TokenStream(input, Tokens);
          this._readWhitespace();
          var result = this._ruleset();
          this._readWhitespace();
          this._verifyEnd();
          return result;
        },
        parseSelector: function(input) {
          this._tokenStream = new TokenStream(input, Tokens);
          this._readWhitespace();
          var result = this._selector();
          this._readWhitespace();
          this._verifyEnd();
          return result;
        },
        parseStyleAttribute: function(input) {
          input += "}";
          this._tokenStream = new TokenStream(input, Tokens);
          this._readDeclarations();
        }
      };
      for (prop in additions) {
        if (Object.prototype.hasOwnProperty.call(additions, prop)) {
          proto[prop] = additions[prop];
        }
      }
      return proto;
    }();
    var Properties = {
      __proto__: null,
      "align-items": "flex-start | flex-end | center | baseline | stretch",
      "align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
      "align-self": "auto | flex-start | flex-end | center | baseline | stretch",
      "-webkit-align-items": "flex-start | flex-end | center | baseline | stretch",
      "-webkit-align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
      "-webkit-align-self": "auto | flex-start | flex-end | center | baseline | stretch",
      "alignment-adjust": "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
      "alignment-baseline": "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
      animation: 1,
      "animation-delay": {multi: "<time>", comma: true},
      "animation-direction": {multi: "normal | alternate", comma: true},
      "animation-duration": {multi: "<time>", comma: true},
      "animation-fill-mode": {multi: "none | forwards | backwards | both", comma: true},
      "animation-iteration-count": {multi: "<number> | infinite", comma: true},
      "animation-name": {multi: "none | <ident>", comma: true},
      "animation-play-state": {multi: "running | paused", comma: true},
      "animation-timing-function": 1,
      "-moz-animation-delay": {multi: "<time>", comma: true},
      "-moz-animation-direction": {multi: "normal | alternate", comma: true},
      "-moz-animation-duration": {multi: "<time>", comma: true},
      "-moz-animation-iteration-count": {multi: "<number> | infinite", comma: true},
      "-moz-animation-name": {multi: "none | <ident>", comma: true},
      "-moz-animation-play-state": {multi: "running | paused", comma: true},
      "-ms-animation-delay": {multi: "<time>", comma: true},
      "-ms-animation-direction": {multi: "normal | alternate", comma: true},
      "-ms-animation-duration": {multi: "<time>", comma: true},
      "-ms-animation-iteration-count": {multi: "<number> | infinite", comma: true},
      "-ms-animation-name": {multi: "none | <ident>", comma: true},
      "-ms-animation-play-state": {multi: "running | paused", comma: true},
      "-webkit-animation-delay": {multi: "<time>", comma: true},
      "-webkit-animation-direction": {multi: "normal | alternate", comma: true},
      "-webkit-animation-duration": {multi: "<time>", comma: true},
      "-webkit-animation-fill-mode": {multi: "none | forwards | backwards | both", comma: true},
      "-webkit-animation-iteration-count": {multi: "<number> | infinite", comma: true},
      "-webkit-animation-name": {multi: "none | <ident>", comma: true},
      "-webkit-animation-play-state": {multi: "running | paused", comma: true},
      "-o-animation-delay": {multi: "<time>", comma: true},
      "-o-animation-direction": {multi: "normal | alternate", comma: true},
      "-o-animation-duration": {multi: "<time>", comma: true},
      "-o-animation-iteration-count": {multi: "<number> | infinite", comma: true},
      "-o-animation-name": {multi: "none | <ident>", comma: true},
      "-o-animation-play-state": {multi: "running | paused", comma: true},
      appearance: "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
      azimuth: function(expression) {
        var simple = "<angle> | leftwards | rightwards | inherit", direction = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side", behind = false, valid = false, part;
        if (!ValidationTypes.isAny(expression, simple)) {
          if (ValidationTypes.isAny(expression, "behind")) {
            behind = true;
            valid = true;
          }
          if (ValidationTypes.isAny(expression, direction)) {
            valid = true;
            if (!behind) {
              ValidationTypes.isAny(expression, "behind");
            }
          }
        }
        if (expression.hasNext()) {
          part = expression.next();
          if (valid) {
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          } else {
            throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
          }
        }
      },
      "backface-visibility": "visible | hidden",
      background: 1,
      "background-attachment": {multi: "<attachment>", comma: true},
      "background-clip": {multi: "<box>", comma: true},
      "background-color": "<color> | inherit",
      "background-image": {multi: "<bg-image>", comma: true},
      "background-origin": {multi: "<box>", comma: true},
      "background-position": {multi: "<bg-position>", comma: true},
      "background-repeat": {multi: "<repeat-style>"},
      "background-size": {multi: "<bg-size>", comma: true},
      "baseline-shift": "baseline | sub | super | <percentage> | <length>",
      behavior: 1,
      binding: 1,
      bleed: "<length>",
      "bookmark-label": "<content> | <attr> | <string>",
      "bookmark-level": "none | <integer>",
      "bookmark-state": "open | closed",
      "bookmark-target": "none | <uri> | <attr>",
      border: "<border-width> || <border-style> || <color>",
      "border-bottom": "<border-width> || <border-style> || <color>",
      "border-bottom-color": "<color> | inherit",
      "border-bottom-left-radius": "<x-one-radius>",
      "border-bottom-right-radius": "<x-one-radius>",
      "border-bottom-style": "<border-style>",
      "border-bottom-width": "<border-width>",
      "border-collapse": "collapse | separate | inherit",
      "border-color": {multi: "<color> | inherit", max: 4},
      "border-image": 1,
      "border-image-outset": {multi: "<length> | <number>", max: 4},
      "border-image-repeat": {multi: "stretch | repeat | round", max: 2},
      "border-image-slice": function(expression) {
        var valid = false, numeric = "<number> | <percentage>", fill = false, count = 0, max = 4, part;
        if (ValidationTypes.isAny(expression, "fill")) {
          fill = true;
          valid = true;
        }
        while (expression.hasNext() && count < max) {
          valid = ValidationTypes.isAny(expression, numeric);
          if (!valid) {
            break;
          }
          count++;
        }
        if (!fill) {
          ValidationTypes.isAny(expression, "fill");
        } else {
          valid = true;
        }
        if (expression.hasNext()) {
          part = expression.next();
          if (valid) {
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          } else {
            throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
          }
        }
      },
      "border-image-source": "<image> | none",
      "border-image-width": {multi: "<length> | <percentage> | <number> | auto", max: 4},
      "border-left": "<border-width> || <border-style> || <color>",
      "border-left-color": "<color> | inherit",
      "border-left-style": "<border-style>",
      "border-left-width": "<border-width>",
      "border-radius": function(expression) {
        var valid = false, simple = "<length> | <percentage> | inherit", slash = false, count = 0, max = 8, part;
        while (expression.hasNext() && count < max) {
          valid = ValidationTypes.isAny(expression, simple);
          if (!valid) {
            if (String(expression.peek()) === "/" && count > 0 && !slash) {
              slash = true;
              max = count + 5;
              expression.next();
            } else {
              break;
            }
          }
          count++;
        }
        if (expression.hasNext()) {
          part = expression.next();
          if (valid) {
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          } else {
            throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
          }
        }
      },
      "border-right": "<border-width> || <border-style> || <color>",
      "border-right-color": "<color> | inherit",
      "border-right-style": "<border-style>",
      "border-right-width": "<border-width>",
      "border-spacing": {multi: "<length> | inherit", max: 2},
      "border-style": {multi: "<border-style>", max: 4},
      "border-top": "<border-width> || <border-style> || <color>",
      "border-top-color": "<color> | inherit",
      "border-top-left-radius": "<x-one-radius>",
      "border-top-right-radius": "<x-one-radius>",
      "border-top-style": "<border-style>",
      "border-top-width": "<border-width>",
      "border-width": {multi: "<border-width>", max: 4},
      bottom: "<margin-width> | inherit",
      "-moz-box-align": "start | end | center | baseline | stretch",
      "-moz-box-decoration-break": "slice |clone",
      "-moz-box-direction": "normal | reverse | inherit",
      "-moz-box-flex": "<number>",
      "-moz-box-flex-group": "<integer>",
      "-moz-box-lines": "single | multiple",
      "-moz-box-ordinal-group": "<integer>",
      "-moz-box-orient": "horizontal | vertical | inline-axis | block-axis | inherit",
      "-moz-box-pack": "start | end | center | justify",
      "-o-box-decoration-break": "slice | clone",
      "-webkit-box-align": "start | end | center | baseline | stretch",
      "-webkit-box-decoration-break": "slice |clone",
      "-webkit-box-direction": "normal | reverse | inherit",
      "-webkit-box-flex": "<number>",
      "-webkit-box-flex-group": "<integer>",
      "-webkit-box-lines": "single | multiple",
      "-webkit-box-ordinal-group": "<integer>",
      "-webkit-box-orient": "horizontal | vertical | inline-axis | block-axis | inherit",
      "-webkit-box-pack": "start | end | center | justify",
      "box-decoration-break": "slice | clone",
      "box-shadow": function(expression) {
        var part;
        if (!ValidationTypes.isAny(expression, "none")) {
          Validation.multiProperty("<shadow>", expression, true, Infinity);
        } else {
          if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          }
        }
      },
      "box-sizing": "content-box | border-box | inherit",
      "break-after": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
      "break-before": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
      "break-inside": "auto | avoid | avoid-page | avoid-column",
      "caption-side": "top | bottom | inherit",
      clear: "none | right | left | both | inherit",
      clip: 1,
      color: "<color> | inherit",
      "color-profile": 1,
      "column-count": "<integer> | auto",
      "column-fill": "auto | balance",
      "column-gap": "<length> | normal",
      "column-rule": "<border-width> || <border-style> || <color>",
      "column-rule-color": "<color>",
      "column-rule-style": "<border-style>",
      "column-rule-width": "<border-width>",
      "column-span": "none | all",
      "column-width": "<length> | auto",
      columns: 1,
      content: 1,
      "counter-increment": 1,
      "counter-reset": 1,
      crop: "<shape> | auto",
      cue: "cue-after | cue-before | inherit",
      "cue-after": 1,
      "cue-before": 1,
      cursor: 1,
      direction: "ltr | rtl | inherit",
      display: "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
      "dominant-baseline": 1,
      "drop-initial-after-adjust": "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
      "drop-initial-after-align": "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
      "drop-initial-before-adjust": "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
      "drop-initial-before-align": "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
      "drop-initial-size": "auto | line | <length> | <percentage>",
      "drop-initial-value": "initial | <integer>",
      elevation: "<angle> | below | level | above | higher | lower | inherit",
      "empty-cells": "show | hide | inherit",
      filter: 1,
      fit: "fill | hidden | meet | slice",
      "fit-position": 1,
      flex: "<flex>",
      "flex-basis": "<width>",
      "flex-direction": "row | row-reverse | column | column-reverse",
      "flex-flow": "<flex-direction> || <flex-wrap>",
      "flex-grow": "<number>",
      "flex-shrink": "<number>",
      "flex-wrap": "nowrap | wrap | wrap-reverse",
      "-webkit-flex": "<flex>",
      "-webkit-flex-basis": "<width>",
      "-webkit-flex-direction": "row | row-reverse | column | column-reverse",
      "-webkit-flex-flow": "<flex-direction> || <flex-wrap>",
      "-webkit-flex-grow": "<number>",
      "-webkit-flex-shrink": "<number>",
      "-webkit-flex-wrap": "nowrap | wrap | wrap-reverse",
      "-ms-flex": "<flex>",
      "-ms-flex-align": "start | end | center | stretch | baseline",
      "-ms-flex-direction": "row | row-reverse | column | column-reverse | inherit",
      "-ms-flex-order": "<number>",
      "-ms-flex-pack": "start | end | center | justify",
      "-ms-flex-wrap": "nowrap | wrap | wrap-reverse",
      float: "left | right | none | inherit",
      "float-offset": 1,
      font: 1,
      "font-family": 1,
      "font-feature-settings": "<feature-tag-value> | normal | inherit",
      "font-kerning": "auto | normal | none | initial | inherit | unset",
      "font-size": "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
      "font-size-adjust": "<number> | none | inherit",
      "font-stretch": "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
      "font-style": "normal | italic | oblique | inherit",
      "font-variant": "normal | small-caps | inherit",
      "font-variant-caps": "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
      "font-variant-position": "normal | sub | super | inherit | initial | unset",
      "font-weight": "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",
      grid: 1,
      "grid-area": 1,
      "grid-auto-columns": 1,
      "grid-auto-flow": 1,
      "grid-auto-position": 1,
      "grid-auto-rows": 1,
      "grid-cell-stacking": "columns | rows | layer",
      "grid-column": 1,
      "grid-columns": 1,
      "grid-column-align": "start | end | center | stretch",
      "grid-column-sizing": 1,
      "grid-column-start": 1,
      "grid-column-end": 1,
      "grid-column-span": "<integer>",
      "grid-flow": "none | rows | columns",
      "grid-layer": "<integer>",
      "grid-row": 1,
      "grid-rows": 1,
      "grid-row-align": "start | end | center | stretch",
      "grid-row-start": 1,
      "grid-row-end": 1,
      "grid-row-span": "<integer>",
      "grid-row-sizing": 1,
      "grid-template": 1,
      "grid-template-areas": 1,
      "grid-template-columns": 1,
      "grid-template-rows": 1,
      "hanging-punctuation": 1,
      height: "<margin-width> | <content-sizing> | inherit",
      "hyphenate-after": "<integer> | auto",
      "hyphenate-before": "<integer> | auto",
      "hyphenate-character": "<string> | auto",
      "hyphenate-lines": "no-limit | <integer>",
      "hyphenate-resource": 1,
      hyphens: "none | manual | auto",
      icon: 1,
      "image-orientation": "angle | auto",
      "image-rendering": 1,
      "image-resolution": 1,
      "ime-mode": "auto | normal | active | inactive | disabled | inherit",
      "inline-box-align": "initial | last | <integer>",
      "justify-content": "flex-start | flex-end | center | space-between | space-around",
      "-webkit-justify-content": "flex-start | flex-end | center | space-between | space-around",
      left: "<margin-width> | inherit",
      "letter-spacing": "<length> | normal | inherit",
      "line-height": "<number> | <length> | <percentage> | normal | inherit",
      "line-break": "auto | loose | normal | strict",
      "line-stacking": 1,
      "line-stacking-ruby": "exclude-ruby | include-ruby",
      "line-stacking-shift": "consider-shifts | disregard-shifts",
      "line-stacking-strategy": "inline-line-height | block-line-height | max-height | grid-height",
      "list-style": 1,
      "list-style-image": "<uri> | none | inherit",
      "list-style-position": "inside | outside | inherit",
      "list-style-type": "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",
      margin: {multi: "<margin-width> | inherit", max: 4},
      "margin-bottom": "<margin-width> | inherit",
      "margin-left": "<margin-width> | inherit",
      "margin-right": "<margin-width> | inherit",
      "margin-top": "<margin-width> | inherit",
      mark: 1,
      "mark-after": 1,
      "mark-before": 1,
      marks: 1,
      "marquee-direction": 1,
      "marquee-play-count": 1,
      "marquee-speed": 1,
      "marquee-style": 1,
      "max-height": "<length> | <percentage> | <content-sizing> | none | inherit",
      "max-width": "<length> | <percentage> | <content-sizing> | none | inherit",
      "min-height": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
      "min-width": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
      "move-to": 1,
      "nav-down": 1,
      "nav-index": 1,
      "nav-left": 1,
      "nav-right": 1,
      "nav-up": 1,
      "object-fit": "fill | contain | cover | none | scale-down",
      "object-position": "<bg-position>",
      opacity: "<number> | inherit",
      order: "<integer>",
      "-webkit-order": "<integer>",
      orphans: "<integer> | inherit",
      outline: 1,
      "outline-color": "<color> | invert | inherit",
      "outline-offset": 1,
      "outline-style": "<border-style> | inherit",
      "outline-width": "<border-width> | inherit",
      overflow: "visible | hidden | scroll | auto | inherit",
      "overflow-style": 1,
      "overflow-wrap": "normal | break-word",
      "overflow-x": 1,
      "overflow-y": 1,
      padding: {multi: "<padding-width> | inherit", max: 4},
      "padding-bottom": "<padding-width> | inherit",
      "padding-left": "<padding-width> | inherit",
      "padding-right": "<padding-width> | inherit",
      "padding-top": "<padding-width> | inherit",
      page: 1,
      "page-break-after": "auto | always | avoid | left | right | inherit",
      "page-break-before": "auto | always | avoid | left | right | inherit",
      "page-break-inside": "auto | avoid | inherit",
      "page-policy": 1,
      pause: 1,
      "pause-after": 1,
      "pause-before": 1,
      perspective: 1,
      "perspective-origin": 1,
      phonemes: 1,
      pitch: 1,
      "pitch-range": 1,
      "play-during": 1,
      "pointer-events": "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
      position: "static | relative | absolute | fixed | inherit",
      "presentation-level": 1,
      "punctuation-trim": 1,
      quotes: 1,
      "rendering-intent": 1,
      resize: 1,
      rest: 1,
      "rest-after": 1,
      "rest-before": 1,
      richness: 1,
      right: "<margin-width> | inherit",
      rotation: 1,
      "rotation-point": 1,
      "ruby-align": 1,
      "ruby-overhang": 1,
      "ruby-position": 1,
      "ruby-span": 1,
      size: 1,
      speak: "normal | none | spell-out | inherit",
      "speak-header": "once | always | inherit",
      "speak-numeral": "digits | continuous | inherit",
      "speak-punctuation": "code | none | inherit",
      "speech-rate": 1,
      src: 1,
      stress: 1,
      "string-set": 1,
      "table-layout": "auto | fixed | inherit",
      "tab-size": "<integer> | <length>",
      target: 1,
      "target-name": 1,
      "target-new": 1,
      "target-position": 1,
      "text-align": "left | right | center | justify | match-parent | start | end | inherit",
      "text-align-last": 1,
      "text-decoration": 1,
      "text-emphasis": 1,
      "text-height": 1,
      "text-indent": "<length> | <percentage> | inherit",
      "text-justify": "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
      "text-outline": 1,
      "text-overflow": 1,
      "text-rendering": "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
      "text-shadow": 1,
      "text-transform": "capitalize | uppercase | lowercase | none | inherit",
      "text-wrap": "normal | none | avoid",
      top: "<margin-width> | inherit",
      "-ms-touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
      "touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
      transform: 1,
      "transform-origin": 1,
      "transform-style": 1,
      transition: 1,
      "transition-delay": 1,
      "transition-duration": 1,
      "transition-property": 1,
      "transition-timing-function": 1,
      "unicode-bidi": "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
      "user-modify": "read-only | read-write | write-only | inherit",
      "user-select": "none | text | toggle | element | elements | all | inherit",
      "vertical-align": "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length> | inherit",
      visibility: "visible | hidden | collapse | inherit",
      "voice-balance": 1,
      "voice-duration": 1,
      "voice-family": 1,
      "voice-pitch": 1,
      "voice-pitch-range": 1,
      "voice-rate": 1,
      "voice-stress": 1,
      "voice-volume": 1,
      volume: 1,
      "white-space": "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap",
      "white-space-collapse": 1,
      widows: "<integer> | inherit",
      width: "<length> | <percentage> | <content-sizing> | auto | inherit",
      "will-change": {multi: "<ident>", comma: true},
      "word-break": "normal | keep-all | break-all",
      "word-spacing": "<length> | normal | inherit",
      "word-wrap": "normal | break-word",
      "writing-mode": "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",
      "z-index": "<integer> | auto | inherit",
      zoom: "<number> | <percentage> | normal"
    };
    function PropertyName(text, hack, line, col) {
      SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);
      this.hack = hack;
    }
    PropertyName.prototype = new SyntaxUnit();
    PropertyName.prototype.constructor = PropertyName;
    PropertyName.prototype.toString = function() {
      return (this.hack ? this.hack : "") + this.text;
    };
    function PropertyValue(parts, line, col) {
      SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);
      this.parts = parts;
    }
    PropertyValue.prototype = new SyntaxUnit();
    PropertyValue.prototype.constructor = PropertyValue;
    function PropertyValueIterator(value) {
      this._i = 0;
      this._parts = value.parts;
      this._marks = [];
      this.value = value;
    }
    PropertyValueIterator.prototype.count = function() {
      return this._parts.length;
    };
    PropertyValueIterator.prototype.isFirst = function() {
      return this._i === 0;
    };
    PropertyValueIterator.prototype.hasNext = function() {
      return this._i < this._parts.length;
    };
    PropertyValueIterator.prototype.mark = function() {
      this._marks.push(this._i);
    };
    PropertyValueIterator.prototype.peek = function(count) {
      return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
    };
    PropertyValueIterator.prototype.next = function() {
      return this.hasNext() ? this._parts[this._i++] : null;
    };
    PropertyValueIterator.prototype.previous = function() {
      return this._i > 0 ? this._parts[--this._i] : null;
    };
    PropertyValueIterator.prototype.restore = function() {
      if (this._marks.length) {
        this._i = this._marks.pop();
      }
    };
    function PropertyValuePart(text, line, col) {
      SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);
      this.type = "unknown";
      var temp;
      if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;
        switch (this.units.toLowerCase()) {
          case "em":
          case "rem":
          case "ex":
          case "px":
          case "cm":
          case "mm":
          case "in":
          case "pt":
          case "pc":
          case "ch":
          case "vh":
          case "vw":
          case "vmax":
          case "vmin":
            this.type = "length";
            break;
          case "fr":
            this.type = "grid";
            break;
          case "deg":
          case "rad":
          case "grad":
            this.type = "angle";
            break;
          case "ms":
          case "s":
            this.type = "time";
            break;
          case "hz":
          case "khz":
            this.type = "frequency";
            break;
          case "dpi":
          case "dpcm":
            this.type = "resolution";
            break;
        }
      } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {
        this.type = "percentage";
        this.value = +RegExp.$1;
      } else if (/^([+\-]?\d+)$/i.test(text)) {
        this.type = "integer";
        this.value = +RegExp.$1;
      } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {
        this.type = "number";
        this.value = +RegExp.$1;
      } else if (/^#([a-f0-9]{3,6})/i.test(text)) {
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length === 3) {
          this.red = parseInt(temp.charAt(0) + temp.charAt(0), 16);
          this.green = parseInt(temp.charAt(1) + temp.charAt(1), 16);
          this.blue = parseInt(temp.charAt(2) + temp.charAt(2), 16);
        } else {
          this.red = parseInt(temp.substring(0, 2), 16);
          this.green = parseInt(temp.substring(2, 4), 16);
          this.blue = parseInt(temp.substring(4, 6), 16);
        }
      } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) {
        this.type = "color";
        this.red = +RegExp.$1;
        this.green = +RegExp.$2;
        this.blue = +RegExp.$3;
      } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
        this.type = "color";
        this.red = +RegExp.$1 * 255 / 100;
        this.green = +RegExp.$2 * 255 / 100;
        this.blue = +RegExp.$3 * 255 / 100;
      } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
        this.type = "color";
        this.red = +RegExp.$1;
        this.green = +RegExp.$2;
        this.blue = +RegExp.$3;
        this.alpha = +RegExp.$4;
      } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
        this.type = "color";
        this.red = +RegExp.$1 * 255 / 100;
        this.green = +RegExp.$2 * 255 / 100;
        this.blue = +RegExp.$3 * 255 / 100;
        this.alpha = +RegExp.$4;
      } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
        this.type = "color";
        this.hue = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness = +RegExp.$3 / 100;
      } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
        this.type = "color";
        this.hue = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness = +RegExp.$3 / 100;
        this.alpha = +RegExp.$4;
      } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)) {
        this.type = "uri";
        this.uri = RegExp.$1;
      } else if (/^([^\(]+)\(/i.test(text)) {
        this.type = "function";
        this.name = RegExp.$1;
        this.value = text;
      } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)) {
        this.type = "string";
        this.value = PropertyValuePart.parseString(text);
      } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)) {
        this.type = "string";
        this.value = PropertyValuePart.parseString(text);
      } else if (Colors[text.toLowerCase()]) {
        this.type = "color";
        temp = Colors[text.toLowerCase()].substring(1);
        this.red = parseInt(temp.substring(0, 2), 16);
        this.green = parseInt(temp.substring(2, 4), 16);
        this.blue = parseInt(temp.substring(4, 6), 16);
      } else if (/^[\,\/]$/.test(text)) {
        this.type = "operator";
        this.value = text;
      } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)) {
        this.type = "identifier";
        this.value = text;
      }
    }
    PropertyValuePart.prototype = new SyntaxUnit();
    PropertyValuePart.prototype.constructor = PropertyValuePart;
    PropertyValuePart.parseString = function(str) {
      str = str.slice(1, -1);
      var replacer = function(match, esc) {
        if (/^(\n|\r\n|\r|\f)$/.test(esc)) {
          return "";
        }
        var m = /^[0-9a-f]{1,6}/i.exec(esc);
        if (m) {
          var codePoint = parseInt(m[0], 16);
          if (String.fromCodePoint) {
            return String.fromCodePoint(codePoint);
          } else {
            return String.fromCharCode(codePoint);
          }
        }
        return esc;
      };
      return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig, replacer);
    };
    PropertyValuePart.serializeString = function(value) {
      var replacer = function(match, c) {
        if (c === '"') {
          return "\\" + c;
        }
        var cp = String.codePointAt ? String.codePointAt(0) : String.charCodeAt(0);
        return "\\" + cp.toString(16) + " ";
      };
      return '"' + value.replace(/["\r\n\f]/g, replacer) + '"';
    };
    PropertyValuePart.fromToken = function(token) {
      return new PropertyValuePart(token.value, token.startLine, token.startCol);
    };
    var Pseudos = {
      __proto__: null,
      ":first-letter": 1,
      ":first-line": 1,
      ":before": 1,
      ":after": 1
    };
    Pseudos.ELEMENT = 1;
    Pseudos.CLASS = 2;
    Pseudos.isElement = function(pseudo) {
      return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
    };
    function Selector(parts, line, col) {
      SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);
      this.parts = parts;
      this.specificity = Specificity.calculate(this);
    }
    Selector.prototype = new SyntaxUnit();
    Selector.prototype.constructor = Selector;
    function SelectorPart(elementName, modifiers, text, line, col) {
      SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);
      this.elementName = elementName;
      this.modifiers = modifiers;
    }
    SelectorPart.prototype = new SyntaxUnit();
    SelectorPart.prototype.constructor = SelectorPart;
    function SelectorSubPart(text, type, line, col) {
      SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);
      this.type = type;
      this.args = [];
    }
    SelectorSubPart.prototype = new SyntaxUnit();
    SelectorSubPart.prototype.constructor = SelectorSubPart;
    function Specificity(a, b, c, d) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
    }
    Specificity.prototype = {
      constructor: Specificity,
      compare: function(other) {
        var comps = ["a", "b", "c", "d"], i, len;
        for (i = 0, len = comps.length; i < len; i++) {
          if (this[comps[i]] < other[comps[i]]) {
            return -1;
          } else if (this[comps[i]] > other[comps[i]]) {
            return 1;
          }
        }
        return 0;
      },
      valueOf: function() {
        return this.a * 1e3 + this.b * 100 + this.c * 10 + this.d;
      },
      toString: function() {
        return this.a + "," + this.b + "," + this.c + "," + this.d;
      }
    };
    Specificity.calculate = function(selector) {
      var i, len, part, b = 0, c = 0, d = 0;
      function updateValues(part2) {
        var i2, j, len2, num, elementName = part2.elementName ? part2.elementName.text : "", modifier;
        if (elementName && elementName.charAt(elementName.length - 1) !== "*") {
          d++;
        }
        for (i2 = 0, len2 = part2.modifiers.length; i2 < len2; i2++) {
          modifier = part2.modifiers[i2];
          switch (modifier.type) {
            case "class":
            case "attribute":
              c++;
              break;
            case "id":
              b++;
              break;
            case "pseudo":
              if (Pseudos.isElement(modifier.text)) {
                d++;
              } else {
                c++;
              }
              break;
            case "not":
              for (j = 0, num = modifier.args.length; j < num; j++) {
                updateValues(modifier.args[j]);
              }
          }
        }
      }
      for (i = 0, len = selector.parts.length; i < len; i++) {
        part = selector.parts[i];
        if (part instanceof SelectorPart) {
          updateValues(part);
        }
      }
      return new Specificity(0, b, c, d);
    };
    var h = /^[0-9a-fA-F]$/, nl = /\n|\r\n|\r|\f/;
    function isHexDigit(c) {
      return c !== null && h.test(c);
    }
    function isDigit(c) {
      return c !== null && /\d/.test(c);
    }
    function isWhitespace(c) {
      return c !== null && /\s/.test(c);
    }
    function isNewLine(c) {
      return c !== null && nl.test(c);
    }
    function isNameStart(c) {
      return c !== null && /[a-z_\u0080-\uFFFF\\]/i.test(c);
    }
    function isNameChar(c) {
      return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
    }
    function isIdentStart(c) {
      return c !== null && (isNameStart(c) || /\-\\/.test(c));
    }
    function mix(receiver, supplier) {
      for (var prop in supplier) {
        if (Object.prototype.hasOwnProperty.call(supplier, prop)) {
          receiver[prop] = supplier[prop];
        }
      }
      return receiver;
    }
    function TokenStream(input) {
      TokenStreamBase.call(this, input, Tokens);
    }
    TokenStream.prototype = mix(new TokenStreamBase(), {
      _getToken: function(channel) {
        var c, reader = this._reader, token = null, startLine = reader.getLine(), startCol = reader.getCol();
        c = reader.read();
        while (c) {
          switch (c) {
            case "/":
              if (reader.peek() === "*") {
                token = this.commentToken(c, startLine, startCol);
              } else {
                token = this.charToken(c, startLine, startCol);
              }
              break;
            case "|":
            case "~":
            case "^":
            case "$":
            case "*":
              if (reader.peek() === "=") {
                token = this.comparisonToken(c, startLine, startCol);
              } else {
                token = this.charToken(c, startLine, startCol);
              }
              break;
            case '"':
            case "'":
              token = this.stringToken(c, startLine, startCol);
              break;
            case "#":
              if (isNameChar(reader.peek())) {
                token = this.hashToken(c, startLine, startCol);
              } else {
                token = this.charToken(c, startLine, startCol);
              }
              break;
            case ".":
              if (isDigit(reader.peek())) {
                token = this.numberToken(c, startLine, startCol);
              } else {
                token = this.charToken(c, startLine, startCol);
              }
              break;
            case "-":
              if (reader.peek() === "-") {
                token = this.htmlCommentEndToken(c, startLine, startCol);
              } else if (isNameStart(reader.peek())) {
                token = this.identOrFunctionToken(c, startLine, startCol);
              } else {
                token = this.charToken(c, startLine, startCol);
              }
              break;
            case "!":
              token = this.importantToken(c, startLine, startCol);
              break;
            case "@":
              token = this.atRuleToken(c, startLine, startCol);
              break;
            case ":":
              token = this.notToken(c, startLine, startCol);
              break;
            case "<":
              token = this.htmlCommentStartToken(c, startLine, startCol);
              break;
            case "U":
            case "u":
              if (reader.peek() === "+") {
                token = this.unicodeRangeToken(c, startLine, startCol);
                break;
              }
            default:
              if (isDigit(c)) {
                token = this.numberToken(c, startLine, startCol);
              } else if (isWhitespace(c)) {
                token = this.whitespaceToken(c, startLine, startCol);
              } else if (isIdentStart(c)) {
                token = this.identOrFunctionToken(c, startLine, startCol);
              } else {
                token = this.charToken(c, startLine, startCol);
              }
          }
          break;
        }
        if (!token && c === null) {
          token = this.createToken(Tokens.EOF, null, startLine, startCol);
        }
        return token;
      },
      createToken: function(tt, value, startLine, startCol, options) {
        var reader = this._reader;
        options = options || {};
        return {
          value,
          type: tt,
          channel: options.channel,
          endChar: options.endChar,
          hide: options.hide || false,
          startLine,
          startCol,
          endLine: reader.getLine(),
          endCol: reader.getCol()
        };
      },
      atRuleToken: function(first, startLine, startCol) {
        var rule = first, reader = this._reader, tt = Tokens.CHAR, ident;
        reader.mark();
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());
        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
          if (rule.length > 1) {
            tt = Tokens.UNKNOWN_SYM;
          } else {
            tt = Tokens.CHAR;
            rule = first;
            reader.reset();
          }
        }
        return this.createToken(tt, rule, startLine, startCol);
      },
      charToken: function(c, startLine, startCol) {
        var tt = Tokens.type(c);
        var opts = {};
        if (tt === -1) {
          tt = Tokens.CHAR;
        } else {
          opts.endChar = Tokens[tt].endChar;
        }
        return this.createToken(tt, c, startLine, startCol, opts);
      },
      commentToken: function(first, startLine, startCol) {
        var comment = this.readComment(first);
        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
      },
      comparisonToken: function(c, startLine, startCol) {
        var reader = this._reader, comparison = c + reader.read(), tt = Tokens.type(comparison) || Tokens.CHAR;
        return this.createToken(tt, comparison, startLine, startCol);
      },
      hashToken: function(first, startLine, startCol) {
        var name = this.readName(first);
        return this.createToken(Tokens.HASH, name, startLine, startCol);
      },
      htmlCommentStartToken: function(first, startLine, startCol) {
        var reader = this._reader, text = first;
        reader.mark();
        text += reader.readCount(3);
        if (text === "<!--") {
          return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
          reader.reset();
          return this.charToken(first, startLine, startCol);
        }
      },
      htmlCommentEndToken: function(first, startLine, startCol) {
        var reader = this._reader, text = first;
        reader.mark();
        text += reader.readCount(2);
        if (text === "-->") {
          return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
          reader.reset();
          return this.charToken(first, startLine, startCol);
        }
      },
      identOrFunctionToken: function(first, startLine, startCol) {
        var reader = this._reader, ident = this.readName(first), tt = Tokens.IDENT, uriFns = ["url(", "url-prefix(", "domain("];
        if (reader.peek() === "(") {
          ident += reader.read();
          if (uriFns.indexOf(ident.toLowerCase()) > -1) {
            tt = Tokens.URI;
            ident = this.readURI(ident);
            if (uriFns.indexOf(ident.toLowerCase()) > -1) {
              tt = Tokens.FUNCTION;
            }
          } else {
            tt = Tokens.FUNCTION;
          }
        } else if (reader.peek() === ":") {
          if (ident.toLowerCase() === "progid") {
            ident += reader.readTo("(");
            tt = Tokens.IE_FUNCTION;
          }
        }
        return this.createToken(tt, ident, startLine, startCol);
      },
      importantToken: function(first, startLine, startCol) {
        var reader = this._reader, important = first, tt = Tokens.CHAR, temp, c;
        reader.mark();
        c = reader.read();
        while (c) {
          if (c === "/") {
            if (reader.peek() !== "*") {
              break;
            } else {
              temp = this.readComment(c);
              if (temp === "") {
                break;
              }
            }
          } else if (isWhitespace(c)) {
            important += c + this.readWhitespace();
          } else if (/i/i.test(c)) {
            temp = reader.readCount(8);
            if (/mportant/i.test(temp)) {
              important += c + temp;
              tt = Tokens.IMPORTANT_SYM;
            }
            break;
          } else {
            break;
          }
          c = reader.read();
        }
        if (tt === Tokens.CHAR) {
          reader.reset();
          return this.charToken(first, startLine, startCol);
        } else {
          return this.createToken(tt, important, startLine, startCol);
        }
      },
      notToken: function(first, startLine, startCol) {
        var reader = this._reader, text = first;
        reader.mark();
        text += reader.readCount(4);
        if (text.toLowerCase() === ":not(") {
          return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
          reader.reset();
          return this.charToken(first, startLine, startCol);
        }
      },
      numberToken: function(first, startLine, startCol) {
        var reader = this._reader, value = this.readNumber(first), ident, tt = Tokens.NUMBER, c = reader.peek();
        if (isIdentStart(c)) {
          ident = this.readName(reader.read());
          value += ident;
          if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {
            tt = Tokens.LENGTH;
          } else if (/^deg|^rad$|^grad$/i.test(ident)) {
            tt = Tokens.ANGLE;
          } else if (/^ms$|^s$/i.test(ident)) {
            tt = Tokens.TIME;
          } else if (/^hz$|^khz$/i.test(ident)) {
            tt = Tokens.FREQ;
          } else if (/^dpi$|^dpcm$/i.test(ident)) {
            tt = Tokens.RESOLUTION;
          } else {
            tt = Tokens.DIMENSION;
          }
        } else if (c === "%") {
          value += reader.read();
          tt = Tokens.PERCENTAGE;
        }
        return this.createToken(tt, value, startLine, startCol);
      },
      stringToken: function(first, startLine, startCol) {
        var delim = first, string = first, reader = this._reader, prev = first, tt = Tokens.STRING, c = reader.read();
        while (c) {
          string += c;
          if (c === delim && prev !== "\\") {
            break;
          }
          if (isNewLine(reader.peek()) && c !== "\\") {
            tt = Tokens.INVALID;
            break;
          }
          prev = c;
          c = reader.read();
        }
        if (c === null) {
          tt = Tokens.INVALID;
        }
        return this.createToken(tt, string, startLine, startCol);
      },
      unicodeRangeToken: function(first, startLine, startCol) {
        var reader = this._reader, value = first, temp, tt = Tokens.CHAR;
        if (reader.peek() === "+") {
          reader.mark();
          value += reader.read();
          value += this.readUnicodeRangePart(true);
          if (value.length === 2) {
            reader.reset();
          } else {
            tt = Tokens.UNICODE_RANGE;
            if (value.indexOf("?") === -1) {
              if (reader.peek() === "-") {
                reader.mark();
                temp = reader.read();
                temp += this.readUnicodeRangePart(false);
                if (temp.length === 1) {
                  reader.reset();
                } else {
                  value += temp;
                }
              }
            }
          }
        }
        return this.createToken(tt, value, startLine, startCol);
      },
      whitespaceToken: function(first, startLine, startCol) {
        var value = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
      },
      readUnicodeRangePart: function(allowQuestionMark) {
        var reader = this._reader, part = "", c = reader.peek();
        while (isHexDigit(c) && part.length < 6) {
          reader.read();
          part += c;
          c = reader.peek();
        }
        if (allowQuestionMark) {
          while (c === "?" && part.length < 6) {
            reader.read();
            part += c;
            c = reader.peek();
          }
        }
        return part;
      },
      readWhitespace: function() {
        var reader = this._reader, whitespace = "", c = reader.peek();
        while (isWhitespace(c)) {
          reader.read();
          whitespace += c;
          c = reader.peek();
        }
        return whitespace;
      },
      readNumber: function(first) {
        var reader = this._reader, number = first, hasDot = first === ".", c = reader.peek();
        while (c) {
          if (isDigit(c)) {
            number += reader.read();
          } else if (c === ".") {
            if (hasDot) {
              break;
            } else {
              hasDot = true;
              number += reader.read();
            }
          } else {
            break;
          }
          c = reader.peek();
        }
        return number;
      },
      readString: function() {
        var reader = this._reader, delim = reader.read(), string = delim, prev = delim, c = reader.peek();
        while (c) {
          c = reader.read();
          string += c;
          if (c === delim && prev !== "\\") {
            break;
          }
          if (isNewLine(reader.peek()) && c !== "\\") {
            string = "";
            break;
          }
          prev = c;
          c = reader.peek();
        }
        if (c === null) {
          string = "";
        }
        return string;
      },
      readURI: function(first) {
        var reader = this._reader, uri = first, inner = "", c = reader.peek();
        reader.mark();
        while (c && isWhitespace(c)) {
          reader.read();
          c = reader.peek();
        }
        if (c === "'" || c === '"') {
          inner = this.readString();
        } else {
          inner = this.readURL();
        }
        c = reader.peek();
        while (c && isWhitespace(c)) {
          reader.read();
          c = reader.peek();
        }
        if (inner === "" || c !== ")") {
          uri = first;
          reader.reset();
        } else {
          uri += inner + reader.read();
        }
        return uri;
      },
      readURL: function() {
        var reader = this._reader, url = "", c = reader.peek();
        while (/^[!#$%&\\*-~]$/.test(c)) {
          url += reader.read();
          c = reader.peek();
        }
        return url;
      },
      readName: function(first) {
        var reader = this._reader, ident = first || "", c = reader.peek();
        while (true) {
          if (c === "\\") {
            ident += this.readEscape(reader.read());
            c = reader.peek();
          } else if (c && isNameChar(c)) {
            ident += reader.read();
            c = reader.peek();
          } else {
            break;
          }
        }
        return ident;
      },
      readEscape: function(first) {
        var reader = this._reader, cssEscape = first || "", i = 0, c = reader.peek();
        if (isHexDigit(c)) {
          do {
            cssEscape += reader.read();
            c = reader.peek();
          } while (c && isHexDigit(c) && ++i < 6);
        }
        if (cssEscape.length === 3 && /\s/.test(c) || cssEscape.length === 7 || cssEscape.length === 1) {
          reader.read();
        } else {
          c = "";
        }
        return cssEscape + c;
      },
      readComment: function(first) {
        var reader = this._reader, comment = first || "", c = reader.read();
        if (c === "*") {
          while (c) {
            comment += c;
            if (comment.length > 2 && c === "*" && reader.peek() === "/") {
              comment += reader.read();
              break;
            }
            c = reader.read();
          }
          return comment;
        } else {
          return "";
        }
      }
    });
    var Tokens = [
      {name: "CDO"},
      {name: "CDC"},
      {name: "S", whitespace: true},
      {name: "COMMENT", comment: true, hide: true, channel: "comment"},
      {name: "INCLUDES", text: "~="},
      {name: "DASHMATCH", text: "|="},
      {name: "PREFIXMATCH", text: "^="},
      {name: "SUFFIXMATCH", text: "$="},
      {name: "SUBSTRINGMATCH", text: "*="},
      {name: "STRING"},
      {name: "IDENT"},
      {name: "HASH"},
      {name: "IMPORT_SYM", text: "@import"},
      {name: "PAGE_SYM", text: "@page"},
      {name: "MEDIA_SYM", text: "@media"},
      {name: "FONT_FACE_SYM", text: "@font-face"},
      {name: "CHARSET_SYM", text: "@charset"},
      {name: "NAMESPACE_SYM", text: "@namespace"},
      {name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport", "@-o-viewport"]},
      {name: "DOCUMENT_SYM", text: ["@document", "@-moz-document"]},
      {name: "UNKNOWN_SYM"},
      {name: "KEYFRAMES_SYM", text: ["@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes"]},
      {name: "IMPORTANT_SYM"},
      {name: "LENGTH"},
      {name: "ANGLE"},
      {name: "TIME"},
      {name: "FREQ"},
      {name: "DIMENSION"},
      {name: "PERCENTAGE"},
      {name: "NUMBER"},
      {name: "URI"},
      {name: "FUNCTION"},
      {name: "UNICODE_RANGE"},
      {name: "INVALID"},
      {name: "PLUS", text: "+"},
      {name: "GREATER", text: ">"},
      {name: "COMMA", text: ","},
      {name: "TILDE", text: "~"},
      {name: "NOT"},
      {name: "TOPLEFTCORNER_SYM", text: "@top-left-corner"},
      {name: "TOPLEFT_SYM", text: "@top-left"},
      {name: "TOPCENTER_SYM", text: "@top-center"},
      {name: "TOPRIGHT_SYM", text: "@top-right"},
      {name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner"},
      {name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner"},
      {name: "BOTTOMLEFT_SYM", text: "@bottom-left"},
      {name: "BOTTOMCENTER_SYM", text: "@bottom-center"},
      {name: "BOTTOMRIGHT_SYM", text: "@bottom-right"},
      {name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner"},
      {name: "LEFTTOP_SYM", text: "@left-top"},
      {name: "LEFTMIDDLE_SYM", text: "@left-middle"},
      {name: "LEFTBOTTOM_SYM", text: "@left-bottom"},
      {name: "RIGHTTOP_SYM", text: "@right-top"},
      {name: "RIGHTMIDDLE_SYM", text: "@right-middle"},
      {name: "RIGHTBOTTOM_SYM", text: "@right-bottom"},
      {name: "RESOLUTION", state: "media"},
      {name: "IE_FUNCTION"},
      {name: "CHAR"},
      {
        name: "PIPE",
        text: "|"
      },
      {
        name: "SLASH",
        text: "/"
      },
      {
        name: "MINUS",
        text: "-"
      },
      {
        name: "STAR",
        text: "*"
      },
      {
        name: "LBRACE",
        endChar: "}",
        text: "{"
      },
      {
        name: "RBRACE",
        text: "}"
      },
      {
        name: "LBRACKET",
        endChar: "]",
        text: "["
      },
      {
        name: "RBRACKET",
        text: "]"
      },
      {
        name: "EQUALS",
        text: "="
      },
      {
        name: "COLON",
        text: ":"
      },
      {
        name: "SEMICOLON",
        text: ";"
      },
      {
        name: "LPAREN",
        endChar: ")",
        text: "("
      },
      {
        name: "RPAREN",
        text: ")"
      },
      {
        name: "DOT",
        text: "."
      }
    ];
    (function() {
      var nameMap = [], typeMap = Object.create(null);
      Tokens.UNKNOWN = -1;
      Tokens.unshift({name: "EOF"});
      for (var i = 0, len = Tokens.length; i < len; i++) {
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text) {
          if (Tokens[i].text instanceof Array) {
            for (var j = 0; j < Tokens[i].text.length; j++) {
              typeMap[Tokens[i].text[j]] = i;
            }
          } else {
            typeMap[Tokens[i].text] = i;
          }
        }
      }
      Tokens.name = function(tt) {
        return nameMap[tt];
      };
      Tokens.type = function(c) {
        return typeMap[c] || -1;
      };
    })();
    var Validation = {
      validate: function(property, value) {
        var name = property.toString().toLowerCase(), expression = new PropertyValueIterator(value), spec = Properties[name];
        if (!spec) {
          if (name.indexOf("-") !== 0) {
            throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
          }
        } else if (typeof spec !== "number") {
          if (typeof spec === "string") {
            if (spec.indexOf("||") > -1) {
              this.groupProperty(spec, expression);
            } else {
              this.singleProperty(spec, expression, 1);
            }
          } else if (spec.multi) {
            this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
          } else if (typeof spec === "function") {
            spec(expression);
          }
        }
      },
      singleProperty: function(types, expression, max, partial) {
        var result = false, value = expression.value, count = 0, part;
        while (expression.hasNext() && count < max) {
          result = ValidationTypes.isAny(expression, types);
          if (!result) {
            break;
          }
          count++;
        }
        if (!result) {
          if (expression.hasNext() && !expression.isFirst()) {
            part = expression.peek();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          } else {
            throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
          }
        } else if (expression.hasNext()) {
          part = expression.next();
          throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
      },
      multiProperty: function(types, expression, comma, max) {
        var result = false, value = expression.value, count = 0, part;
        while (expression.hasNext() && !result && count < max) {
          if (ValidationTypes.isAny(expression, types)) {
            count++;
            if (!expression.hasNext()) {
              result = true;
            } else if (comma) {
              if (String(expression.peek()) === ",") {
                part = expression.next();
              } else {
                break;
              }
            }
          } else {
            break;
          }
        }
        if (!result) {
          if (expression.hasNext() && !expression.isFirst()) {
            part = expression.peek();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          } else {
            part = expression.previous();
            if (comma && String(part) === ",") {
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
              throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
          }
        } else if (expression.hasNext()) {
          part = expression.next();
          throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
      },
      groupProperty: function(types, expression, comma) {
        var result = false, value = expression.value, typeCount = types.split("||").length, groups = {count: 0}, partial = false, name, part;
        while (expression.hasNext() && !result) {
          name = ValidationTypes.isAnyOfGroup(expression, types);
          if (name) {
            if (groups[name]) {
              break;
            } else {
              groups[name] = 1;
              groups.count++;
              partial = true;
              if (groups.count === typeCount || !expression.hasNext()) {
                result = true;
              }
            }
          } else {
            break;
          }
        }
        if (!result) {
          if (partial && expression.hasNext()) {
            part = expression.peek();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          } else {
            throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
          }
        } else if (expression.hasNext()) {
          part = expression.next();
          throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
      }
    };
    function ValidationError(message, line, col) {
      this.col = col;
      this.line = line;
      this.message = message;
    }
    ValidationError.prototype = new Error();
    var ValidationTypes = {
      isLiteral: function(part, literals) {
        var text = part.text.toString().toLowerCase(), args = literals.split(" | "), i, len, found = false;
        for (i = 0, len = args.length; i < len && !found; i++) {
          if (text === args[i].toLowerCase()) {
            found = true;
          }
        }
        return found;
      },
      isSimple: function(type) {
        return !!this.simple[type];
      },
      isComplex: function(type) {
        return !!this.complex[type];
      },
      isAny: function(expression, types) {
        var args = types.split(" | "), i, len, found = false;
        for (i = 0, len = args.length; i < len && !found && expression.hasNext(); i++) {
          found = this.isType(expression, args[i]);
        }
        return found;
      },
      isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "), i, len, found = false;
        for (i = 0, len = args.length; i < len && !found; i++) {
          found = this.isType(expression, args[i]);
        }
        return found ? args[i - 1] : false;
      },
      isType: function(expression, type) {
        var part = expression.peek(), result = false;
        if (type.charAt(0) !== "<") {
          result = this.isLiteral(part, type);
          if (result) {
            expression.next();
          }
        } else if (this.simple[type]) {
          result = this.simple[type](part);
          if (result) {
            expression.next();
          }
        } else {
          result = this.complex[type](expression);
        }
        return result;
      },
      simple: {
        __proto__: null,
        "<absolute-size>": function(part) {
          return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
        },
        "<attachment>": function(part) {
          return ValidationTypes.isLiteral(part, "scroll | fixed | local");
        },
        "<attr>": function(part) {
          return part.type === "function" && part.name === "attr";
        },
        "<bg-image>": function(part) {
          return this["<image>"](part) || this["<gradient>"](part) || String(part) === "none";
        },
        "<gradient>": function(part) {
          return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },
        "<box>": function(part) {
          return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
        },
        "<content>": function(part) {
          return part.type === "function" && part.name === "content";
        },
        "<relative-size>": function(part) {
          return ValidationTypes.isLiteral(part, "smaller | larger");
        },
        "<ident>": function(part) {
          return part.type === "identifier";
        },
        "<length>": function(part) {
          if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)) {
            return true;
          } else {
            return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
          }
        },
        "<color>": function(part) {
          return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
        },
        "<number>": function(part) {
          return part.type === "number" || this["<integer>"](part);
        },
        "<integer>": function(part) {
          return part.type === "integer";
        },
        "<line>": function(part) {
          return part.type === "integer";
        },
        "<angle>": function(part) {
          return part.type === "angle";
        },
        "<uri>": function(part) {
          return part.type === "uri";
        },
        "<image>": function(part) {
          return this["<uri>"](part);
        },
        "<percentage>": function(part) {
          return part.type === "percentage" || String(part) === "0";
        },
        "<border-width>": function(part) {
          return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
        },
        "<border-style>": function(part) {
          return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
        },
        "<content-sizing>": function(part) {
          return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
        },
        "<margin-width>": function(part) {
          return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
        },
        "<padding-width>": function(part) {
          return this["<length>"](part) || this["<percentage>"](part);
        },
        "<shape>": function(part) {
          return part.type === "function" && (part.name === "rect" || part.name === "inset-rect");
        },
        "<time>": function(part) {
          return part.type === "time";
        },
        "<flex-grow>": function(part) {
          return this["<number>"](part);
        },
        "<flex-shrink>": function(part) {
          return this["<number>"](part);
        },
        "<width>": function(part) {
          return this["<margin-width>"](part);
        },
        "<flex-basis>": function(part) {
          return this["<width>"](part);
        },
        "<flex-direction>": function(part) {
          return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
        },
        "<flex-wrap>": function(part) {
          return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
        },
        "<feature-tag-value>": function(part) {
          return part.type === "function" && /^[A-Z0-9]{4}$/i.test(part);
        }
      },
      complex: {
        __proto__: null,
        "<bg-position>": function(expression) {
          var result = false, numeric = "<percentage> | <length>", xDir = "left | right", yDir = "top | bottom", count = 0;
          while (expression.peek(count) && expression.peek(count).text !== ",") {
            count++;
          }
          if (count < 3) {
            if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
              result = true;
              ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
            } else if (ValidationTypes.isAny(expression, yDir)) {
              result = true;
              ValidationTypes.isAny(expression, xDir + " | center");
            }
          } else {
            if (ValidationTypes.isAny(expression, xDir)) {
              if (ValidationTypes.isAny(expression, yDir)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
              } else if (ValidationTypes.isAny(expression, numeric)) {
                if (ValidationTypes.isAny(expression, yDir)) {
                  result = true;
                  ValidationTypes.isAny(expression, numeric);
                } else if (ValidationTypes.isAny(expression, "center")) {
                  result = true;
                }
              }
            } else if (ValidationTypes.isAny(expression, yDir)) {
              if (ValidationTypes.isAny(expression, xDir)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
              } else if (ValidationTypes.isAny(expression, numeric)) {
                if (ValidationTypes.isAny(expression, xDir)) {
                  result = true;
                  ValidationTypes.isAny(expression, numeric);
                } else if (ValidationTypes.isAny(expression, "center")) {
                  result = true;
                }
              }
            } else if (ValidationTypes.isAny(expression, "center")) {
              if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
              }
            }
          }
          return result;
        },
        "<bg-size>": function(expression) {
          var result = false, numeric = "<percentage> | <length> | auto";
          if (ValidationTypes.isAny(expression, "cover | contain")) {
            result = true;
          } else if (ValidationTypes.isAny(expression, numeric)) {
            result = true;
            ValidationTypes.isAny(expression, numeric);
          }
          return result;
        },
        "<repeat-style>": function(expression) {
          var result = false, values = "repeat | space | round | no-repeat", part;
          if (expression.hasNext()) {
            part = expression.next();
            if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
              result = true;
            } else if (ValidationTypes.isLiteral(part, values)) {
              result = true;
              if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                expression.next();
              }
            }
          }
          return result;
        },
        "<shadow>": function(expression) {
          var result = false, count = 0, inset = false, color = false;
          if (expression.hasNext()) {
            if (ValidationTypes.isAny(expression, "inset")) {
              inset = true;
            }
            if (ValidationTypes.isAny(expression, "<color>")) {
              color = true;
            }
            while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
              count++;
            }
            if (expression.hasNext()) {
              if (!color) {
                ValidationTypes.isAny(expression, "<color>");
              }
              if (!inset) {
                ValidationTypes.isAny(expression, "inset");
              }
            }
            result = count >= 2 && count <= 4;
          }
          return result;
        },
        "<x-one-radius>": function(expression) {
          var result = false, simple = "<length> | <percentage> | inherit";
          if (ValidationTypes.isAny(expression, simple)) {
            result = true;
            ValidationTypes.isAny(expression, simple);
          }
          return result;
        },
        "<flex>": function(expression) {
          var part, result = false;
          if (ValidationTypes.isAny(expression, "none | inherit")) {
            result = true;
          } else {
            if (ValidationTypes.isType(expression, "<flex-grow>")) {
              if (expression.peek()) {
                if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                  if (expression.peek()) {
                    result = ValidationTypes.isType(expression, "<flex-basis>");
                  } else {
                    result = true;
                  }
                } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                  result = expression.peek() === null;
                }
              } else {
                result = true;
              }
            } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
              result = true;
            }
          }
          if (!result) {
            part = expression.peek();
            throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
          }
          return result;
        }
      }
    };
    parserlib.css = {
      __proto__: null,
      Colors,
      Combinator,
      Parser,
      PropertyName,
      PropertyValue,
      PropertyValuePart,
      MediaFeature,
      MediaQuery,
      Selector,
      SelectorPart,
      SelectorSubPart,
      Specificity,
      TokenStream,
      Tokens,
      ValidationError
    };
  })();
  (function() {
    for (var prop in parserlib) {
      exports2[prop] = parserlib[prop];
    }
  })();
});

// node_modules/domino/lib/CSSStyleDeclaration.js
var require_CSSStyleDeclaration = __commonJS((exports2, module2) => {
  "use strict";
  var parserlib = require_cssparser();
  module2.exports = CSSStyleDeclaration;
  function CSSStyleDeclaration(elt) {
    this._element = elt;
  }
  function parseStyles(s) {
    var parser = new parserlib.css.Parser();
    var result = {property: Object.create(null), priority: Object.create(null)};
    parser.addListener("property", function(e) {
      if (e.invalid)
        return;
      result.property[e.property.text] = e.value.text;
      if (e.important)
        result.priority[e.property.text] = "important";
    });
    s = ("" + s).replace(/^;/, "");
    parser.parseStyleAttribute(s);
    return result;
  }
  var NO_CHANGE = {};
  CSSStyleDeclaration.prototype = Object.create(Object.prototype, {
    _parsed: {get: function() {
      if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
        var text = this.cssText;
        this._parsedStyles = parseStyles(text);
        this._lastParsedText = text;
        delete this._names;
      }
      return this._parsedStyles;
    }},
    _serialize: {value: function() {
      var styles = this._parsed;
      var s = "";
      for (var name in styles.property) {
        if (s)
          s += " ";
        s += name + ": " + styles.property[name];
        if (styles.priority[name]) {
          s += " !" + styles.priority[name];
        }
        s += ";";
      }
      this.cssText = s;
      this._lastParsedText = s;
      delete this._names;
    }},
    cssText: {
      get: function() {
        return this._element.getAttribute("style");
      },
      set: function(value) {
        this._element.setAttribute("style", value);
      }
    },
    length: {get: function() {
      if (!this._names)
        this._names = Object.getOwnPropertyNames(this._parsed.property);
      return this._names.length;
    }},
    item: {value: function(n) {
      if (!this._names)
        this._names = Object.getOwnPropertyNames(this._parsed.property);
      return this._names[n];
    }},
    getPropertyValue: {value: function(property) {
      property = property.toLowerCase();
      return this._parsed.property[property] || "";
    }},
    getPropertyPriority: {value: function(property) {
      property = property.toLowerCase();
      return this._parsed.priority[property] || "";
    }},
    setProperty: {value: function(property, value, priority) {
      property = property.toLowerCase();
      if (value === null || value === void 0) {
        value = "";
      }
      if (priority === null || priority === void 0) {
        priority = "";
      }
      if (value !== NO_CHANGE) {
        value = "" + value;
      }
      if (value === "") {
        this.removeProperty(property);
        return;
      }
      if (priority !== "" && priority !== NO_CHANGE && !/^important$/i.test(priority)) {
        return;
      }
      var styles = this._parsed;
      if (value === NO_CHANGE) {
        if (!styles.property[property]) {
          return;
        }
        if (priority !== "") {
          styles.priority[property] = "important";
        } else {
          delete styles.priority[property];
        }
      } else {
        if (value.indexOf(";") !== -1)
          return;
        var newprops = parseStyles(property + ":" + value);
        if (Object.getOwnPropertyNames(newprops.property).length === 0) {
          return;
        }
        if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {
          return;
        }
        for (var p in newprops.property) {
          styles.property[p] = newprops.property[p];
          if (priority === NO_CHANGE) {
            continue;
          } else if (priority !== "") {
            styles.priority[p] = "important";
          } else if (styles.priority[p]) {
            delete styles.priority[p];
          }
        }
      }
      this._serialize();
    }},
    setPropertyValue: {value: function(property, value) {
      return this.setProperty(property, value, NO_CHANGE);
    }},
    setPropertyPriority: {value: function(property, priority) {
      return this.setProperty(property, NO_CHANGE, priority);
    }},
    removeProperty: {value: function(property) {
      property = property.toLowerCase();
      var styles = this._parsed;
      if (property in styles.property) {
        delete styles.property[property];
        delete styles.priority[property];
        this._serialize();
      }
    }}
  });
  var cssProperties = {
    alignContent: "align-content",
    alignItems: "align-items",
    alignmentBaseline: "alignment-baseline",
    alignSelf: "align-self",
    animation: "animation",
    animationDelay: "animation-delay",
    animationDirection: "animation-direction",
    animationDuration: "animation-duration",
    animationFillMode: "animation-fill-mode",
    animationIterationCount: "animation-iteration-count",
    animationName: "animation-name",
    animationPlayState: "animation-play-state",
    animationTimingFunction: "animation-timing-function",
    backfaceVisibility: "backface-visibility",
    background: "background",
    backgroundAttachment: "background-attachment",
    backgroundClip: "background-clip",
    backgroundColor: "background-color",
    backgroundImage: "background-image",
    backgroundOrigin: "background-origin",
    backgroundPosition: "background-position",
    backgroundPositionX: "background-position-x",
    backgroundPositionY: "background-position-y",
    backgroundRepeat: "background-repeat",
    backgroundSize: "background-size",
    baselineShift: "baseline-shift",
    border: "border",
    borderBottom: "border-bottom",
    borderBottomColor: "border-bottom-color",
    borderBottomLeftRadius: "border-bottom-left-radius",
    borderBottomRightRadius: "border-bottom-right-radius",
    borderBottomStyle: "border-bottom-style",
    borderBottomWidth: "border-bottom-width",
    borderCollapse: "border-collapse",
    borderColor: "border-color",
    borderImage: "border-image",
    borderImageOutset: "border-image-outset",
    borderImageRepeat: "border-image-repeat",
    borderImageSlice: "border-image-slice",
    borderImageSource: "border-image-source",
    borderImageWidth: "border-image-width",
    borderLeft: "border-left",
    borderLeftColor: "border-left-color",
    borderLeftStyle: "border-left-style",
    borderLeftWidth: "border-left-width",
    borderRadius: "border-radius",
    borderRight: "border-right",
    borderRightColor: "border-right-color",
    borderRightStyle: "border-right-style",
    borderRightWidth: "border-right-width",
    borderSpacing: "border-spacing",
    borderStyle: "border-style",
    borderTop: "border-top",
    borderTopColor: "border-top-color",
    borderTopLeftRadius: "border-top-left-radius",
    borderTopRightRadius: "border-top-right-radius",
    borderTopStyle: "border-top-style",
    borderTopWidth: "border-top-width",
    borderWidth: "border-width",
    bottom: "bottom",
    boxShadow: "box-shadow",
    boxSizing: "box-sizing",
    breakAfter: "break-after",
    breakBefore: "break-before",
    breakInside: "break-inside",
    captionSide: "caption-side",
    clear: "clear",
    clip: "clip",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    color: "color",
    colorInterpolationFilters: "color-interpolation-filters",
    columnCount: "column-count",
    columnFill: "column-fill",
    columnGap: "column-gap",
    columnRule: "column-rule",
    columnRuleColor: "column-rule-color",
    columnRuleStyle: "column-rule-style",
    columnRuleWidth: "column-rule-width",
    columns: "columns",
    columnSpan: "column-span",
    columnWidth: "column-width",
    content: "content",
    counterIncrement: "counter-increment",
    counterReset: "counter-reset",
    cssFloat: "float",
    cursor: "cursor",
    direction: "direction",
    display: "display",
    dominantBaseline: "dominant-baseline",
    emptyCells: "empty-cells",
    enableBackground: "enable-background",
    fill: "fill",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    filter: "filter",
    flex: "flex",
    flexBasis: "flex-basis",
    flexDirection: "flex-direction",
    flexFlow: "flex-flow",
    flexGrow: "flex-grow",
    flexShrink: "flex-shrink",
    flexWrap: "flex-wrap",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    font: "font",
    fontFamily: "font-family",
    fontFeatureSettings: "font-feature-settings",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    grid: "grid",
    gridArea: "grid-area",
    gridAutoColumns: "grid-auto-columns",
    gridAutoFlow: "grid-auto-flow",
    gridAutoRows: "grid-auto-rows",
    gridColumn: "grid-column",
    gridColumnEnd: "grid-column-end",
    gridColumnGap: "grid-column-gap",
    gridColumnStart: "grid-column-start",
    gridGap: "grid-gap",
    gridRow: "grid-row",
    gridRowEnd: "grid-row-end",
    gridRowGap: "grid-row-gap",
    gridRowStart: "grid-row-start",
    gridTemplate: "grid-template",
    gridTemplateAreas: "grid-template-areas",
    gridTemplateColumns: "grid-template-columns",
    gridTemplateRows: "grid-template-rows",
    height: "height",
    imeMode: "ime-mode",
    justifyContent: "justify-content",
    kerning: "kerning",
    layoutGrid: "layout-grid",
    layoutGridChar: "layout-grid-char",
    layoutGridLine: "layout-grid-line",
    layoutGridMode: "layout-grid-mode",
    layoutGridType: "layout-grid-type",
    left: "left",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    lineBreak: "line-break",
    lineHeight: "line-height",
    listStyle: "list-style",
    listStyleImage: "list-style-image",
    listStylePosition: "list-style-position",
    listStyleType: "list-style-type",
    margin: "margin",
    marginBottom: "margin-bottom",
    marginLeft: "margin-left",
    marginRight: "margin-right",
    marginTop: "margin-top",
    marker: "marker",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    mask: "mask",
    maxHeight: "max-height",
    maxWidth: "max-width",
    minHeight: "min-height",
    minWidth: "min-width",
    msContentZoomChaining: "-ms-content-zoom-chaining",
    msContentZooming: "-ms-content-zooming",
    msContentZoomLimit: "-ms-content-zoom-limit",
    msContentZoomLimitMax: "-ms-content-zoom-limit-max",
    msContentZoomLimitMin: "-ms-content-zoom-limit-min",
    msContentZoomSnap: "-ms-content-zoom-snap",
    msContentZoomSnapPoints: "-ms-content-zoom-snap-points",
    msContentZoomSnapType: "-ms-content-zoom-snap-type",
    msFlowFrom: "-ms-flow-from",
    msFlowInto: "-ms-flow-into",
    msFontFeatureSettings: "-ms-font-feature-settings",
    msGridColumn: "-ms-grid-column",
    msGridColumnAlign: "-ms-grid-column-align",
    msGridColumns: "-ms-grid-columns",
    msGridColumnSpan: "-ms-grid-column-span",
    msGridRow: "-ms-grid-row",
    msGridRowAlign: "-ms-grid-row-align",
    msGridRows: "-ms-grid-rows",
    msGridRowSpan: "-ms-grid-row-span",
    msHighContrastAdjust: "-ms-high-contrast-adjust",
    msHyphenateLimitChars: "-ms-hyphenate-limit-chars",
    msHyphenateLimitLines: "-ms-hyphenate-limit-lines",
    msHyphenateLimitZone: "-ms-hyphenate-limit-zone",
    msHyphens: "-ms-hyphens",
    msImeAlign: "-ms-ime-align",
    msOverflowStyle: "-ms-overflow-style",
    msScrollChaining: "-ms-scroll-chaining",
    msScrollLimit: "-ms-scroll-limit",
    msScrollLimitXMax: "-ms-scroll-limit-x-max",
    msScrollLimitXMin: "-ms-scroll-limit-x-min",
    msScrollLimitYMax: "-ms-scroll-limit-y-max",
    msScrollLimitYMin: "-ms-scroll-limit-y-min",
    msScrollRails: "-ms-scroll-rails",
    msScrollSnapPointsX: "-ms-scroll-snap-points-x",
    msScrollSnapPointsY: "-ms-scroll-snap-points-y",
    msScrollSnapType: "-ms-scroll-snap-type",
    msScrollSnapX: "-ms-scroll-snap-x",
    msScrollSnapY: "-ms-scroll-snap-y",
    msScrollTranslation: "-ms-scroll-translation",
    msTextCombineHorizontal: "-ms-text-combine-horizontal",
    msTextSizeAdjust: "-ms-text-size-adjust",
    msTouchAction: "-ms-touch-action",
    msTouchSelect: "-ms-touch-select",
    msUserSelect: "-ms-user-select",
    msWrapFlow: "-ms-wrap-flow",
    msWrapMargin: "-ms-wrap-margin",
    msWrapThrough: "-ms-wrap-through",
    opacity: "opacity",
    order: "order",
    orphans: "orphans",
    outline: "outline",
    outlineColor: "outline-color",
    outlineOffset: "outline-offset",
    outlineStyle: "outline-style",
    outlineWidth: "outline-width",
    overflow: "overflow",
    overflowX: "overflow-x",
    overflowY: "overflow-y",
    padding: "padding",
    paddingBottom: "padding-bottom",
    paddingLeft: "padding-left",
    paddingRight: "padding-right",
    paddingTop: "padding-top",
    page: "page",
    pageBreakAfter: "page-break-after",
    pageBreakBefore: "page-break-before",
    pageBreakInside: "page-break-inside",
    perspective: "perspective",
    perspectiveOrigin: "perspective-origin",
    pointerEvents: "pointer-events",
    position: "position",
    quotes: "quotes",
    right: "right",
    rotate: "rotate",
    rubyAlign: "ruby-align",
    rubyOverhang: "ruby-overhang",
    rubyPosition: "ruby-position",
    scale: "scale",
    size: "size",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    stroke: "stroke",
    strokeDasharray: "stroke-dasharray",
    strokeDashoffset: "stroke-dashoffset",
    strokeLinecap: "stroke-linecap",
    strokeLinejoin: "stroke-linejoin",
    strokeMiterlimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tableLayout: "table-layout",
    textAlign: "text-align",
    textAlignLast: "text-align-last",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textIndent: "text-indent",
    textJustify: "text-justify",
    textKashida: "text-kashida",
    textKashidaSpace: "text-kashida-space",
    textOverflow: "text-overflow",
    textShadow: "text-shadow",
    textTransform: "text-transform",
    textUnderlinePosition: "text-underline-position",
    top: "top",
    touchAction: "touch-action",
    transform: "transform",
    transformOrigin: "transform-origin",
    transformStyle: "transform-style",
    transition: "transition",
    transitionDelay: "transition-delay",
    transitionDuration: "transition-duration",
    transitionProperty: "transition-property",
    transitionTimingFunction: "transition-timing-function",
    translate: "translate",
    unicodeBidi: "unicode-bidi",
    verticalAlign: "vertical-align",
    visibility: "visibility",
    webkitAlignContent: "-webkit-align-content",
    webkitAlignItems: "-webkit-align-items",
    webkitAlignSelf: "-webkit-align-self",
    webkitAnimation: "-webkit-animation",
    webkitAnimationDelay: "-webkit-animation-delay",
    webkitAnimationDirection: "-webkit-animation-direction",
    webkitAnimationDuration: "-webkit-animation-duration",
    webkitAnimationFillMode: "-webkit-animation-fill-mode",
    webkitAnimationIterationCount: "-webkit-animation-iteration-count",
    webkitAnimationName: "-webkit-animation-name",
    webkitAnimationPlayState: "-webkit-animation-play-state",
    webkitAnimationTimingFunction: "-webkit-animation-timing-funciton",
    webkitAppearance: "-webkit-appearance",
    webkitBackfaceVisibility: "-webkit-backface-visibility",
    webkitBackgroundClip: "-webkit-background-clip",
    webkitBackgroundOrigin: "-webkit-background-origin",
    webkitBackgroundSize: "-webkit-background-size",
    webkitBorderBottomLeftRadius: "-webkit-border-bottom-left-radius",
    webkitBorderBottomRightRadius: "-webkit-border-bottom-right-radius",
    webkitBorderImage: "-webkit-border-image",
    webkitBorderRadius: "-webkit-border-radius",
    webkitBorderTopLeftRadius: "-webkit-border-top-left-radius",
    webkitBorderTopRightRadius: "-webkit-border-top-right-radius",
    webkitBoxAlign: "-webkit-box-align",
    webkitBoxDirection: "-webkit-box-direction",
    webkitBoxFlex: "-webkit-box-flex",
    webkitBoxOrdinalGroup: "-webkit-box-ordinal-group",
    webkitBoxOrient: "-webkit-box-orient",
    webkitBoxPack: "-webkit-box-pack",
    webkitBoxSizing: "-webkit-box-sizing",
    webkitColumnBreakAfter: "-webkit-column-break-after",
    webkitColumnBreakBefore: "-webkit-column-break-before",
    webkitColumnBreakInside: "-webkit-column-break-inside",
    webkitColumnCount: "-webkit-column-count",
    webkitColumnGap: "-webkit-column-gap",
    webkitColumnRule: "-webkit-column-rule",
    webkitColumnRuleColor: "-webkit-column-rule-color",
    webkitColumnRuleStyle: "-webkit-column-rule-style",
    webkitColumnRuleWidth: "-webkit-column-rule-width",
    webkitColumns: "-webkit-columns",
    webkitColumnSpan: "-webkit-column-span",
    webkitColumnWidth: "-webkit-column-width",
    webkitFilter: "-webkit-filter",
    webkitFlex: "-webkit-flex",
    webkitFlexBasis: "-webkit-flex-basis",
    webkitFlexDirection: "-webkit-flex-direction",
    webkitFlexFlow: "-webkit-flex-flow",
    webkitFlexGrow: "-webkit-flex-grow",
    webkitFlexShrink: "-webkit-flex-shrink",
    webkitFlexWrap: "-webkit-flex-wrap",
    webkitJustifyContent: "-webkit-justify-content",
    webkitOrder: "-webkit-order",
    webkitPerspective: "-webkit-perspective-origin",
    webkitPerspectiveOrigin: "-webkit-perspective-origin",
    webkitTapHighlightColor: "-webkit-tap-highlight-color",
    webkitTextFillColor: "-webkit-text-fill-color",
    webkitTextSizeAdjust: "-webkit-text-size-adjust",
    webkitTextStroke: "-webkit-text-stroke",
    webkitTextStrokeColor: "-webkit-text-stroke-color",
    webkitTextStrokeWidth: "-webkit-text-stroke-width",
    webkitTransform: "-webkit-transform",
    webkitTransformOrigin: "-webkit-transform-origin",
    webkitTransformStyle: "-webkit-transform-style",
    webkitTransition: "-webkit-transition",
    webkitTransitionDelay: "-webkit-transition-delay",
    webkitTransitionDuration: "-webkit-transition-duration",
    webkitTransitionProperty: "-webkit-transition-property",
    webkitTransitionTimingFunction: "-webkit-transition-timing-function",
    webkitUserModify: "-webkit-user-modify",
    webkitUserSelect: "-webkit-user-select",
    webkitWritingMode: "-webkit-writing-mode",
    whiteSpace: "white-space",
    widows: "widows",
    width: "width",
    wordBreak: "word-break",
    wordSpacing: "word-spacing",
    wordWrap: "word-wrap",
    writingMode: "writing-mode",
    zIndex: "z-index",
    zoom: "zoom",
    resize: "resize",
    userSelect: "user-select"
  };
  for (var prop in cssProperties)
    defineStyleProperty(prop);
  function defineStyleProperty(jsname) {
    var cssname = cssProperties[jsname];
    Object.defineProperty(CSSStyleDeclaration.prototype, jsname, {
      get: function() {
        return this.getPropertyValue(cssname);
      },
      set: function(value) {
        this.setProperty(cssname, value);
      }
    });
    if (!CSSStyleDeclaration.prototype.hasOwnProperty(cssname)) {
      Object.defineProperty(CSSStyleDeclaration.prototype, cssname, {
        get: function() {
          return this.getPropertyValue(cssname);
        },
        set: function(value) {
          this.setProperty(cssname, value);
        }
      });
    }
  }
});

// node_modules/domino/lib/URLUtils.js
var require_URLUtils = __commonJS((exports2, module2) => {
  "use strict";
  var URL = require_URL();
  module2.exports = URLUtils;
  function URLUtils() {
  }
  URLUtils.prototype = Object.create(Object.prototype, {
    _url: {get: function() {
      return new URL(this.href);
    }},
    protocol: {
      get: function() {
        var url = this._url;
        if (url && url.scheme)
          return url.scheme + ":";
        else
          return ":";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute()) {
          v = v.replace(/:+$/, "");
          v = v.replace(/[^-+\.a-zA-Z0-9]/g, URL.percentEncode);
          if (v.length > 0) {
            url.scheme = v;
            output = url.toString();
          }
        }
        this.href = output;
      }
    },
    host: {
      get: function() {
        var url = this._url;
        if (url.isAbsolute() && url.isAuthorityBased())
          return url.host + (url.port ? ":" + url.port : "");
        else
          return "";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute() && url.isAuthorityBased()) {
          v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
          if (v.length > 0) {
            url.host = v;
            delete url.port;
            output = url.toString();
          }
        }
        this.href = output;
      }
    },
    hostname: {
      get: function() {
        var url = this._url;
        if (url.isAbsolute() && url.isAuthorityBased())
          return url.host;
        else
          return "";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute() && url.isAuthorityBased()) {
          v = v.replace(/^\/+/, "");
          v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
          if (v.length > 0) {
            url.host = v;
            output = url.toString();
          }
        }
        this.href = output;
      }
    },
    port: {
      get: function() {
        var url = this._url;
        if (url.isAbsolute() && url.isAuthorityBased() && url.port !== void 0)
          return url.port;
        else
          return "";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute() && url.isAuthorityBased()) {
          v = "" + v;
          v = v.replace(/[^0-9].*$/, "");
          v = v.replace(/^0+/, "");
          if (v.length === 0)
            v = "0";
          if (parseInt(v, 10) <= 65535) {
            url.port = v;
            output = url.toString();
          }
        }
        this.href = output;
      }
    },
    pathname: {
      get: function() {
        var url = this._url;
        if (url.isAbsolute() && url.isHierarchical())
          return url.path;
        else
          return "";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute() && url.isHierarchical()) {
          if (v.charAt(0) !== "/")
            v = "/" + v;
          v = v.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g, URL.percentEncode);
          url.path = v;
          output = url.toString();
        }
        this.href = output;
      }
    },
    search: {
      get: function() {
        var url = this._url;
        if (url.isAbsolute() && url.isHierarchical() && url.query !== void 0)
          return "?" + url.query;
        else
          return "";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute() && url.isHierarchical()) {
          if (v.charAt(0) === "?")
            v = v.substring(1);
          v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
          url.query = v;
          output = url.toString();
        }
        this.href = output;
      }
    },
    hash: {
      get: function() {
        var url = this._url;
        if (url == null || url.fragment == null || url.fragment === "") {
          return "";
        } else {
          return "#" + url.fragment;
        }
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (v.charAt(0) === "#")
          v = v.substring(1);
        v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
        url.fragment = v;
        output = url.toString();
        this.href = output;
      }
    },
    username: {
      get: function() {
        var url = this._url;
        return url.username || "";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute()) {
          v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, URL.percentEncode);
          url.username = v;
          output = url.toString();
        }
        this.href = output;
      }
    },
    password: {
      get: function() {
        var url = this._url;
        return url.password || "";
      },
      set: function(v) {
        var output = this.href;
        var url = new URL(output);
        if (url.isAbsolute()) {
          if (v === "") {
            url.password = null;
          } else {
            v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, URL.percentEncode);
            url.password = v;
          }
          output = url.toString();
        }
        this.href = output;
      }
    },
    origin: {get: function() {
      var url = this._url;
      if (url == null) {
        return "";
      }
      var originForPort = function(defaultPort) {
        var origin = [url.scheme, url.host, +url.port || defaultPort];
        return origin[0] + "://" + origin[1] + (origin[2] === defaultPort ? "" : ":" + origin[2]);
      };
      switch (url.scheme) {
        case "ftp":
          return originForPort(21);
        case "gopher":
          return originForPort(70);
        case "http":
        case "ws":
          return originForPort(80);
        case "https":
        case "wss":
          return originForPort(443);
        default:
          return url.scheme + "://";
      }
    }}
  });
  URLUtils._inherit = function(proto) {
    Object.getOwnPropertyNames(URLUtils.prototype).forEach(function(p) {
      if (p === "constructor" || p === "href") {
        return;
      }
      var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);
      Object.defineProperty(proto, p, desc);
    });
  };
});

// node_modules/domino/lib/sloppy.js
var require_sloppy = __commonJS((exports, module) => {
  module.exports = {
    Window_run: function _run(code, file) {
      if (file)
        code += "\n//@ sourceURL=" + file;
      with (this)
        eval(code);
    },
    EventHandlerBuilder_build: function build() {
      try {
        with (this.document.defaultView || Object.create(null))
          with (this.document)
            with (this.form)
              with (this.element)
                return eval("(function(event){" + this.body + "})");
      } catch (err) {
        return function() {
          throw err;
        };
      }
    }
  };
});

// node_modules/domino/lib/defineElement.js
var require_defineElement = __commonJS((exports2, module2) => {
  "use strict";
  var attributes = require_attributes();
  var sloppy = require_sloppy();
  var isApiWritable = require_config().isApiWritable;
  module2.exports = function(spec, defaultConstructor, tagList, tagNameToImpl) {
    var c = spec.ctor;
    if (c) {
      var props = spec.props || {};
      if (spec.attributes) {
        for (var n in spec.attributes) {
          var attr = spec.attributes[n];
          if (typeof attr !== "object" || Array.isArray(attr))
            attr = {type: attr};
          if (!attr.name)
            attr.name = n.toLowerCase();
          props[n] = attributes.property(attr);
        }
      }
      props.constructor = {value: c, writable: isApiWritable};
      c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);
      if (spec.events) {
        addEventHandlers(c, spec.events);
      }
      tagList[c.name] = c;
    } else {
      c = defaultConstructor;
    }
    (spec.tags || spec.tag && [spec.tag] || []).forEach(function(tag) {
      tagNameToImpl[tag] = c;
    });
    return c;
  };
  function EventHandlerBuilder(body, document, form, element) {
    this.body = body;
    this.document = document;
    this.form = form;
    this.element = element;
  }
  EventHandlerBuilder.prototype.build = sloppy.EventHandlerBuilder_build;
  function EventHandlerChangeHandler(elt, name, oldval, newval) {
    var doc = elt.ownerDocument || Object.create(null);
    var form = elt.form || Object.create(null);
    elt[name] = new EventHandlerBuilder(newval, doc, form, elt).build();
  }
  function addEventHandlers(c, eventHandlerTypes) {
    var p = c.prototype;
    eventHandlerTypes.forEach(function(type) {
      Object.defineProperty(p, "on" + type, {
        get: function() {
          return this._getEventHandler(type);
        },
        set: function(v) {
          this._setEventHandler(type, v);
        }
      });
      attributes.registerChangeHandler(c, "on" + type, EventHandlerChangeHandler);
    });
  }
});

// node_modules/domino/lib/Location.js
var require_Location = __commonJS((exports2, module2) => {
  "use strict";
  var URL = require_URL();
  var URLUtils = require_URLUtils();
  module2.exports = Location;
  function Location(window4, href) {
    this._window = window4;
    this._href = href;
  }
  Location.prototype = Object.create(URLUtils.prototype, {
    constructor: {value: Location},
    href: {
      get: function() {
        return this._href;
      },
      set: function(v) {
        this.assign(v);
      }
    },
    assign: {value: function(url) {
      var current = new URL(this._href);
      var newurl = current.resolve(url);
      this._href = newurl;
    }},
    replace: {value: function(url) {
      this.assign(url);
    }},
    reload: {value: function() {
      this.assign(this.href);
    }},
    toString: {value: function() {
      return this.href;
    }}
  });
});

// node_modules/domino/lib/NavigatorID.js
var require_NavigatorID = __commonJS((exports2, module2) => {
  "use strict";
  var NavigatorID = Object.create(null, {
    appCodeName: {value: "Mozilla"},
    appName: {value: "Netscape"},
    appVersion: {value: "4.0"},
    platform: {value: ""},
    product: {value: "Gecko"},
    productSub: {value: "20100101"},
    userAgent: {value: ""},
    vendor: {value: ""},
    vendorSub: {value: ""},
    taintEnabled: {value: function() {
      return false;
    }}
  });
  module2.exports = NavigatorID;
});

// node_modules/domino/lib/WindowTimers.js
var require_WindowTimers = __commonJS((exports2, module2) => {
  "use strict";
  var WindowTimers = {
    setTimeout,
    clearTimeout,
    setInterval,
    clearInterval
  };
  module2.exports = WindowTimers;
});

// node_modules/domino/lib/DocumentType.js
var require_DocumentType = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = DocumentType;
  var Node2 = require_Node();
  var Leaf = require_Leaf();
  var ChildNode = require_ChildNode();
  function DocumentType(ownerDocument, name, publicId, systemId) {
    Leaf.call(this);
    this.nodeType = Node2.DOCUMENT_TYPE_NODE;
    this.ownerDocument = ownerDocument || null;
    this.name = name;
    this.publicId = publicId || "";
    this.systemId = systemId || "";
  }
  DocumentType.prototype = Object.create(Leaf.prototype, {
    nodeName: {get: function() {
      return this.name;
    }},
    nodeValue: {
      get: function() {
        return null;
      },
      set: function() {
      }
    },
    clone: {value: function clone() {
      return new DocumentType(this.ownerDocument, this.name, this.publicId, this.systemId);
    }},
    isEqual: {value: function isEqual(n) {
      return this.name === n.name && this.publicId === n.publicId && this.systemId === n.systemId;
    }}
  });
  Object.defineProperties(DocumentType.prototype, ChildNode);
});

// node_modules/domino/lib/HTMLParser.js
var require_HTMLParser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = HTMLParser2;
  var Document = require_Document();
  var DocumentType = require_DocumentType();
  var Node2 = require_Node();
  var NAMESPACE = require_utils4().NAMESPACE;
  var html = require_htmlelts();
  var impl = html.elements;
  var pushAll = Function.prototype.apply.bind(Array.prototype.push);
  var EOF = -1;
  var TEXT = 1;
  var TAG = 2;
  var ENDTAG = 3;
  var COMMENT = 4;
  var DOCTYPE = 5;
  var NOATTRS = [];
  var quirkyPublicIds = /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i;
  var quirkySystemId = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
  var conditionallyQuirkyPublicIds = /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i;
  var limitedQuirkyPublicIds = /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i;
  var specialSet = Object.create(null);
  specialSet[NAMESPACE.HTML] = {
    __proto__: null,
    address: true,
    applet: true,
    area: true,
    article: true,
    aside: true,
    base: true,
    basefont: true,
    bgsound: true,
    blockquote: true,
    body: true,
    br: true,
    button: true,
    caption: true,
    center: true,
    col: true,
    colgroup: true,
    dd: true,
    details: true,
    dir: true,
    div: true,
    dl: true,
    dt: true,
    embed: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    frame: true,
    frameset: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    head: true,
    header: true,
    hgroup: true,
    hr: true,
    html: true,
    iframe: true,
    img: true,
    input: true,
    li: true,
    link: true,
    listing: true,
    main: true,
    marquee: true,
    menu: true,
    meta: true,
    nav: true,
    noembed: true,
    noframes: true,
    noscript: true,
    object: true,
    ol: true,
    p: true,
    param: true,
    plaintext: true,
    pre: true,
    script: true,
    section: true,
    select: true,
    source: true,
    style: true,
    summary: true,
    table: true,
    tbody: true,
    td: true,
    template: true,
    textarea: true,
    tfoot: true,
    th: true,
    thead: true,
    title: true,
    tr: true,
    track: true,
    ul: true,
    wbr: true,
    xmp: true
  };
  specialSet[NAMESPACE.SVG] = {
    __proto__: null,
    foreignObject: true,
    desc: true,
    title: true
  };
  specialSet[NAMESPACE.MATHML] = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true,
    "annotation-xml": true
  };
  var addressdivpSet = Object.create(null);
  addressdivpSet[NAMESPACE.HTML] = {
    __proto__: null,
    address: true,
    div: true,
    p: true
  };
  var dddtSet = Object.create(null);
  dddtSet[NAMESPACE.HTML] = {
    __proto__: null,
    dd: true,
    dt: true
  };
  var tablesectionrowSet = Object.create(null);
  tablesectionrowSet[NAMESPACE.HTML] = {
    __proto__: null,
    table: true,
    thead: true,
    tbody: true,
    tfoot: true,
    tr: true
  };
  var impliedEndTagsSet = Object.create(null);
  impliedEndTagsSet[NAMESPACE.HTML] = {
    __proto__: null,
    dd: true,
    dt: true,
    li: true,
    menuitem: true,
    optgroup: true,
    option: true,
    p: true,
    rb: true,
    rp: true,
    rt: true,
    rtc: true
  };
  var thoroughImpliedEndTagsSet = Object.create(null);
  thoroughImpliedEndTagsSet[NAMESPACE.HTML] = {
    __proto__: null,
    caption: true,
    colgroup: true,
    dd: true,
    dt: true,
    li: true,
    optgroup: true,
    option: true,
    p: true,
    rb: true,
    rp: true,
    rt: true,
    rtc: true,
    tbody: true,
    td: true,
    tfoot: true,
    th: true,
    thead: true,
    tr: true
  };
  var tableContextSet = Object.create(null);
  tableContextSet[NAMESPACE.HTML] = {
    __proto__: null,
    table: true,
    template: true,
    html: true
  };
  var tableBodyContextSet = Object.create(null);
  tableBodyContextSet[NAMESPACE.HTML] = {
    __proto__: null,
    tbody: true,
    tfoot: true,
    thead: true,
    template: true,
    html: true
  };
  var tableRowContextSet = Object.create(null);
  tableRowContextSet[NAMESPACE.HTML] = {
    __proto__: null,
    tr: true,
    template: true,
    html: true
  };
  var formassociatedSet = Object.create(null);
  formassociatedSet[NAMESPACE.HTML] = {
    __proto__: null,
    button: true,
    fieldset: true,
    input: true,
    keygen: true,
    object: true,
    output: true,
    select: true,
    textarea: true,
    img: true
  };
  var inScopeSet = Object.create(null);
  inScopeSet[NAMESPACE.HTML] = {
    __proto__: null,
    applet: true,
    caption: true,
    html: true,
    table: true,
    td: true,
    th: true,
    marquee: true,
    object: true,
    template: true
  };
  inScopeSet[NAMESPACE.MATHML] = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true,
    "annotation-xml": true
  };
  inScopeSet[NAMESPACE.SVG] = {
    __proto__: null,
    foreignObject: true,
    desc: true,
    title: true
  };
  var inListItemScopeSet = Object.create(inScopeSet);
  inListItemScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
  inListItemScopeSet[NAMESPACE.HTML].ol = true;
  inListItemScopeSet[NAMESPACE.HTML].ul = true;
  var inButtonScopeSet = Object.create(inScopeSet);
  inButtonScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
  inButtonScopeSet[NAMESPACE.HTML].button = true;
  var inTableScopeSet = Object.create(null);
  inTableScopeSet[NAMESPACE.HTML] = {
    __proto__: null,
    html: true,
    table: true,
    template: true
  };
  var invertedSelectScopeSet = Object.create(null);
  invertedSelectScopeSet[NAMESPACE.HTML] = {
    __proto__: null,
    optgroup: true,
    option: true
  };
  var mathmlTextIntegrationPointSet = Object.create(null);
  mathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true
  };
  var htmlIntegrationPointSet = Object.create(null);
  htmlIntegrationPointSet[NAMESPACE.SVG] = {
    __proto__: null,
    foreignObject: true,
    desc: true,
    title: true
  };
  var foreignAttributes = {
    __proto__: null,
    "xlink:actuate": NAMESPACE.XLINK,
    "xlink:arcrole": NAMESPACE.XLINK,
    "xlink:href": NAMESPACE.XLINK,
    "xlink:role": NAMESPACE.XLINK,
    "xlink:show": NAMESPACE.XLINK,
    "xlink:title": NAMESPACE.XLINK,
    "xlink:type": NAMESPACE.XLINK,
    "xml:base": NAMESPACE.XML,
    "xml:lang": NAMESPACE.XML,
    "xml:space": NAMESPACE.XML,
    xmlns: NAMESPACE.XMLNS,
    "xmlns:xlink": NAMESPACE.XMLNS
  };
  var svgAttrAdjustments = {
    __proto__: null,
    attributename: "attributeName",
    attributetype: "attributeType",
    basefrequency: "baseFrequency",
    baseprofile: "baseProfile",
    calcmode: "calcMode",
    clippathunits: "clipPathUnits",
    diffuseconstant: "diffuseConstant",
    edgemode: "edgeMode",
    filterunits: "filterUnits",
    glyphref: "glyphRef",
    gradienttransform: "gradientTransform",
    gradientunits: "gradientUnits",
    kernelmatrix: "kernelMatrix",
    kernelunitlength: "kernelUnitLength",
    keypoints: "keyPoints",
    keysplines: "keySplines",
    keytimes: "keyTimes",
    lengthadjust: "lengthAdjust",
    limitingconeangle: "limitingConeAngle",
    markerheight: "markerHeight",
    markerunits: "markerUnits",
    markerwidth: "markerWidth",
    maskcontentunits: "maskContentUnits",
    maskunits: "maskUnits",
    numoctaves: "numOctaves",
    pathlength: "pathLength",
    patterncontentunits: "patternContentUnits",
    patterntransform: "patternTransform",
    patternunits: "patternUnits",
    pointsatx: "pointsAtX",
    pointsaty: "pointsAtY",
    pointsatz: "pointsAtZ",
    preservealpha: "preserveAlpha",
    preserveaspectratio: "preserveAspectRatio",
    primitiveunits: "primitiveUnits",
    refx: "refX",
    refy: "refY",
    repeatcount: "repeatCount",
    repeatdur: "repeatDur",
    requiredextensions: "requiredExtensions",
    requiredfeatures: "requiredFeatures",
    specularconstant: "specularConstant",
    specularexponent: "specularExponent",
    spreadmethod: "spreadMethod",
    startoffset: "startOffset",
    stddeviation: "stdDeviation",
    stitchtiles: "stitchTiles",
    surfacescale: "surfaceScale",
    systemlanguage: "systemLanguage",
    tablevalues: "tableValues",
    targetx: "targetX",
    targety: "targetY",
    textlength: "textLength",
    viewbox: "viewBox",
    viewtarget: "viewTarget",
    xchannelselector: "xChannelSelector",
    ychannelselector: "yChannelSelector",
    zoomandpan: "zoomAndPan"
  };
  var svgTagNameAdjustments = {
    __proto__: null,
    altglyph: "altGlyph",
    altglyphdef: "altGlyphDef",
    altglyphitem: "altGlyphItem",
    animatecolor: "animateColor",
    animatemotion: "animateMotion",
    animatetransform: "animateTransform",
    clippath: "clipPath",
    feblend: "feBlend",
    fecolormatrix: "feColorMatrix",
    fecomponenttransfer: "feComponentTransfer",
    fecomposite: "feComposite",
    feconvolvematrix: "feConvolveMatrix",
    fediffuselighting: "feDiffuseLighting",
    fedisplacementmap: "feDisplacementMap",
    fedistantlight: "feDistantLight",
    feflood: "feFlood",
    fefunca: "feFuncA",
    fefuncb: "feFuncB",
    fefuncg: "feFuncG",
    fefuncr: "feFuncR",
    fegaussianblur: "feGaussianBlur",
    feimage: "feImage",
    femerge: "feMerge",
    femergenode: "feMergeNode",
    femorphology: "feMorphology",
    feoffset: "feOffset",
    fepointlight: "fePointLight",
    fespecularlighting: "feSpecularLighting",
    fespotlight: "feSpotLight",
    fetile: "feTile",
    feturbulence: "feTurbulence",
    foreignobject: "foreignObject",
    glyphref: "glyphRef",
    lineargradient: "linearGradient",
    radialgradient: "radialGradient",
    textpath: "textPath"
  };
  var numericCharRefReplacements = {
    __proto__: null,
    0: 65533,
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
  };
  var namedCharRefs = {
    __proto__: null,
    AElig: 198,
    "AElig;": 198,
    AMP: 38,
    "AMP;": 38,
    Aacute: 193,
    "Aacute;": 193,
    "Abreve;": 258,
    Acirc: 194,
    "Acirc;": 194,
    "Acy;": 1040,
    "Afr;": [55349, 56580],
    Agrave: 192,
    "Agrave;": 192,
    "Alpha;": 913,
    "Amacr;": 256,
    "And;": 10835,
    "Aogon;": 260,
    "Aopf;": [55349, 56632],
    "ApplyFunction;": 8289,
    Aring: 197,
    "Aring;": 197,
    "Ascr;": [55349, 56476],
    "Assign;": 8788,
    Atilde: 195,
    "Atilde;": 195,
    Auml: 196,
    "Auml;": 196,
    "Backslash;": 8726,
    "Barv;": 10983,
    "Barwed;": 8966,
    "Bcy;": 1041,
    "Because;": 8757,
    "Bernoullis;": 8492,
    "Beta;": 914,
    "Bfr;": [55349, 56581],
    "Bopf;": [55349, 56633],
    "Breve;": 728,
    "Bscr;": 8492,
    "Bumpeq;": 8782,
    "CHcy;": 1063,
    COPY: 169,
    "COPY;": 169,
    "Cacute;": 262,
    "Cap;": 8914,
    "CapitalDifferentialD;": 8517,
    "Cayleys;": 8493,
    "Ccaron;": 268,
    Ccedil: 199,
    "Ccedil;": 199,
    "Ccirc;": 264,
    "Cconint;": 8752,
    "Cdot;": 266,
    "Cedilla;": 184,
    "CenterDot;": 183,
    "Cfr;": 8493,
    "Chi;": 935,
    "CircleDot;": 8857,
    "CircleMinus;": 8854,
    "CirclePlus;": 8853,
    "CircleTimes;": 8855,
    "ClockwiseContourIntegral;": 8754,
    "CloseCurlyDoubleQuote;": 8221,
    "CloseCurlyQuote;": 8217,
    "Colon;": 8759,
    "Colone;": 10868,
    "Congruent;": 8801,
    "Conint;": 8751,
    "ContourIntegral;": 8750,
    "Copf;": 8450,
    "Coproduct;": 8720,
    "CounterClockwiseContourIntegral;": 8755,
    "Cross;": 10799,
    "Cscr;": [55349, 56478],
    "Cup;": 8915,
    "CupCap;": 8781,
    "DD;": 8517,
    "DDotrahd;": 10513,
    "DJcy;": 1026,
    "DScy;": 1029,
    "DZcy;": 1039,
    "Dagger;": 8225,
    "Darr;": 8609,
    "Dashv;": 10980,
    "Dcaron;": 270,
    "Dcy;": 1044,
    "Del;": 8711,
    "Delta;": 916,
    "Dfr;": [55349, 56583],
    "DiacriticalAcute;": 180,
    "DiacriticalDot;": 729,
    "DiacriticalDoubleAcute;": 733,
    "DiacriticalGrave;": 96,
    "DiacriticalTilde;": 732,
    "Diamond;": 8900,
    "DifferentialD;": 8518,
    "Dopf;": [55349, 56635],
    "Dot;": 168,
    "DotDot;": 8412,
    "DotEqual;": 8784,
    "DoubleContourIntegral;": 8751,
    "DoubleDot;": 168,
    "DoubleDownArrow;": 8659,
    "DoubleLeftArrow;": 8656,
    "DoubleLeftRightArrow;": 8660,
    "DoubleLeftTee;": 10980,
    "DoubleLongLeftArrow;": 10232,
    "DoubleLongLeftRightArrow;": 10234,
    "DoubleLongRightArrow;": 10233,
    "DoubleRightArrow;": 8658,
    "DoubleRightTee;": 8872,
    "DoubleUpArrow;": 8657,
    "DoubleUpDownArrow;": 8661,
    "DoubleVerticalBar;": 8741,
    "DownArrow;": 8595,
    "DownArrowBar;": 10515,
    "DownArrowUpArrow;": 8693,
    "DownBreve;": 785,
    "DownLeftRightVector;": 10576,
    "DownLeftTeeVector;": 10590,
    "DownLeftVector;": 8637,
    "DownLeftVectorBar;": 10582,
    "DownRightTeeVector;": 10591,
    "DownRightVector;": 8641,
    "DownRightVectorBar;": 10583,
    "DownTee;": 8868,
    "DownTeeArrow;": 8615,
    "Downarrow;": 8659,
    "Dscr;": [55349, 56479],
    "Dstrok;": 272,
    "ENG;": 330,
    ETH: 208,
    "ETH;": 208,
    Eacute: 201,
    "Eacute;": 201,
    "Ecaron;": 282,
    Ecirc: 202,
    "Ecirc;": 202,
    "Ecy;": 1069,
    "Edot;": 278,
    "Efr;": [55349, 56584],
    Egrave: 200,
    "Egrave;": 200,
    "Element;": 8712,
    "Emacr;": 274,
    "EmptySmallSquare;": 9723,
    "EmptyVerySmallSquare;": 9643,
    "Eogon;": 280,
    "Eopf;": [55349, 56636],
    "Epsilon;": 917,
    "Equal;": 10869,
    "EqualTilde;": 8770,
    "Equilibrium;": 8652,
    "Escr;": 8496,
    "Esim;": 10867,
    "Eta;": 919,
    Euml: 203,
    "Euml;": 203,
    "Exists;": 8707,
    "ExponentialE;": 8519,
    "Fcy;": 1060,
    "Ffr;": [55349, 56585],
    "FilledSmallSquare;": 9724,
    "FilledVerySmallSquare;": 9642,
    "Fopf;": [55349, 56637],
    "ForAll;": 8704,
    "Fouriertrf;": 8497,
    "Fscr;": 8497,
    "GJcy;": 1027,
    GT: 62,
    "GT;": 62,
    "Gamma;": 915,
    "Gammad;": 988,
    "Gbreve;": 286,
    "Gcedil;": 290,
    "Gcirc;": 284,
    "Gcy;": 1043,
    "Gdot;": 288,
    "Gfr;": [55349, 56586],
    "Gg;": 8921,
    "Gopf;": [55349, 56638],
    "GreaterEqual;": 8805,
    "GreaterEqualLess;": 8923,
    "GreaterFullEqual;": 8807,
    "GreaterGreater;": 10914,
    "GreaterLess;": 8823,
    "GreaterSlantEqual;": 10878,
    "GreaterTilde;": 8819,
    "Gscr;": [55349, 56482],
    "Gt;": 8811,
    "HARDcy;": 1066,
    "Hacek;": 711,
    "Hat;": 94,
    "Hcirc;": 292,
    "Hfr;": 8460,
    "HilbertSpace;": 8459,
    "Hopf;": 8461,
    "HorizontalLine;": 9472,
    "Hscr;": 8459,
    "Hstrok;": 294,
    "HumpDownHump;": 8782,
    "HumpEqual;": 8783,
    "IEcy;": 1045,
    "IJlig;": 306,
    "IOcy;": 1025,
    Iacute: 205,
    "Iacute;": 205,
    Icirc: 206,
    "Icirc;": 206,
    "Icy;": 1048,
    "Idot;": 304,
    "Ifr;": 8465,
    Igrave: 204,
    "Igrave;": 204,
    "Im;": 8465,
    "Imacr;": 298,
    "ImaginaryI;": 8520,
    "Implies;": 8658,
    "Int;": 8748,
    "Integral;": 8747,
    "Intersection;": 8898,
    "InvisibleComma;": 8291,
    "InvisibleTimes;": 8290,
    "Iogon;": 302,
    "Iopf;": [55349, 56640],
    "Iota;": 921,
    "Iscr;": 8464,
    "Itilde;": 296,
    "Iukcy;": 1030,
    Iuml: 207,
    "Iuml;": 207,
    "Jcirc;": 308,
    "Jcy;": 1049,
    "Jfr;": [55349, 56589],
    "Jopf;": [55349, 56641],
    "Jscr;": [55349, 56485],
    "Jsercy;": 1032,
    "Jukcy;": 1028,
    "KHcy;": 1061,
    "KJcy;": 1036,
    "Kappa;": 922,
    "Kcedil;": 310,
    "Kcy;": 1050,
    "Kfr;": [55349, 56590],
    "Kopf;": [55349, 56642],
    "Kscr;": [55349, 56486],
    "LJcy;": 1033,
    LT: 60,
    "LT;": 60,
    "Lacute;": 313,
    "Lambda;": 923,
    "Lang;": 10218,
    "Laplacetrf;": 8466,
    "Larr;": 8606,
    "Lcaron;": 317,
    "Lcedil;": 315,
    "Lcy;": 1051,
    "LeftAngleBracket;": 10216,
    "LeftArrow;": 8592,
    "LeftArrowBar;": 8676,
    "LeftArrowRightArrow;": 8646,
    "LeftCeiling;": 8968,
    "LeftDoubleBracket;": 10214,
    "LeftDownTeeVector;": 10593,
    "LeftDownVector;": 8643,
    "LeftDownVectorBar;": 10585,
    "LeftFloor;": 8970,
    "LeftRightArrow;": 8596,
    "LeftRightVector;": 10574,
    "LeftTee;": 8867,
    "LeftTeeArrow;": 8612,
    "LeftTeeVector;": 10586,
    "LeftTriangle;": 8882,
    "LeftTriangleBar;": 10703,
    "LeftTriangleEqual;": 8884,
    "LeftUpDownVector;": 10577,
    "LeftUpTeeVector;": 10592,
    "LeftUpVector;": 8639,
    "LeftUpVectorBar;": 10584,
    "LeftVector;": 8636,
    "LeftVectorBar;": 10578,
    "Leftarrow;": 8656,
    "Leftrightarrow;": 8660,
    "LessEqualGreater;": 8922,
    "LessFullEqual;": 8806,
    "LessGreater;": 8822,
    "LessLess;": 10913,
    "LessSlantEqual;": 10877,
    "LessTilde;": 8818,
    "Lfr;": [55349, 56591],
    "Ll;": 8920,
    "Lleftarrow;": 8666,
    "Lmidot;": 319,
    "LongLeftArrow;": 10229,
    "LongLeftRightArrow;": 10231,
    "LongRightArrow;": 10230,
    "Longleftarrow;": 10232,
    "Longleftrightarrow;": 10234,
    "Longrightarrow;": 10233,
    "Lopf;": [55349, 56643],
    "LowerLeftArrow;": 8601,
    "LowerRightArrow;": 8600,
    "Lscr;": 8466,
    "Lsh;": 8624,
    "Lstrok;": 321,
    "Lt;": 8810,
    "Map;": 10501,
    "Mcy;": 1052,
    "MediumSpace;": 8287,
    "Mellintrf;": 8499,
    "Mfr;": [55349, 56592],
    "MinusPlus;": 8723,
    "Mopf;": [55349, 56644],
    "Mscr;": 8499,
    "Mu;": 924,
    "NJcy;": 1034,
    "Nacute;": 323,
    "Ncaron;": 327,
    "Ncedil;": 325,
    "Ncy;": 1053,
    "NegativeMediumSpace;": 8203,
    "NegativeThickSpace;": 8203,
    "NegativeThinSpace;": 8203,
    "NegativeVeryThinSpace;": 8203,
    "NestedGreaterGreater;": 8811,
    "NestedLessLess;": 8810,
    "NewLine;": 10,
    "Nfr;": [55349, 56593],
    "NoBreak;": 8288,
    "NonBreakingSpace;": 160,
    "Nopf;": 8469,
    "Not;": 10988,
    "NotCongruent;": 8802,
    "NotCupCap;": 8813,
    "NotDoubleVerticalBar;": 8742,
    "NotElement;": 8713,
    "NotEqual;": 8800,
    "NotEqualTilde;": [8770, 824],
    "NotExists;": 8708,
    "NotGreater;": 8815,
    "NotGreaterEqual;": 8817,
    "NotGreaterFullEqual;": [8807, 824],
    "NotGreaterGreater;": [8811, 824],
    "NotGreaterLess;": 8825,
    "NotGreaterSlantEqual;": [10878, 824],
    "NotGreaterTilde;": 8821,
    "NotHumpDownHump;": [8782, 824],
    "NotHumpEqual;": [8783, 824],
    "NotLeftTriangle;": 8938,
    "NotLeftTriangleBar;": [10703, 824],
    "NotLeftTriangleEqual;": 8940,
    "NotLess;": 8814,
    "NotLessEqual;": 8816,
    "NotLessGreater;": 8824,
    "NotLessLess;": [8810, 824],
    "NotLessSlantEqual;": [10877, 824],
    "NotLessTilde;": 8820,
    "NotNestedGreaterGreater;": [10914, 824],
    "NotNestedLessLess;": [10913, 824],
    "NotPrecedes;": 8832,
    "NotPrecedesEqual;": [10927, 824],
    "NotPrecedesSlantEqual;": 8928,
    "NotReverseElement;": 8716,
    "NotRightTriangle;": 8939,
    "NotRightTriangleBar;": [10704, 824],
    "NotRightTriangleEqual;": 8941,
    "NotSquareSubset;": [8847, 824],
    "NotSquareSubsetEqual;": 8930,
    "NotSquareSuperset;": [8848, 824],
    "NotSquareSupersetEqual;": 8931,
    "NotSubset;": [8834, 8402],
    "NotSubsetEqual;": 8840,
    "NotSucceeds;": 8833,
    "NotSucceedsEqual;": [10928, 824],
    "NotSucceedsSlantEqual;": 8929,
    "NotSucceedsTilde;": [8831, 824],
    "NotSuperset;": [8835, 8402],
    "NotSupersetEqual;": 8841,
    "NotTilde;": 8769,
    "NotTildeEqual;": 8772,
    "NotTildeFullEqual;": 8775,
    "NotTildeTilde;": 8777,
    "NotVerticalBar;": 8740,
    "Nscr;": [55349, 56489],
    Ntilde: 209,
    "Ntilde;": 209,
    "Nu;": 925,
    "OElig;": 338,
    Oacute: 211,
    "Oacute;": 211,
    Ocirc: 212,
    "Ocirc;": 212,
    "Ocy;": 1054,
    "Odblac;": 336,
    "Ofr;": [55349, 56594],
    Ograve: 210,
    "Ograve;": 210,
    "Omacr;": 332,
    "Omega;": 937,
    "Omicron;": 927,
    "Oopf;": [55349, 56646],
    "OpenCurlyDoubleQuote;": 8220,
    "OpenCurlyQuote;": 8216,
    "Or;": 10836,
    "Oscr;": [55349, 56490],
    Oslash: 216,
    "Oslash;": 216,
    Otilde: 213,
    "Otilde;": 213,
    "Otimes;": 10807,
    Ouml: 214,
    "Ouml;": 214,
    "OverBar;": 8254,
    "OverBrace;": 9182,
    "OverBracket;": 9140,
    "OverParenthesis;": 9180,
    "PartialD;": 8706,
    "Pcy;": 1055,
    "Pfr;": [55349, 56595],
    "Phi;": 934,
    "Pi;": 928,
    "PlusMinus;": 177,
    "Poincareplane;": 8460,
    "Popf;": 8473,
    "Pr;": 10939,
    "Precedes;": 8826,
    "PrecedesEqual;": 10927,
    "PrecedesSlantEqual;": 8828,
    "PrecedesTilde;": 8830,
    "Prime;": 8243,
    "Product;": 8719,
    "Proportion;": 8759,
    "Proportional;": 8733,
    "Pscr;": [55349, 56491],
    "Psi;": 936,
    QUOT: 34,
    "QUOT;": 34,
    "Qfr;": [55349, 56596],
    "Qopf;": 8474,
    "Qscr;": [55349, 56492],
    "RBarr;": 10512,
    REG: 174,
    "REG;": 174,
    "Racute;": 340,
    "Rang;": 10219,
    "Rarr;": 8608,
    "Rarrtl;": 10518,
    "Rcaron;": 344,
    "Rcedil;": 342,
    "Rcy;": 1056,
    "Re;": 8476,
    "ReverseElement;": 8715,
    "ReverseEquilibrium;": 8651,
    "ReverseUpEquilibrium;": 10607,
    "Rfr;": 8476,
    "Rho;": 929,
    "RightAngleBracket;": 10217,
    "RightArrow;": 8594,
    "RightArrowBar;": 8677,
    "RightArrowLeftArrow;": 8644,
    "RightCeiling;": 8969,
    "RightDoubleBracket;": 10215,
    "RightDownTeeVector;": 10589,
    "RightDownVector;": 8642,
    "RightDownVectorBar;": 10581,
    "RightFloor;": 8971,
    "RightTee;": 8866,
    "RightTeeArrow;": 8614,
    "RightTeeVector;": 10587,
    "RightTriangle;": 8883,
    "RightTriangleBar;": 10704,
    "RightTriangleEqual;": 8885,
    "RightUpDownVector;": 10575,
    "RightUpTeeVector;": 10588,
    "RightUpVector;": 8638,
    "RightUpVectorBar;": 10580,
    "RightVector;": 8640,
    "RightVectorBar;": 10579,
    "Rightarrow;": 8658,
    "Ropf;": 8477,
    "RoundImplies;": 10608,
    "Rrightarrow;": 8667,
    "Rscr;": 8475,
    "Rsh;": 8625,
    "RuleDelayed;": 10740,
    "SHCHcy;": 1065,
    "SHcy;": 1064,
    "SOFTcy;": 1068,
    "Sacute;": 346,
    "Sc;": 10940,
    "Scaron;": 352,
    "Scedil;": 350,
    "Scirc;": 348,
    "Scy;": 1057,
    "Sfr;": [55349, 56598],
    "ShortDownArrow;": 8595,
    "ShortLeftArrow;": 8592,
    "ShortRightArrow;": 8594,
    "ShortUpArrow;": 8593,
    "Sigma;": 931,
    "SmallCircle;": 8728,
    "Sopf;": [55349, 56650],
    "Sqrt;": 8730,
    "Square;": 9633,
    "SquareIntersection;": 8851,
    "SquareSubset;": 8847,
    "SquareSubsetEqual;": 8849,
    "SquareSuperset;": 8848,
    "SquareSupersetEqual;": 8850,
    "SquareUnion;": 8852,
    "Sscr;": [55349, 56494],
    "Star;": 8902,
    "Sub;": 8912,
    "Subset;": 8912,
    "SubsetEqual;": 8838,
    "Succeeds;": 8827,
    "SucceedsEqual;": 10928,
    "SucceedsSlantEqual;": 8829,
    "SucceedsTilde;": 8831,
    "SuchThat;": 8715,
    "Sum;": 8721,
    "Sup;": 8913,
    "Superset;": 8835,
    "SupersetEqual;": 8839,
    "Supset;": 8913,
    THORN: 222,
    "THORN;": 222,
    "TRADE;": 8482,
    "TSHcy;": 1035,
    "TScy;": 1062,
    "Tab;": 9,
    "Tau;": 932,
    "Tcaron;": 356,
    "Tcedil;": 354,
    "Tcy;": 1058,
    "Tfr;": [55349, 56599],
    "Therefore;": 8756,
    "Theta;": 920,
    "ThickSpace;": [8287, 8202],
    "ThinSpace;": 8201,
    "Tilde;": 8764,
    "TildeEqual;": 8771,
    "TildeFullEqual;": 8773,
    "TildeTilde;": 8776,
    "Topf;": [55349, 56651],
    "TripleDot;": 8411,
    "Tscr;": [55349, 56495],
    "Tstrok;": 358,
    Uacute: 218,
    "Uacute;": 218,
    "Uarr;": 8607,
    "Uarrocir;": 10569,
    "Ubrcy;": 1038,
    "Ubreve;": 364,
    Ucirc: 219,
    "Ucirc;": 219,
    "Ucy;": 1059,
    "Udblac;": 368,
    "Ufr;": [55349, 56600],
    Ugrave: 217,
    "Ugrave;": 217,
    "Umacr;": 362,
    "UnderBar;": 95,
    "UnderBrace;": 9183,
    "UnderBracket;": 9141,
    "UnderParenthesis;": 9181,
    "Union;": 8899,
    "UnionPlus;": 8846,
    "Uogon;": 370,
    "Uopf;": [55349, 56652],
    "UpArrow;": 8593,
    "UpArrowBar;": 10514,
    "UpArrowDownArrow;": 8645,
    "UpDownArrow;": 8597,
    "UpEquilibrium;": 10606,
    "UpTee;": 8869,
    "UpTeeArrow;": 8613,
    "Uparrow;": 8657,
    "Updownarrow;": 8661,
    "UpperLeftArrow;": 8598,
    "UpperRightArrow;": 8599,
    "Upsi;": 978,
    "Upsilon;": 933,
    "Uring;": 366,
    "Uscr;": [55349, 56496],
    "Utilde;": 360,
    Uuml: 220,
    "Uuml;": 220,
    "VDash;": 8875,
    "Vbar;": 10987,
    "Vcy;": 1042,
    "Vdash;": 8873,
    "Vdashl;": 10982,
    "Vee;": 8897,
    "Verbar;": 8214,
    "Vert;": 8214,
    "VerticalBar;": 8739,
    "VerticalLine;": 124,
    "VerticalSeparator;": 10072,
    "VerticalTilde;": 8768,
    "VeryThinSpace;": 8202,
    "Vfr;": [55349, 56601],
    "Vopf;": [55349, 56653],
    "Vscr;": [55349, 56497],
    "Vvdash;": 8874,
    "Wcirc;": 372,
    "Wedge;": 8896,
    "Wfr;": [55349, 56602],
    "Wopf;": [55349, 56654],
    "Wscr;": [55349, 56498],
    "Xfr;": [55349, 56603],
    "Xi;": 926,
    "Xopf;": [55349, 56655],
    "Xscr;": [55349, 56499],
    "YAcy;": 1071,
    "YIcy;": 1031,
    "YUcy;": 1070,
    Yacute: 221,
    "Yacute;": 221,
    "Ycirc;": 374,
    "Ycy;": 1067,
    "Yfr;": [55349, 56604],
    "Yopf;": [55349, 56656],
    "Yscr;": [55349, 56500],
    "Yuml;": 376,
    "ZHcy;": 1046,
    "Zacute;": 377,
    "Zcaron;": 381,
    "Zcy;": 1047,
    "Zdot;": 379,
    "ZeroWidthSpace;": 8203,
    "Zeta;": 918,
    "Zfr;": 8488,
    "Zopf;": 8484,
    "Zscr;": [55349, 56501],
    aacute: 225,
    "aacute;": 225,
    "abreve;": 259,
    "ac;": 8766,
    "acE;": [8766, 819],
    "acd;": 8767,
    acirc: 226,
    "acirc;": 226,
    acute: 180,
    "acute;": 180,
    "acy;": 1072,
    aelig: 230,
    "aelig;": 230,
    "af;": 8289,
    "afr;": [55349, 56606],
    agrave: 224,
    "agrave;": 224,
    "alefsym;": 8501,
    "aleph;": 8501,
    "alpha;": 945,
    "amacr;": 257,
    "amalg;": 10815,
    amp: 38,
    "amp;": 38,
    "and;": 8743,
    "andand;": 10837,
    "andd;": 10844,
    "andslope;": 10840,
    "andv;": 10842,
    "ang;": 8736,
    "ange;": 10660,
    "angle;": 8736,
    "angmsd;": 8737,
    "angmsdaa;": 10664,
    "angmsdab;": 10665,
    "angmsdac;": 10666,
    "angmsdad;": 10667,
    "angmsdae;": 10668,
    "angmsdaf;": 10669,
    "angmsdag;": 10670,
    "angmsdah;": 10671,
    "angrt;": 8735,
    "angrtvb;": 8894,
    "angrtvbd;": 10653,
    "angsph;": 8738,
    "angst;": 197,
    "angzarr;": 9084,
    "aogon;": 261,
    "aopf;": [55349, 56658],
    "ap;": 8776,
    "apE;": 10864,
    "apacir;": 10863,
    "ape;": 8778,
    "apid;": 8779,
    "apos;": 39,
    "approx;": 8776,
    "approxeq;": 8778,
    aring: 229,
    "aring;": 229,
    "ascr;": [55349, 56502],
    "ast;": 42,
    "asymp;": 8776,
    "asympeq;": 8781,
    atilde: 227,
    "atilde;": 227,
    auml: 228,
    "auml;": 228,
    "awconint;": 8755,
    "awint;": 10769,
    "bNot;": 10989,
    "backcong;": 8780,
    "backepsilon;": 1014,
    "backprime;": 8245,
    "backsim;": 8765,
    "backsimeq;": 8909,
    "barvee;": 8893,
    "barwed;": 8965,
    "barwedge;": 8965,
    "bbrk;": 9141,
    "bbrktbrk;": 9142,
    "bcong;": 8780,
    "bcy;": 1073,
    "bdquo;": 8222,
    "becaus;": 8757,
    "because;": 8757,
    "bemptyv;": 10672,
    "bepsi;": 1014,
    "bernou;": 8492,
    "beta;": 946,
    "beth;": 8502,
    "between;": 8812,
    "bfr;": [55349, 56607],
    "bigcap;": 8898,
    "bigcirc;": 9711,
    "bigcup;": 8899,
    "bigodot;": 10752,
    "bigoplus;": 10753,
    "bigotimes;": 10754,
    "bigsqcup;": 10758,
    "bigstar;": 9733,
    "bigtriangledown;": 9661,
    "bigtriangleup;": 9651,
    "biguplus;": 10756,
    "bigvee;": 8897,
    "bigwedge;": 8896,
    "bkarow;": 10509,
    "blacklozenge;": 10731,
    "blacksquare;": 9642,
    "blacktriangle;": 9652,
    "blacktriangledown;": 9662,
    "blacktriangleleft;": 9666,
    "blacktriangleright;": 9656,
    "blank;": 9251,
    "blk12;": 9618,
    "blk14;": 9617,
    "blk34;": 9619,
    "block;": 9608,
    "bne;": [61, 8421],
    "bnequiv;": [8801, 8421],
    "bnot;": 8976,
    "bopf;": [55349, 56659],
    "bot;": 8869,
    "bottom;": 8869,
    "bowtie;": 8904,
    "boxDL;": 9559,
    "boxDR;": 9556,
    "boxDl;": 9558,
    "boxDr;": 9555,
    "boxH;": 9552,
    "boxHD;": 9574,
    "boxHU;": 9577,
    "boxHd;": 9572,
    "boxHu;": 9575,
    "boxUL;": 9565,
    "boxUR;": 9562,
    "boxUl;": 9564,
    "boxUr;": 9561,
    "boxV;": 9553,
    "boxVH;": 9580,
    "boxVL;": 9571,
    "boxVR;": 9568,
    "boxVh;": 9579,
    "boxVl;": 9570,
    "boxVr;": 9567,
    "boxbox;": 10697,
    "boxdL;": 9557,
    "boxdR;": 9554,
    "boxdl;": 9488,
    "boxdr;": 9484,
    "boxh;": 9472,
    "boxhD;": 9573,
    "boxhU;": 9576,
    "boxhd;": 9516,
    "boxhu;": 9524,
    "boxminus;": 8863,
    "boxplus;": 8862,
    "boxtimes;": 8864,
    "boxuL;": 9563,
    "boxuR;": 9560,
    "boxul;": 9496,
    "boxur;": 9492,
    "boxv;": 9474,
    "boxvH;": 9578,
    "boxvL;": 9569,
    "boxvR;": 9566,
    "boxvh;": 9532,
    "boxvl;": 9508,
    "boxvr;": 9500,
    "bprime;": 8245,
    "breve;": 728,
    brvbar: 166,
    "brvbar;": 166,
    "bscr;": [55349, 56503],
    "bsemi;": 8271,
    "bsim;": 8765,
    "bsime;": 8909,
    "bsol;": 92,
    "bsolb;": 10693,
    "bsolhsub;": 10184,
    "bull;": 8226,
    "bullet;": 8226,
    "bump;": 8782,
    "bumpE;": 10926,
    "bumpe;": 8783,
    "bumpeq;": 8783,
    "cacute;": 263,
    "cap;": 8745,
    "capand;": 10820,
    "capbrcup;": 10825,
    "capcap;": 10827,
    "capcup;": 10823,
    "capdot;": 10816,
    "caps;": [8745, 65024],
    "caret;": 8257,
    "caron;": 711,
    "ccaps;": 10829,
    "ccaron;": 269,
    ccedil: 231,
    "ccedil;": 231,
    "ccirc;": 265,
    "ccups;": 10828,
    "ccupssm;": 10832,
    "cdot;": 267,
    cedil: 184,
    "cedil;": 184,
    "cemptyv;": 10674,
    cent: 162,
    "cent;": 162,
    "centerdot;": 183,
    "cfr;": [55349, 56608],
    "chcy;": 1095,
    "check;": 10003,
    "checkmark;": 10003,
    "chi;": 967,
    "cir;": 9675,
    "cirE;": 10691,
    "circ;": 710,
    "circeq;": 8791,
    "circlearrowleft;": 8634,
    "circlearrowright;": 8635,
    "circledR;": 174,
    "circledS;": 9416,
    "circledast;": 8859,
    "circledcirc;": 8858,
    "circleddash;": 8861,
    "cire;": 8791,
    "cirfnint;": 10768,
    "cirmid;": 10991,
    "cirscir;": 10690,
    "clubs;": 9827,
    "clubsuit;": 9827,
    "colon;": 58,
    "colone;": 8788,
    "coloneq;": 8788,
    "comma;": 44,
    "commat;": 64,
    "comp;": 8705,
    "compfn;": 8728,
    "complement;": 8705,
    "complexes;": 8450,
    "cong;": 8773,
    "congdot;": 10861,
    "conint;": 8750,
    "copf;": [55349, 56660],
    "coprod;": 8720,
    copy: 169,
    "copy;": 169,
    "copysr;": 8471,
    "crarr;": 8629,
    "cross;": 10007,
    "cscr;": [55349, 56504],
    "csub;": 10959,
    "csube;": 10961,
    "csup;": 10960,
    "csupe;": 10962,
    "ctdot;": 8943,
    "cudarrl;": 10552,
    "cudarrr;": 10549,
    "cuepr;": 8926,
    "cuesc;": 8927,
    "cularr;": 8630,
    "cularrp;": 10557,
    "cup;": 8746,
    "cupbrcap;": 10824,
    "cupcap;": 10822,
    "cupcup;": 10826,
    "cupdot;": 8845,
    "cupor;": 10821,
    "cups;": [8746, 65024],
    "curarr;": 8631,
    "curarrm;": 10556,
    "curlyeqprec;": 8926,
    "curlyeqsucc;": 8927,
    "curlyvee;": 8910,
    "curlywedge;": 8911,
    curren: 164,
    "curren;": 164,
    "curvearrowleft;": 8630,
    "curvearrowright;": 8631,
    "cuvee;": 8910,
    "cuwed;": 8911,
    "cwconint;": 8754,
    "cwint;": 8753,
    "cylcty;": 9005,
    "dArr;": 8659,
    "dHar;": 10597,
    "dagger;": 8224,
    "daleth;": 8504,
    "darr;": 8595,
    "dash;": 8208,
    "dashv;": 8867,
    "dbkarow;": 10511,
    "dblac;": 733,
    "dcaron;": 271,
    "dcy;": 1076,
    "dd;": 8518,
    "ddagger;": 8225,
    "ddarr;": 8650,
    "ddotseq;": 10871,
    deg: 176,
    "deg;": 176,
    "delta;": 948,
    "demptyv;": 10673,
    "dfisht;": 10623,
    "dfr;": [55349, 56609],
    "dharl;": 8643,
    "dharr;": 8642,
    "diam;": 8900,
    "diamond;": 8900,
    "diamondsuit;": 9830,
    "diams;": 9830,
    "die;": 168,
    "digamma;": 989,
    "disin;": 8946,
    "div;": 247,
    divide: 247,
    "divide;": 247,
    "divideontimes;": 8903,
    "divonx;": 8903,
    "djcy;": 1106,
    "dlcorn;": 8990,
    "dlcrop;": 8973,
    "dollar;": 36,
    "dopf;": [55349, 56661],
    "dot;": 729,
    "doteq;": 8784,
    "doteqdot;": 8785,
    "dotminus;": 8760,
    "dotplus;": 8724,
    "dotsquare;": 8865,
    "doublebarwedge;": 8966,
    "downarrow;": 8595,
    "downdownarrows;": 8650,
    "downharpoonleft;": 8643,
    "downharpoonright;": 8642,
    "drbkarow;": 10512,
    "drcorn;": 8991,
    "drcrop;": 8972,
    "dscr;": [55349, 56505],
    "dscy;": 1109,
    "dsol;": 10742,
    "dstrok;": 273,
    "dtdot;": 8945,
    "dtri;": 9663,
    "dtrif;": 9662,
    "duarr;": 8693,
    "duhar;": 10607,
    "dwangle;": 10662,
    "dzcy;": 1119,
    "dzigrarr;": 10239,
    "eDDot;": 10871,
    "eDot;": 8785,
    eacute: 233,
    "eacute;": 233,
    "easter;": 10862,
    "ecaron;": 283,
    "ecir;": 8790,
    ecirc: 234,
    "ecirc;": 234,
    "ecolon;": 8789,
    "ecy;": 1101,
    "edot;": 279,
    "ee;": 8519,
    "efDot;": 8786,
    "efr;": [55349, 56610],
    "eg;": 10906,
    egrave: 232,
    "egrave;": 232,
    "egs;": 10902,
    "egsdot;": 10904,
    "el;": 10905,
    "elinters;": 9191,
    "ell;": 8467,
    "els;": 10901,
    "elsdot;": 10903,
    "emacr;": 275,
    "empty;": 8709,
    "emptyset;": 8709,
    "emptyv;": 8709,
    "emsp13;": 8196,
    "emsp14;": 8197,
    "emsp;": 8195,
    "eng;": 331,
    "ensp;": 8194,
    "eogon;": 281,
    "eopf;": [55349, 56662],
    "epar;": 8917,
    "eparsl;": 10723,
    "eplus;": 10865,
    "epsi;": 949,
    "epsilon;": 949,
    "epsiv;": 1013,
    "eqcirc;": 8790,
    "eqcolon;": 8789,
    "eqsim;": 8770,
    "eqslantgtr;": 10902,
    "eqslantless;": 10901,
    "equals;": 61,
    "equest;": 8799,
    "equiv;": 8801,
    "equivDD;": 10872,
    "eqvparsl;": 10725,
    "erDot;": 8787,
    "erarr;": 10609,
    "escr;": 8495,
    "esdot;": 8784,
    "esim;": 8770,
    "eta;": 951,
    eth: 240,
    "eth;": 240,
    euml: 235,
    "euml;": 235,
    "euro;": 8364,
    "excl;": 33,
    "exist;": 8707,
    "expectation;": 8496,
    "exponentiale;": 8519,
    "fallingdotseq;": 8786,
    "fcy;": 1092,
    "female;": 9792,
    "ffilig;": 64259,
    "fflig;": 64256,
    "ffllig;": 64260,
    "ffr;": [55349, 56611],
    "filig;": 64257,
    "fjlig;": [102, 106],
    "flat;": 9837,
    "fllig;": 64258,
    "fltns;": 9649,
    "fnof;": 402,
    "fopf;": [55349, 56663],
    "forall;": 8704,
    "fork;": 8916,
    "forkv;": 10969,
    "fpartint;": 10765,
    frac12: 189,
    "frac12;": 189,
    "frac13;": 8531,
    frac14: 188,
    "frac14;": 188,
    "frac15;": 8533,
    "frac16;": 8537,
    "frac18;": 8539,
    "frac23;": 8532,
    "frac25;": 8534,
    frac34: 190,
    "frac34;": 190,
    "frac35;": 8535,
    "frac38;": 8540,
    "frac45;": 8536,
    "frac56;": 8538,
    "frac58;": 8541,
    "frac78;": 8542,
    "frasl;": 8260,
    "frown;": 8994,
    "fscr;": [55349, 56507],
    "gE;": 8807,
    "gEl;": 10892,
    "gacute;": 501,
    "gamma;": 947,
    "gammad;": 989,
    "gap;": 10886,
    "gbreve;": 287,
    "gcirc;": 285,
    "gcy;": 1075,
    "gdot;": 289,
    "ge;": 8805,
    "gel;": 8923,
    "geq;": 8805,
    "geqq;": 8807,
    "geqslant;": 10878,
    "ges;": 10878,
    "gescc;": 10921,
    "gesdot;": 10880,
    "gesdoto;": 10882,
    "gesdotol;": 10884,
    "gesl;": [8923, 65024],
    "gesles;": 10900,
    "gfr;": [55349, 56612],
    "gg;": 8811,
    "ggg;": 8921,
    "gimel;": 8503,
    "gjcy;": 1107,
    "gl;": 8823,
    "glE;": 10898,
    "gla;": 10917,
    "glj;": 10916,
    "gnE;": 8809,
    "gnap;": 10890,
    "gnapprox;": 10890,
    "gne;": 10888,
    "gneq;": 10888,
    "gneqq;": 8809,
    "gnsim;": 8935,
    "gopf;": [55349, 56664],
    "grave;": 96,
    "gscr;": 8458,
    "gsim;": 8819,
    "gsime;": 10894,
    "gsiml;": 10896,
    gt: 62,
    "gt;": 62,
    "gtcc;": 10919,
    "gtcir;": 10874,
    "gtdot;": 8919,
    "gtlPar;": 10645,
    "gtquest;": 10876,
    "gtrapprox;": 10886,
    "gtrarr;": 10616,
    "gtrdot;": 8919,
    "gtreqless;": 8923,
    "gtreqqless;": 10892,
    "gtrless;": 8823,
    "gtrsim;": 8819,
    "gvertneqq;": [8809, 65024],
    "gvnE;": [8809, 65024],
    "hArr;": 8660,
    "hairsp;": 8202,
    "half;": 189,
    "hamilt;": 8459,
    "hardcy;": 1098,
    "harr;": 8596,
    "harrcir;": 10568,
    "harrw;": 8621,
    "hbar;": 8463,
    "hcirc;": 293,
    "hearts;": 9829,
    "heartsuit;": 9829,
    "hellip;": 8230,
    "hercon;": 8889,
    "hfr;": [55349, 56613],
    "hksearow;": 10533,
    "hkswarow;": 10534,
    "hoarr;": 8703,
    "homtht;": 8763,
    "hookleftarrow;": 8617,
    "hookrightarrow;": 8618,
    "hopf;": [55349, 56665],
    "horbar;": 8213,
    "hscr;": [55349, 56509],
    "hslash;": 8463,
    "hstrok;": 295,
    "hybull;": 8259,
    "hyphen;": 8208,
    iacute: 237,
    "iacute;": 237,
    "ic;": 8291,
    icirc: 238,
    "icirc;": 238,
    "icy;": 1080,
    "iecy;": 1077,
    iexcl: 161,
    "iexcl;": 161,
    "iff;": 8660,
    "ifr;": [55349, 56614],
    igrave: 236,
    "igrave;": 236,
    "ii;": 8520,
    "iiiint;": 10764,
    "iiint;": 8749,
    "iinfin;": 10716,
    "iiota;": 8489,
    "ijlig;": 307,
    "imacr;": 299,
    "image;": 8465,
    "imagline;": 8464,
    "imagpart;": 8465,
    "imath;": 305,
    "imof;": 8887,
    "imped;": 437,
    "in;": 8712,
    "incare;": 8453,
    "infin;": 8734,
    "infintie;": 10717,
    "inodot;": 305,
    "int;": 8747,
    "intcal;": 8890,
    "integers;": 8484,
    "intercal;": 8890,
    "intlarhk;": 10775,
    "intprod;": 10812,
    "iocy;": 1105,
    "iogon;": 303,
    "iopf;": [55349, 56666],
    "iota;": 953,
    "iprod;": 10812,
    iquest: 191,
    "iquest;": 191,
    "iscr;": [55349, 56510],
    "isin;": 8712,
    "isinE;": 8953,
    "isindot;": 8949,
    "isins;": 8948,
    "isinsv;": 8947,
    "isinv;": 8712,
    "it;": 8290,
    "itilde;": 297,
    "iukcy;": 1110,
    iuml: 239,
    "iuml;": 239,
    "jcirc;": 309,
    "jcy;": 1081,
    "jfr;": [55349, 56615],
    "jmath;": 567,
    "jopf;": [55349, 56667],
    "jscr;": [55349, 56511],
    "jsercy;": 1112,
    "jukcy;": 1108,
    "kappa;": 954,
    "kappav;": 1008,
    "kcedil;": 311,
    "kcy;": 1082,
    "kfr;": [55349, 56616],
    "kgreen;": 312,
    "khcy;": 1093,
    "kjcy;": 1116,
    "kopf;": [55349, 56668],
    "kscr;": [55349, 56512],
    "lAarr;": 8666,
    "lArr;": 8656,
    "lAtail;": 10523,
    "lBarr;": 10510,
    "lE;": 8806,
    "lEg;": 10891,
    "lHar;": 10594,
    "lacute;": 314,
    "laemptyv;": 10676,
    "lagran;": 8466,
    "lambda;": 955,
    "lang;": 10216,
    "langd;": 10641,
    "langle;": 10216,
    "lap;": 10885,
    laquo: 171,
    "laquo;": 171,
    "larr;": 8592,
    "larrb;": 8676,
    "larrbfs;": 10527,
    "larrfs;": 10525,
    "larrhk;": 8617,
    "larrlp;": 8619,
    "larrpl;": 10553,
    "larrsim;": 10611,
    "larrtl;": 8610,
    "lat;": 10923,
    "latail;": 10521,
    "late;": 10925,
    "lates;": [10925, 65024],
    "lbarr;": 10508,
    "lbbrk;": 10098,
    "lbrace;": 123,
    "lbrack;": 91,
    "lbrke;": 10635,
    "lbrksld;": 10639,
    "lbrkslu;": 10637,
    "lcaron;": 318,
    "lcedil;": 316,
    "lceil;": 8968,
    "lcub;": 123,
    "lcy;": 1083,
    "ldca;": 10550,
    "ldquo;": 8220,
    "ldquor;": 8222,
    "ldrdhar;": 10599,
    "ldrushar;": 10571,
    "ldsh;": 8626,
    "le;": 8804,
    "leftarrow;": 8592,
    "leftarrowtail;": 8610,
    "leftharpoondown;": 8637,
    "leftharpoonup;": 8636,
    "leftleftarrows;": 8647,
    "leftrightarrow;": 8596,
    "leftrightarrows;": 8646,
    "leftrightharpoons;": 8651,
    "leftrightsquigarrow;": 8621,
    "leftthreetimes;": 8907,
    "leg;": 8922,
    "leq;": 8804,
    "leqq;": 8806,
    "leqslant;": 10877,
    "les;": 10877,
    "lescc;": 10920,
    "lesdot;": 10879,
    "lesdoto;": 10881,
    "lesdotor;": 10883,
    "lesg;": [8922, 65024],
    "lesges;": 10899,
    "lessapprox;": 10885,
    "lessdot;": 8918,
    "lesseqgtr;": 8922,
    "lesseqqgtr;": 10891,
    "lessgtr;": 8822,
    "lesssim;": 8818,
    "lfisht;": 10620,
    "lfloor;": 8970,
    "lfr;": [55349, 56617],
    "lg;": 8822,
    "lgE;": 10897,
    "lhard;": 8637,
    "lharu;": 8636,
    "lharul;": 10602,
    "lhblk;": 9604,
    "ljcy;": 1113,
    "ll;": 8810,
    "llarr;": 8647,
    "llcorner;": 8990,
    "llhard;": 10603,
    "lltri;": 9722,
    "lmidot;": 320,
    "lmoust;": 9136,
    "lmoustache;": 9136,
    "lnE;": 8808,
    "lnap;": 10889,
    "lnapprox;": 10889,
    "lne;": 10887,
    "lneq;": 10887,
    "lneqq;": 8808,
    "lnsim;": 8934,
    "loang;": 10220,
    "loarr;": 8701,
    "lobrk;": 10214,
    "longleftarrow;": 10229,
    "longleftrightarrow;": 10231,
    "longmapsto;": 10236,
    "longrightarrow;": 10230,
    "looparrowleft;": 8619,
    "looparrowright;": 8620,
    "lopar;": 10629,
    "lopf;": [55349, 56669],
    "loplus;": 10797,
    "lotimes;": 10804,
    "lowast;": 8727,
    "lowbar;": 95,
    "loz;": 9674,
    "lozenge;": 9674,
    "lozf;": 10731,
    "lpar;": 40,
    "lparlt;": 10643,
    "lrarr;": 8646,
    "lrcorner;": 8991,
    "lrhar;": 8651,
    "lrhard;": 10605,
    "lrm;": 8206,
    "lrtri;": 8895,
    "lsaquo;": 8249,
    "lscr;": [55349, 56513],
    "lsh;": 8624,
    "lsim;": 8818,
    "lsime;": 10893,
    "lsimg;": 10895,
    "lsqb;": 91,
    "lsquo;": 8216,
    "lsquor;": 8218,
    "lstrok;": 322,
    lt: 60,
    "lt;": 60,
    "ltcc;": 10918,
    "ltcir;": 10873,
    "ltdot;": 8918,
    "lthree;": 8907,
    "ltimes;": 8905,
    "ltlarr;": 10614,
    "ltquest;": 10875,
    "ltrPar;": 10646,
    "ltri;": 9667,
    "ltrie;": 8884,
    "ltrif;": 9666,
    "lurdshar;": 10570,
    "luruhar;": 10598,
    "lvertneqq;": [8808, 65024],
    "lvnE;": [8808, 65024],
    "mDDot;": 8762,
    macr: 175,
    "macr;": 175,
    "male;": 9794,
    "malt;": 10016,
    "maltese;": 10016,
    "map;": 8614,
    "mapsto;": 8614,
    "mapstodown;": 8615,
    "mapstoleft;": 8612,
    "mapstoup;": 8613,
    "marker;": 9646,
    "mcomma;": 10793,
    "mcy;": 1084,
    "mdash;": 8212,
    "measuredangle;": 8737,
    "mfr;": [55349, 56618],
    "mho;": 8487,
    micro: 181,
    "micro;": 181,
    "mid;": 8739,
    "midast;": 42,
    "midcir;": 10992,
    middot: 183,
    "middot;": 183,
    "minus;": 8722,
    "minusb;": 8863,
    "minusd;": 8760,
    "minusdu;": 10794,
    "mlcp;": 10971,
    "mldr;": 8230,
    "mnplus;": 8723,
    "models;": 8871,
    "mopf;": [55349, 56670],
    "mp;": 8723,
    "mscr;": [55349, 56514],
    "mstpos;": 8766,
    "mu;": 956,
    "multimap;": 8888,
    "mumap;": 8888,
    "nGg;": [8921, 824],
    "nGt;": [8811, 8402],
    "nGtv;": [8811, 824],
    "nLeftarrow;": 8653,
    "nLeftrightarrow;": 8654,
    "nLl;": [8920, 824],
    "nLt;": [8810, 8402],
    "nLtv;": [8810, 824],
    "nRightarrow;": 8655,
    "nVDash;": 8879,
    "nVdash;": 8878,
    "nabla;": 8711,
    "nacute;": 324,
    "nang;": [8736, 8402],
    "nap;": 8777,
    "napE;": [10864, 824],
    "napid;": [8779, 824],
    "napos;": 329,
    "napprox;": 8777,
    "natur;": 9838,
    "natural;": 9838,
    "naturals;": 8469,
    nbsp: 160,
    "nbsp;": 160,
    "nbump;": [8782, 824],
    "nbumpe;": [8783, 824],
    "ncap;": 10819,
    "ncaron;": 328,
    "ncedil;": 326,
    "ncong;": 8775,
    "ncongdot;": [10861, 824],
    "ncup;": 10818,
    "ncy;": 1085,
    "ndash;": 8211,
    "ne;": 8800,
    "neArr;": 8663,
    "nearhk;": 10532,
    "nearr;": 8599,
    "nearrow;": 8599,
    "nedot;": [8784, 824],
    "nequiv;": 8802,
    "nesear;": 10536,
    "nesim;": [8770, 824],
    "nexist;": 8708,
    "nexists;": 8708,
    "nfr;": [55349, 56619],
    "ngE;": [8807, 824],
    "nge;": 8817,
    "ngeq;": 8817,
    "ngeqq;": [8807, 824],
    "ngeqslant;": [10878, 824],
    "nges;": [10878, 824],
    "ngsim;": 8821,
    "ngt;": 8815,
    "ngtr;": 8815,
    "nhArr;": 8654,
    "nharr;": 8622,
    "nhpar;": 10994,
    "ni;": 8715,
    "nis;": 8956,
    "nisd;": 8954,
    "niv;": 8715,
    "njcy;": 1114,
    "nlArr;": 8653,
    "nlE;": [8806, 824],
    "nlarr;": 8602,
    "nldr;": 8229,
    "nle;": 8816,
    "nleftarrow;": 8602,
    "nleftrightarrow;": 8622,
    "nleq;": 8816,
    "nleqq;": [8806, 824],
    "nleqslant;": [10877, 824],
    "nles;": [10877, 824],
    "nless;": 8814,
    "nlsim;": 8820,
    "nlt;": 8814,
    "nltri;": 8938,
    "nltrie;": 8940,
    "nmid;": 8740,
    "nopf;": [55349, 56671],
    not: 172,
    "not;": 172,
    "notin;": 8713,
    "notinE;": [8953, 824],
    "notindot;": [8949, 824],
    "notinva;": 8713,
    "notinvb;": 8951,
    "notinvc;": 8950,
    "notni;": 8716,
    "notniva;": 8716,
    "notnivb;": 8958,
    "notnivc;": 8957,
    "npar;": 8742,
    "nparallel;": 8742,
    "nparsl;": [11005, 8421],
    "npart;": [8706, 824],
    "npolint;": 10772,
    "npr;": 8832,
    "nprcue;": 8928,
    "npre;": [10927, 824],
    "nprec;": 8832,
    "npreceq;": [10927, 824],
    "nrArr;": 8655,
    "nrarr;": 8603,
    "nrarrc;": [10547, 824],
    "nrarrw;": [8605, 824],
    "nrightarrow;": 8603,
    "nrtri;": 8939,
    "nrtrie;": 8941,
    "nsc;": 8833,
    "nsccue;": 8929,
    "nsce;": [10928, 824],
    "nscr;": [55349, 56515],
    "nshortmid;": 8740,
    "nshortparallel;": 8742,
    "nsim;": 8769,
    "nsime;": 8772,
    "nsimeq;": 8772,
    "nsmid;": 8740,
    "nspar;": 8742,
    "nsqsube;": 8930,
    "nsqsupe;": 8931,
    "nsub;": 8836,
    "nsubE;": [10949, 824],
    "nsube;": 8840,
    "nsubset;": [8834, 8402],
    "nsubseteq;": 8840,
    "nsubseteqq;": [10949, 824],
    "nsucc;": 8833,
    "nsucceq;": [10928, 824],
    "nsup;": 8837,
    "nsupE;": [10950, 824],
    "nsupe;": 8841,
    "nsupset;": [8835, 8402],
    "nsupseteq;": 8841,
    "nsupseteqq;": [10950, 824],
    "ntgl;": 8825,
    ntilde: 241,
    "ntilde;": 241,
    "ntlg;": 8824,
    "ntriangleleft;": 8938,
    "ntrianglelefteq;": 8940,
    "ntriangleright;": 8939,
    "ntrianglerighteq;": 8941,
    "nu;": 957,
    "num;": 35,
    "numero;": 8470,
    "numsp;": 8199,
    "nvDash;": 8877,
    "nvHarr;": 10500,
    "nvap;": [8781, 8402],
    "nvdash;": 8876,
    "nvge;": [8805, 8402],
    "nvgt;": [62, 8402],
    "nvinfin;": 10718,
    "nvlArr;": 10498,
    "nvle;": [8804, 8402],
    "nvlt;": [60, 8402],
    "nvltrie;": [8884, 8402],
    "nvrArr;": 10499,
    "nvrtrie;": [8885, 8402],
    "nvsim;": [8764, 8402],
    "nwArr;": 8662,
    "nwarhk;": 10531,
    "nwarr;": 8598,
    "nwarrow;": 8598,
    "nwnear;": 10535,
    "oS;": 9416,
    oacute: 243,
    "oacute;": 243,
    "oast;": 8859,
    "ocir;": 8858,
    ocirc: 244,
    "ocirc;": 244,
    "ocy;": 1086,
    "odash;": 8861,
    "odblac;": 337,
    "odiv;": 10808,
    "odot;": 8857,
    "odsold;": 10684,
    "oelig;": 339,
    "ofcir;": 10687,
    "ofr;": [55349, 56620],
    "ogon;": 731,
    ograve: 242,
    "ograve;": 242,
    "ogt;": 10689,
    "ohbar;": 10677,
    "ohm;": 937,
    "oint;": 8750,
    "olarr;": 8634,
    "olcir;": 10686,
    "olcross;": 10683,
    "oline;": 8254,
    "olt;": 10688,
    "omacr;": 333,
    "omega;": 969,
    "omicron;": 959,
    "omid;": 10678,
    "ominus;": 8854,
    "oopf;": [55349, 56672],
    "opar;": 10679,
    "operp;": 10681,
    "oplus;": 8853,
    "or;": 8744,
    "orarr;": 8635,
    "ord;": 10845,
    "order;": 8500,
    "orderof;": 8500,
    ordf: 170,
    "ordf;": 170,
    ordm: 186,
    "ordm;": 186,
    "origof;": 8886,
    "oror;": 10838,
    "orslope;": 10839,
    "orv;": 10843,
    "oscr;": 8500,
    oslash: 248,
    "oslash;": 248,
    "osol;": 8856,
    otilde: 245,
    "otilde;": 245,
    "otimes;": 8855,
    "otimesas;": 10806,
    ouml: 246,
    "ouml;": 246,
    "ovbar;": 9021,
    "par;": 8741,
    para: 182,
    "para;": 182,
    "parallel;": 8741,
    "parsim;": 10995,
    "parsl;": 11005,
    "part;": 8706,
    "pcy;": 1087,
    "percnt;": 37,
    "period;": 46,
    "permil;": 8240,
    "perp;": 8869,
    "pertenk;": 8241,
    "pfr;": [55349, 56621],
    "phi;": 966,
    "phiv;": 981,
    "phmmat;": 8499,
    "phone;": 9742,
    "pi;": 960,
    "pitchfork;": 8916,
    "piv;": 982,
    "planck;": 8463,
    "planckh;": 8462,
    "plankv;": 8463,
    "plus;": 43,
    "plusacir;": 10787,
    "plusb;": 8862,
    "pluscir;": 10786,
    "plusdo;": 8724,
    "plusdu;": 10789,
    "pluse;": 10866,
    plusmn: 177,
    "plusmn;": 177,
    "plussim;": 10790,
    "plustwo;": 10791,
    "pm;": 177,
    "pointint;": 10773,
    "popf;": [55349, 56673],
    pound: 163,
    "pound;": 163,
    "pr;": 8826,
    "prE;": 10931,
    "prap;": 10935,
    "prcue;": 8828,
    "pre;": 10927,
    "prec;": 8826,
    "precapprox;": 10935,
    "preccurlyeq;": 8828,
    "preceq;": 10927,
    "precnapprox;": 10937,
    "precneqq;": 10933,
    "precnsim;": 8936,
    "precsim;": 8830,
    "prime;": 8242,
    "primes;": 8473,
    "prnE;": 10933,
    "prnap;": 10937,
    "prnsim;": 8936,
    "prod;": 8719,
    "profalar;": 9006,
    "profline;": 8978,
    "profsurf;": 8979,
    "prop;": 8733,
    "propto;": 8733,
    "prsim;": 8830,
    "prurel;": 8880,
    "pscr;": [55349, 56517],
    "psi;": 968,
    "puncsp;": 8200,
    "qfr;": [55349, 56622],
    "qint;": 10764,
    "qopf;": [55349, 56674],
    "qprime;": 8279,
    "qscr;": [55349, 56518],
    "quaternions;": 8461,
    "quatint;": 10774,
    "quest;": 63,
    "questeq;": 8799,
    quot: 34,
    "quot;": 34,
    "rAarr;": 8667,
    "rArr;": 8658,
    "rAtail;": 10524,
    "rBarr;": 10511,
    "rHar;": 10596,
    "race;": [8765, 817],
    "racute;": 341,
    "radic;": 8730,
    "raemptyv;": 10675,
    "rang;": 10217,
    "rangd;": 10642,
    "range;": 10661,
    "rangle;": 10217,
    raquo: 187,
    "raquo;": 187,
    "rarr;": 8594,
    "rarrap;": 10613,
    "rarrb;": 8677,
    "rarrbfs;": 10528,
    "rarrc;": 10547,
    "rarrfs;": 10526,
    "rarrhk;": 8618,
    "rarrlp;": 8620,
    "rarrpl;": 10565,
    "rarrsim;": 10612,
    "rarrtl;": 8611,
    "rarrw;": 8605,
    "ratail;": 10522,
    "ratio;": 8758,
    "rationals;": 8474,
    "rbarr;": 10509,
    "rbbrk;": 10099,
    "rbrace;": 125,
    "rbrack;": 93,
    "rbrke;": 10636,
    "rbrksld;": 10638,
    "rbrkslu;": 10640,
    "rcaron;": 345,
    "rcedil;": 343,
    "rceil;": 8969,
    "rcub;": 125,
    "rcy;": 1088,
    "rdca;": 10551,
    "rdldhar;": 10601,
    "rdquo;": 8221,
    "rdquor;": 8221,
    "rdsh;": 8627,
    "real;": 8476,
    "realine;": 8475,
    "realpart;": 8476,
    "reals;": 8477,
    "rect;": 9645,
    reg: 174,
    "reg;": 174,
    "rfisht;": 10621,
    "rfloor;": 8971,
    "rfr;": [55349, 56623],
    "rhard;": 8641,
    "rharu;": 8640,
    "rharul;": 10604,
    "rho;": 961,
    "rhov;": 1009,
    "rightarrow;": 8594,
    "rightarrowtail;": 8611,
    "rightharpoondown;": 8641,
    "rightharpoonup;": 8640,
    "rightleftarrows;": 8644,
    "rightleftharpoons;": 8652,
    "rightrightarrows;": 8649,
    "rightsquigarrow;": 8605,
    "rightthreetimes;": 8908,
    "ring;": 730,
    "risingdotseq;": 8787,
    "rlarr;": 8644,
    "rlhar;": 8652,
    "rlm;": 8207,
    "rmoust;": 9137,
    "rmoustache;": 9137,
    "rnmid;": 10990,
    "roang;": 10221,
    "roarr;": 8702,
    "robrk;": 10215,
    "ropar;": 10630,
    "ropf;": [55349, 56675],
    "roplus;": 10798,
    "rotimes;": 10805,
    "rpar;": 41,
    "rpargt;": 10644,
    "rppolint;": 10770,
    "rrarr;": 8649,
    "rsaquo;": 8250,
    "rscr;": [55349, 56519],
    "rsh;": 8625,
    "rsqb;": 93,
    "rsquo;": 8217,
    "rsquor;": 8217,
    "rthree;": 8908,
    "rtimes;": 8906,
    "rtri;": 9657,
    "rtrie;": 8885,
    "rtrif;": 9656,
    "rtriltri;": 10702,
    "ruluhar;": 10600,
    "rx;": 8478,
    "sacute;": 347,
    "sbquo;": 8218,
    "sc;": 8827,
    "scE;": 10932,
    "scap;": 10936,
    "scaron;": 353,
    "sccue;": 8829,
    "sce;": 10928,
    "scedil;": 351,
    "scirc;": 349,
    "scnE;": 10934,
    "scnap;": 10938,
    "scnsim;": 8937,
    "scpolint;": 10771,
    "scsim;": 8831,
    "scy;": 1089,
    "sdot;": 8901,
    "sdotb;": 8865,
    "sdote;": 10854,
    "seArr;": 8664,
    "searhk;": 10533,
    "searr;": 8600,
    "searrow;": 8600,
    sect: 167,
    "sect;": 167,
    "semi;": 59,
    "seswar;": 10537,
    "setminus;": 8726,
    "setmn;": 8726,
    "sext;": 10038,
    "sfr;": [55349, 56624],
    "sfrown;": 8994,
    "sharp;": 9839,
    "shchcy;": 1097,
    "shcy;": 1096,
    "shortmid;": 8739,
    "shortparallel;": 8741,
    shy: 173,
    "shy;": 173,
    "sigma;": 963,
    "sigmaf;": 962,
    "sigmav;": 962,
    "sim;": 8764,
    "simdot;": 10858,
    "sime;": 8771,
    "simeq;": 8771,
    "simg;": 10910,
    "simgE;": 10912,
    "siml;": 10909,
    "simlE;": 10911,
    "simne;": 8774,
    "simplus;": 10788,
    "simrarr;": 10610,
    "slarr;": 8592,
    "smallsetminus;": 8726,
    "smashp;": 10803,
    "smeparsl;": 10724,
    "smid;": 8739,
    "smile;": 8995,
    "smt;": 10922,
    "smte;": 10924,
    "smtes;": [10924, 65024],
    "softcy;": 1100,
    "sol;": 47,
    "solb;": 10692,
    "solbar;": 9023,
    "sopf;": [55349, 56676],
    "spades;": 9824,
    "spadesuit;": 9824,
    "spar;": 8741,
    "sqcap;": 8851,
    "sqcaps;": [8851, 65024],
    "sqcup;": 8852,
    "sqcups;": [8852, 65024],
    "sqsub;": 8847,
    "sqsube;": 8849,
    "sqsubset;": 8847,
    "sqsubseteq;": 8849,
    "sqsup;": 8848,
    "sqsupe;": 8850,
    "sqsupset;": 8848,
    "sqsupseteq;": 8850,
    "squ;": 9633,
    "square;": 9633,
    "squarf;": 9642,
    "squf;": 9642,
    "srarr;": 8594,
    "sscr;": [55349, 56520],
    "ssetmn;": 8726,
    "ssmile;": 8995,
    "sstarf;": 8902,
    "star;": 9734,
    "starf;": 9733,
    "straightepsilon;": 1013,
    "straightphi;": 981,
    "strns;": 175,
    "sub;": 8834,
    "subE;": 10949,
    "subdot;": 10941,
    "sube;": 8838,
    "subedot;": 10947,
    "submult;": 10945,
    "subnE;": 10955,
    "subne;": 8842,
    "subplus;": 10943,
    "subrarr;": 10617,
    "subset;": 8834,
    "subseteq;": 8838,
    "subseteqq;": 10949,
    "subsetneq;": 8842,
    "subsetneqq;": 10955,
    "subsim;": 10951,
    "subsub;": 10965,
    "subsup;": 10963,
    "succ;": 8827,
    "succapprox;": 10936,
    "succcurlyeq;": 8829,
    "succeq;": 10928,
    "succnapprox;": 10938,
    "succneqq;": 10934,
    "succnsim;": 8937,
    "succsim;": 8831,
    "sum;": 8721,
    "sung;": 9834,
    sup1: 185,
    "sup1;": 185,
    sup2: 178,
    "sup2;": 178,
    sup3: 179,
    "sup3;": 179,
    "sup;": 8835,
    "supE;": 10950,
    "supdot;": 10942,
    "supdsub;": 10968,
    "supe;": 8839,
    "supedot;": 10948,
    "suphsol;": 10185,
    "suphsub;": 10967,
    "suplarr;": 10619,
    "supmult;": 10946,
    "supnE;": 10956,
    "supne;": 8843,
    "supplus;": 10944,
    "supset;": 8835,
    "supseteq;": 8839,
    "supseteqq;": 10950,
    "supsetneq;": 8843,
    "supsetneqq;": 10956,
    "supsim;": 10952,
    "supsub;": 10964,
    "supsup;": 10966,
    "swArr;": 8665,
    "swarhk;": 10534,
    "swarr;": 8601,
    "swarrow;": 8601,
    "swnwar;": 10538,
    szlig: 223,
    "szlig;": 223,
    "target;": 8982,
    "tau;": 964,
    "tbrk;": 9140,
    "tcaron;": 357,
    "tcedil;": 355,
    "tcy;": 1090,
    "tdot;": 8411,
    "telrec;": 8981,
    "tfr;": [55349, 56625],
    "there4;": 8756,
    "therefore;": 8756,
    "theta;": 952,
    "thetasym;": 977,
    "thetav;": 977,
    "thickapprox;": 8776,
    "thicksim;": 8764,
    "thinsp;": 8201,
    "thkap;": 8776,
    "thksim;": 8764,
    thorn: 254,
    "thorn;": 254,
    "tilde;": 732,
    times: 215,
    "times;": 215,
    "timesb;": 8864,
    "timesbar;": 10801,
    "timesd;": 10800,
    "tint;": 8749,
    "toea;": 10536,
    "top;": 8868,
    "topbot;": 9014,
    "topcir;": 10993,
    "topf;": [55349, 56677],
    "topfork;": 10970,
    "tosa;": 10537,
    "tprime;": 8244,
    "trade;": 8482,
    "triangle;": 9653,
    "triangledown;": 9663,
    "triangleleft;": 9667,
    "trianglelefteq;": 8884,
    "triangleq;": 8796,
    "triangleright;": 9657,
    "trianglerighteq;": 8885,
    "tridot;": 9708,
    "trie;": 8796,
    "triminus;": 10810,
    "triplus;": 10809,
    "trisb;": 10701,
    "tritime;": 10811,
    "trpezium;": 9186,
    "tscr;": [55349, 56521],
    "tscy;": 1094,
    "tshcy;": 1115,
    "tstrok;": 359,
    "twixt;": 8812,
    "twoheadleftarrow;": 8606,
    "twoheadrightarrow;": 8608,
    "uArr;": 8657,
    "uHar;": 10595,
    uacute: 250,
    "uacute;": 250,
    "uarr;": 8593,
    "ubrcy;": 1118,
    "ubreve;": 365,
    ucirc: 251,
    "ucirc;": 251,
    "ucy;": 1091,
    "udarr;": 8645,
    "udblac;": 369,
    "udhar;": 10606,
    "ufisht;": 10622,
    "ufr;": [55349, 56626],
    ugrave: 249,
    "ugrave;": 249,
    "uharl;": 8639,
    "uharr;": 8638,
    "uhblk;": 9600,
    "ulcorn;": 8988,
    "ulcorner;": 8988,
    "ulcrop;": 8975,
    "ultri;": 9720,
    "umacr;": 363,
    uml: 168,
    "uml;": 168,
    "uogon;": 371,
    "uopf;": [55349, 56678],
    "uparrow;": 8593,
    "updownarrow;": 8597,
    "upharpoonleft;": 8639,
    "upharpoonright;": 8638,
    "uplus;": 8846,
    "upsi;": 965,
    "upsih;": 978,
    "upsilon;": 965,
    "upuparrows;": 8648,
    "urcorn;": 8989,
    "urcorner;": 8989,
    "urcrop;": 8974,
    "uring;": 367,
    "urtri;": 9721,
    "uscr;": [55349, 56522],
    "utdot;": 8944,
    "utilde;": 361,
    "utri;": 9653,
    "utrif;": 9652,
    "uuarr;": 8648,
    uuml: 252,
    "uuml;": 252,
    "uwangle;": 10663,
    "vArr;": 8661,
    "vBar;": 10984,
    "vBarv;": 10985,
    "vDash;": 8872,
    "vangrt;": 10652,
    "varepsilon;": 1013,
    "varkappa;": 1008,
    "varnothing;": 8709,
    "varphi;": 981,
    "varpi;": 982,
    "varpropto;": 8733,
    "varr;": 8597,
    "varrho;": 1009,
    "varsigma;": 962,
    "varsubsetneq;": [8842, 65024],
    "varsubsetneqq;": [10955, 65024],
    "varsupsetneq;": [8843, 65024],
    "varsupsetneqq;": [10956, 65024],
    "vartheta;": 977,
    "vartriangleleft;": 8882,
    "vartriangleright;": 8883,
    "vcy;": 1074,
    "vdash;": 8866,
    "vee;": 8744,
    "veebar;": 8891,
    "veeeq;": 8794,
    "vellip;": 8942,
    "verbar;": 124,
    "vert;": 124,
    "vfr;": [55349, 56627],
    "vltri;": 8882,
    "vnsub;": [8834, 8402],
    "vnsup;": [8835, 8402],
    "vopf;": [55349, 56679],
    "vprop;": 8733,
    "vrtri;": 8883,
    "vscr;": [55349, 56523],
    "vsubnE;": [10955, 65024],
    "vsubne;": [8842, 65024],
    "vsupnE;": [10956, 65024],
    "vsupne;": [8843, 65024],
    "vzigzag;": 10650,
    "wcirc;": 373,
    "wedbar;": 10847,
    "wedge;": 8743,
    "wedgeq;": 8793,
    "weierp;": 8472,
    "wfr;": [55349, 56628],
    "wopf;": [55349, 56680],
    "wp;": 8472,
    "wr;": 8768,
    "wreath;": 8768,
    "wscr;": [55349, 56524],
    "xcap;": 8898,
    "xcirc;": 9711,
    "xcup;": 8899,
    "xdtri;": 9661,
    "xfr;": [55349, 56629],
    "xhArr;": 10234,
    "xharr;": 10231,
    "xi;": 958,
    "xlArr;": 10232,
    "xlarr;": 10229,
    "xmap;": 10236,
    "xnis;": 8955,
    "xodot;": 10752,
    "xopf;": [55349, 56681],
    "xoplus;": 10753,
    "xotime;": 10754,
    "xrArr;": 10233,
    "xrarr;": 10230,
    "xscr;": [55349, 56525],
    "xsqcup;": 10758,
    "xuplus;": 10756,
    "xutri;": 9651,
    "xvee;": 8897,
    "xwedge;": 8896,
    yacute: 253,
    "yacute;": 253,
    "yacy;": 1103,
    "ycirc;": 375,
    "ycy;": 1099,
    yen: 165,
    "yen;": 165,
    "yfr;": [55349, 56630],
    "yicy;": 1111,
    "yopf;": [55349, 56682],
    "yscr;": [55349, 56526],
    "yucy;": 1102,
    yuml: 255,
    "yuml;": 255,
    "zacute;": 378,
    "zcaron;": 382,
    "zcy;": 1079,
    "zdot;": 380,
    "zeetrf;": 8488,
    "zeta;": 950,
    "zfr;": [55349, 56631],
    "zhcy;": 1078,
    "zigrarr;": 8669,
    "zopf;": [55349, 56683],
    "zscr;": [55349, 56527],
    "zwj;": 8205,
    "zwnj;": 8204
  };
  var NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g;
  var NAMEDCHARREF_MAXLEN = 32;
  var DBLQUOTEATTRVAL = /[^\r"&\u0000]+/g;
  var SINGLEQUOTEATTRVAL = /[^\r'&\u0000]+/g;
  var UNQUOTEDATTRVAL = /[^\r\t\n\f &>\u0000]+/g;
  var TAGNAME = /[^\r\t\n\f \/>A-Z\u0000]+/g;
  var ATTRNAME = /[^\r\t\n\f \/=>A-Z\u0000]+/g;
  var CDATATEXT = /[^\]\r\u0000\uffff]*/g;
  var DATATEXT = /[^&<\r\u0000\uffff]*/g;
  var RAWTEXT = /[^<\r\u0000\uffff]*/g;
  var PLAINTEXT = /[^\r\u0000\uffff]*/g;
  var SIMPLETAG = /(?:(\/)?([a-z]+)>)|[\s\S]/g;
  var SIMPLEATTR = /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g;
  var NONWS = /[^\x09\x0A\x0C\x0D\x20]/;
  var ALLNONWS = /[^\x09\x0A\x0C\x0D\x20]/g;
  var NONWSNONNUL = /[^\x00\x09\x0A\x0C\x0D\x20]/;
  var LEADINGWS = /^[\x09\x0A\x0C\x0D\x20]+/;
  var NULCHARS = /\x00/g;
  function buf2str(buf) {
    var CHUNKSIZE = 16384;
    if (buf.length < CHUNKSIZE) {
      return String.fromCharCode.apply(String, buf);
    }
    var result = "";
    for (var i = 0; i < buf.length; i += CHUNKSIZE) {
      result += String.fromCharCode.apply(String, buf.slice(i, i + CHUNKSIZE));
    }
    return result;
  }
  function str2buf(s) {
    var result = [];
    for (var i = 0; i < s.length; i++) {
      result[i] = s.charCodeAt(i);
    }
    return result;
  }
  function isA(elt, set) {
    if (typeof set === "string") {
      return elt.namespaceURI === NAMESPACE.HTML && elt.localName === set;
    }
    var tagnames = set[elt.namespaceURI];
    return tagnames && tagnames[elt.localName];
  }
  function isMathmlTextIntegrationPoint(n) {
    return isA(n, mathmlTextIntegrationPointSet);
  }
  function isHTMLIntegrationPoint(n) {
    if (isA(n, htmlIntegrationPointSet))
      return true;
    if (n.namespaceURI === NAMESPACE.MATHML && n.localName === "annotation-xml") {
      var encoding = n.getAttribute("encoding");
      if (encoding)
        encoding = encoding.toLowerCase();
      if (encoding === "text/html" || encoding === "application/xhtml+xml")
        return true;
    }
    return false;
  }
  function adjustSVGTagName(name) {
    if (name in svgTagNameAdjustments)
      return svgTagNameAdjustments[name];
    else
      return name;
  }
  function adjustSVGAttributes(attrs) {
    for (var i = 0, n = attrs.length; i < n; i++) {
      if (attrs[i][0] in svgAttrAdjustments) {
        attrs[i][0] = svgAttrAdjustments[attrs[i][0]];
      }
    }
  }
  function adjustMathMLAttributes(attrs) {
    for (var i = 0, n = attrs.length; i < n; i++) {
      if (attrs[i][0] === "definitionurl") {
        attrs[i][0] = "definitionURL";
        break;
      }
    }
  }
  function adjustForeignAttributes(attrs) {
    for (var i = 0, n = attrs.length; i < n; i++) {
      if (attrs[i][0] in foreignAttributes) {
        attrs[i].push(foreignAttributes[attrs[i][0]]);
      }
    }
  }
  function transferAttributes(attrs, elt) {
    for (var i = 0, n = attrs.length; i < n; i++) {
      var name = attrs[i][0], value = attrs[i][1];
      if (elt.hasAttribute(name))
        continue;
      elt._setAttribute(name, value);
    }
  }
  HTMLParser2.ElementStack = function ElementStack() {
    this.elements = [];
    this.top = null;
  };
  HTMLParser2.ElementStack.prototype.push = function(e) {
    this.elements.push(e);
    this.top = e;
  };
  HTMLParser2.ElementStack.prototype.pop = function(e) {
    this.elements.pop();
    this.top = this.elements[this.elements.length - 1];
  };
  HTMLParser2.ElementStack.prototype.popTag = function(tag) {
    for (var i = this.elements.length - 1; i > 0; i--) {
      var e = this.elements[i];
      if (isA(e, tag))
        break;
    }
    this.elements.length = i;
    this.top = this.elements[i - 1];
  };
  HTMLParser2.ElementStack.prototype.popElementType = function(type) {
    for (var i = this.elements.length - 1; i > 0; i--) {
      if (this.elements[i] instanceof type)
        break;
    }
    this.elements.length = i;
    this.top = this.elements[i - 1];
  };
  HTMLParser2.ElementStack.prototype.popElement = function(e) {
    for (var i = this.elements.length - 1; i > 0; i--) {
      if (this.elements[i] === e)
        break;
    }
    this.elements.length = i;
    this.top = this.elements[i - 1];
  };
  HTMLParser2.ElementStack.prototype.removeElement = function(e) {
    if (this.top === e)
      this.pop();
    else {
      var idx = this.elements.lastIndexOf(e);
      if (idx !== -1)
        this.elements.splice(idx, 1);
    }
  };
  HTMLParser2.ElementStack.prototype.clearToContext = function(set) {
    for (var i = this.elements.length - 1; i > 0; i--) {
      if (isA(this.elements[i], set))
        break;
    }
    this.elements.length = i + 1;
    this.top = this.elements[i];
  };
  HTMLParser2.ElementStack.prototype.contains = function(tag) {
    return this.inSpecificScope(tag, Object.create(null));
  };
  HTMLParser2.ElementStack.prototype.inSpecificScope = function(tag, set) {
    for (var i = this.elements.length - 1; i >= 0; i--) {
      var elt = this.elements[i];
      if (isA(elt, tag))
        return true;
      if (isA(elt, set))
        return false;
    }
    return false;
  };
  HTMLParser2.ElementStack.prototype.elementInSpecificScope = function(target, set) {
    for (var i = this.elements.length - 1; i >= 0; i--) {
      var elt = this.elements[i];
      if (elt === target)
        return true;
      if (isA(elt, set))
        return false;
    }
    return false;
  };
  HTMLParser2.ElementStack.prototype.elementTypeInSpecificScope = function(target, set) {
    for (var i = this.elements.length - 1; i >= 0; i--) {
      var elt = this.elements[i];
      if (elt instanceof target)
        return true;
      if (isA(elt, set))
        return false;
    }
    return false;
  };
  HTMLParser2.ElementStack.prototype.inScope = function(tag) {
    return this.inSpecificScope(tag, inScopeSet);
  };
  HTMLParser2.ElementStack.prototype.elementInScope = function(e) {
    return this.elementInSpecificScope(e, inScopeSet);
  };
  HTMLParser2.ElementStack.prototype.elementTypeInScope = function(type) {
    return this.elementTypeInSpecificScope(type, inScopeSet);
  };
  HTMLParser2.ElementStack.prototype.inButtonScope = function(tag) {
    return this.inSpecificScope(tag, inButtonScopeSet);
  };
  HTMLParser2.ElementStack.prototype.inListItemScope = function(tag) {
    return this.inSpecificScope(tag, inListItemScopeSet);
  };
  HTMLParser2.ElementStack.prototype.inTableScope = function(tag) {
    return this.inSpecificScope(tag, inTableScopeSet);
  };
  HTMLParser2.ElementStack.prototype.inSelectScope = function(tag) {
    for (var i = this.elements.length - 1; i >= 0; i--) {
      var elt = this.elements[i];
      if (elt.namespaceURI !== NAMESPACE.HTML)
        return false;
      var localname = elt.localName;
      if (localname === tag)
        return true;
      if (localname !== "optgroup" && localname !== "option")
        return false;
    }
    return false;
  };
  HTMLParser2.ElementStack.prototype.generateImpliedEndTags = function(butnot, thorough) {
    var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;
    for (var i = this.elements.length - 1; i >= 0; i--) {
      var e = this.elements[i];
      if (butnot && isA(e, butnot))
        break;
      if (!isA(this.elements[i], endTagSet))
        break;
    }
    this.elements.length = i + 1;
    this.top = this.elements[i];
  };
  HTMLParser2.ActiveFormattingElements = function AFE() {
    this.list = [];
    this.attrs = [];
  };
  HTMLParser2.ActiveFormattingElements.prototype.MARKER = {localName: "|"};
  HTMLParser2.ActiveFormattingElements.prototype.insertMarker = function() {
    this.list.push(this.MARKER);
    this.attrs.push(this.MARKER);
  };
  HTMLParser2.ActiveFormattingElements.prototype.push = function(elt, attrs) {
    var count = 0;
    for (var i = this.list.length - 1; i >= 0; i--) {
      if (this.list[i] === this.MARKER)
        break;
      if (equal(elt, this.list[i], this.attrs[i])) {
        count++;
        if (count === 3) {
          this.list.splice(i, 1);
          this.attrs.splice(i, 1);
          break;
        }
      }
    }
    this.list.push(elt);
    var attrcopy = [];
    for (var ii = 0; ii < attrs.length; ii++) {
      attrcopy[ii] = attrs[ii];
    }
    this.attrs.push(attrcopy);
    function equal(newelt, oldelt, oldattrs) {
      if (newelt.localName !== oldelt.localName)
        return false;
      if (newelt._numattrs !== oldattrs.length)
        return false;
      for (var i2 = 0, n = oldattrs.length; i2 < n; i2++) {
        var oldname = oldattrs[i2][0];
        var oldval = oldattrs[i2][1];
        if (!newelt.hasAttribute(oldname))
          return false;
        if (newelt.getAttribute(oldname) !== oldval)
          return false;
      }
      return true;
    }
  };
  HTMLParser2.ActiveFormattingElements.prototype.clearToMarker = function() {
    for (var i = this.list.length - 1; i >= 0; i--) {
      if (this.list[i] === this.MARKER)
        break;
    }
    if (i < 0)
      i = 0;
    this.list.length = i;
    this.attrs.length = i;
  };
  HTMLParser2.ActiveFormattingElements.prototype.findElementByTag = function(tag) {
    for (var i = this.list.length - 1; i >= 0; i--) {
      var elt = this.list[i];
      if (elt === this.MARKER)
        break;
      if (elt.localName === tag)
        return elt;
    }
    return null;
  };
  HTMLParser2.ActiveFormattingElements.prototype.indexOf = function(e) {
    return this.list.lastIndexOf(e);
  };
  HTMLParser2.ActiveFormattingElements.prototype.remove = function(e) {
    var idx = this.list.lastIndexOf(e);
    if (idx !== -1) {
      this.list.splice(idx, 1);
      this.attrs.splice(idx, 1);
    }
  };
  HTMLParser2.ActiveFormattingElements.prototype.replace = function(a, b, attrs) {
    var idx = this.list.lastIndexOf(a);
    if (idx !== -1) {
      this.list[idx] = b;
      this.attrs[idx] = attrs;
    }
  };
  HTMLParser2.ActiveFormattingElements.prototype.insertAfter = function(a, b) {
    var idx = this.list.lastIndexOf(a);
    if (idx !== -1) {
      this.list.splice(idx, 0, b);
      this.attrs.splice(idx, 0, b);
    }
  };
  function HTMLParser2(address, fragmentContext, options) {
    var chars = null;
    var numchars = 0;
    var nextchar = 0;
    var input_complete = false;
    var scanner_skip_newline = false;
    var reentrant_invocations = 0;
    var saved_scanner_state = [];
    var leftovers = "";
    var first_batch = true;
    var paused = 0;
    var tokenizer = data_state;
    var return_state;
    var character_reference_code;
    var tagnamebuf = "";
    var lasttagname = "";
    var tempbuf = [];
    var attrnamebuf = "";
    var attrvaluebuf = "";
    var commentbuf = [];
    var doctypenamebuf = [];
    var doctypepublicbuf = [];
    var doctypesystembuf = [];
    var attributes = [];
    var is_end_tag = false;
    var parser = initial_mode;
    var originalInsertionMode = null;
    var templateInsertionModes = [];
    var stack = new HTMLParser2.ElementStack();
    var afe = new HTMLParser2.ActiveFormattingElements();
    var fragment = fragmentContext !== void 0;
    var head_element_pointer = null;
    var form_element_pointer = null;
    var scripting_enabled = true;
    if (fragmentContext) {
      scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;
    }
    if (options && options.scripting_enabled === false)
      scripting_enabled = false;
    var frameset_ok = true;
    var force_quirks = false;
    var pending_table_text;
    var text_integration_mode;
    var textrun = [];
    var textIncludesNUL = false;
    var ignore_linefeed = false;
    var htmlparser = {
      document: function() {
        return doc;
      },
      _asDocumentFragment: function() {
        var frag = doc.createDocumentFragment();
        var root3 = doc.firstChild;
        while (root3.hasChildNodes()) {
          frag.appendChild(root3.firstChild);
        }
        return frag;
      },
      pause: function() {
        paused++;
      },
      resume: function() {
        paused--;
        this.parse("");
      },
      parse: function(s, end, shouldPauseFunc) {
        var moreToDo;
        if (paused > 0) {
          leftovers += s;
          return true;
        }
        if (reentrant_invocations === 0) {
          if (leftovers) {
            s = leftovers + s;
            leftovers = "";
          }
          if (end) {
            s += "\uFFFF";
            input_complete = true;
          }
          chars = s;
          numchars = s.length;
          nextchar = 0;
          if (first_batch) {
            first_batch = false;
            if (chars.charCodeAt(0) === 65279)
              nextchar = 1;
          }
          reentrant_invocations++;
          moreToDo = scanChars(shouldPauseFunc);
          leftovers = chars.substring(nextchar, numchars);
          reentrant_invocations--;
        } else {
          reentrant_invocations++;
          saved_scanner_state.push(chars, numchars, nextchar);
          chars = s;
          numchars = s.length;
          nextchar = 0;
          scanChars();
          moreToDo = false;
          leftovers = chars.substring(nextchar, numchars);
          nextchar = saved_scanner_state.pop();
          numchars = saved_scanner_state.pop();
          chars = saved_scanner_state.pop();
          if (leftovers) {
            chars = leftovers + chars.substring(nextchar);
            numchars = chars.length;
            nextchar = 0;
            leftovers = "";
          }
          reentrant_invocations--;
        }
        return moreToDo;
      }
    };
    var doc = new Document(true, address);
    doc._parser = htmlparser;
    doc._scripting_enabled = scripting_enabled;
    if (fragmentContext) {
      if (fragmentContext.ownerDocument._quirks)
        doc._quirks = true;
      if (fragmentContext.ownerDocument._limitedQuirks)
        doc._limitedQuirks = true;
      if (fragmentContext.namespaceURI === NAMESPACE.HTML) {
        switch (fragmentContext.localName) {
          case "title":
          case "textarea":
            tokenizer = rcdata_state;
            break;
          case "style":
          case "xmp":
          case "iframe":
          case "noembed":
          case "noframes":
          case "script":
          case "plaintext":
            tokenizer = plaintext_state;
            break;
          case "noscript":
            if (scripting_enabled)
              tokenizer = plaintext_state;
        }
      }
      var root2 = doc.createElement("html");
      doc._appendChild(root2);
      stack.push(root2);
      if (fragmentContext instanceof impl.HTMLTemplateElement) {
        templateInsertionModes.push(in_template_mode);
      }
      resetInsertionMode();
      for (var e = fragmentContext; e !== null; e = e.parentElement) {
        if (e instanceof impl.HTMLFormElement) {
          form_element_pointer = e;
          break;
        }
      }
    }
    function scanChars(shouldPauseFunc) {
      var codepoint, s, pattern, eof;
      while (nextchar < numchars) {
        if (paused > 0 || shouldPauseFunc && shouldPauseFunc()) {
          return true;
        }
        switch (typeof tokenizer.lookahead) {
          case "undefined":
            codepoint = chars.charCodeAt(nextchar++);
            if (scanner_skip_newline) {
              scanner_skip_newline = false;
              if (codepoint === 10) {
                nextchar++;
                continue;
              }
            }
            switch (codepoint) {
              case 13:
                if (nextchar < numchars) {
                  if (chars.charCodeAt(nextchar) === 10)
                    nextchar++;
                } else {
                  scanner_skip_newline = true;
                }
                tokenizer(10);
                break;
              case 65535:
                if (input_complete && nextchar === numchars) {
                  tokenizer(EOF);
                  break;
                }
              default:
                tokenizer(codepoint);
                break;
            }
            break;
          case "number":
            codepoint = chars.charCodeAt(nextchar);
            var n = tokenizer.lookahead;
            var needsString = true;
            if (n < 0) {
              needsString = false;
              n = -n;
            }
            if (n < numchars - nextchar) {
              s = needsString ? chars.substring(nextchar, nextchar + n) : null;
              eof = false;
            } else {
              if (input_complete) {
                s = needsString ? chars.substring(nextchar, numchars) : null;
                eof = true;
                if (codepoint === 65535 && nextchar === numchars - 1)
                  codepoint = EOF;
              } else {
                return true;
              }
            }
            tokenizer(codepoint, s, eof);
            break;
          case "string":
            codepoint = chars.charCodeAt(nextchar);
            pattern = tokenizer.lookahead;
            var pos = chars.indexOf(pattern, nextchar);
            if (pos !== -1) {
              s = chars.substring(nextchar, pos + pattern.length);
              eof = false;
            } else {
              if (!input_complete)
                return true;
              s = chars.substring(nextchar, numchars);
              if (codepoint === 65535 && nextchar === numchars - 1)
                codepoint = EOF;
              eof = true;
            }
            tokenizer(codepoint, s, eof);
            break;
        }
      }
      return false;
    }
    function addAttribute(name, value) {
      for (var i = 0; i < attributes.length; i++) {
        if (attributes[i][0] === name)
          return;
      }
      if (value !== void 0) {
        attributes.push([name, value]);
      } else {
        attributes.push([name]);
      }
    }
    function handleSimpleAttribute() {
      SIMPLEATTR.lastIndex = nextchar - 1;
      var matched = SIMPLEATTR.exec(chars);
      if (!matched)
        throw new Error("should never happen");
      var name = matched[1];
      if (!name)
        return false;
      var value = matched[2];
      var len = value.length;
      switch (value[0]) {
        case '"':
        case "'":
          value = value.substring(1, len - 1);
          nextchar += matched[0].length - 1;
          tokenizer = after_attribute_value_quoted_state;
          break;
        default:
          tokenizer = before_attribute_name_state;
          nextchar += matched[0].length - 1;
          value = value.substring(0, len - 1);
          break;
      }
      for (var i = 0; i < attributes.length; i++) {
        if (attributes[i][0] === name)
          return true;
      }
      attributes.push([name, value]);
      return true;
    }
    function beginTagName() {
      is_end_tag = false;
      tagnamebuf = "";
      attributes.length = 0;
    }
    function beginEndTagName() {
      is_end_tag = true;
      tagnamebuf = "";
      attributes.length = 0;
    }
    function beginTempBuf() {
      tempbuf.length = 0;
    }
    function beginAttrName() {
      attrnamebuf = "";
    }
    function beginAttrValue() {
      attrvaluebuf = "";
    }
    function beginComment() {
      commentbuf.length = 0;
    }
    function beginDoctype() {
      doctypenamebuf.length = 0;
      doctypepublicbuf = null;
      doctypesystembuf = null;
    }
    function beginDoctypePublicId() {
      doctypepublicbuf = [];
    }
    function beginDoctypeSystemId() {
      doctypesystembuf = [];
    }
    function forcequirks() {
      force_quirks = true;
    }
    function cdataAllowed() {
      return stack.top && stack.top.namespaceURI !== "http://www.w3.org/1999/xhtml";
    }
    function appropriateEndTag(buf) {
      return lasttagname === buf;
    }
    function flushText() {
      if (textrun.length > 0) {
        var s = buf2str(textrun);
        textrun.length = 0;
        if (ignore_linefeed) {
          ignore_linefeed = false;
          if (s[0] === "\n")
            s = s.substring(1);
          if (s.length === 0)
            return;
        }
        insertToken(TEXT, s);
        textIncludesNUL = false;
      }
      ignore_linefeed = false;
    }
    function getMatchingChars(pattern) {
      pattern.lastIndex = nextchar - 1;
      var match = pattern.exec(chars);
      if (match && match.index === nextchar - 1) {
        match = match[0];
        nextchar += match.length - 1;
        if (input_complete && nextchar === numchars) {
          match = match.slice(0, -1);
          nextchar--;
        }
        return match;
      } else {
        throw new Error("should never happen");
      }
    }
    function emitCharsWhile(pattern) {
      pattern.lastIndex = nextchar - 1;
      var match = pattern.exec(chars)[0];
      if (!match)
        return false;
      emitCharString(match);
      nextchar += match.length - 1;
      return true;
    }
    function emitCharString(s) {
      if (textrun.length > 0)
        flushText();
      if (ignore_linefeed) {
        ignore_linefeed = false;
        if (s[0] === "\n")
          s = s.substring(1);
        if (s.length === 0)
          return;
      }
      insertToken(TEXT, s);
    }
    function emitTag() {
      if (is_end_tag)
        insertToken(ENDTAG, tagnamebuf);
      else {
        var tagname = tagnamebuf;
        tagnamebuf = "";
        lasttagname = tagname;
        insertToken(TAG, tagname, attributes);
      }
    }
    function emitSimpleTag() {
      if (nextchar === numchars) {
        return false;
      }
      SIMPLETAG.lastIndex = nextchar;
      var matched = SIMPLETAG.exec(chars);
      if (!matched)
        throw new Error("should never happen");
      var tagname = matched[2];
      if (!tagname)
        return false;
      var endtag = matched[1];
      if (endtag) {
        nextchar += tagname.length + 2;
        insertToken(ENDTAG, tagname);
      } else {
        nextchar += tagname.length + 1;
        lasttagname = tagname;
        insertToken(TAG, tagname, NOATTRS);
      }
      return true;
    }
    function emitSelfClosingTag() {
      if (is_end_tag)
        insertToken(ENDTAG, tagnamebuf, null, true);
      else {
        insertToken(TAG, tagnamebuf, attributes, true);
      }
    }
    function emitDoctype() {
      insertToken(DOCTYPE, buf2str(doctypenamebuf), doctypepublicbuf ? buf2str(doctypepublicbuf) : void 0, doctypesystembuf ? buf2str(doctypesystembuf) : void 0);
    }
    function emitEOF() {
      flushText();
      parser(EOF);
      doc.modclock = 1;
    }
    var insertToken = htmlparser.insertToken = function insertToken2(t, value, arg3, arg4) {
      flushText();
      var current = stack.top;
      if (!current || current.namespaceURI === NAMESPACE.HTML) {
        parser(t, value, arg3, arg4);
      } else {
        if (t !== TAG && t !== TEXT) {
          insertForeignToken(t, value, arg3, arg4);
        } else {
          if (isMathmlTextIntegrationPoint(current) && (t === TEXT || t === TAG && value !== "mglyph" && value !== "malignmark") || t === TAG && value === "svg" && current.namespaceURI === NAMESPACE.MATHML && current.localName === "annotation-xml" || isHTMLIntegrationPoint(current)) {
            text_integration_mode = true;
            parser(t, value, arg3, arg4);
            text_integration_mode = false;
          } else {
            insertForeignToken(t, value, arg3, arg4);
          }
        }
      }
    };
    function insertComment(data) {
      var parent = stack.top;
      if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
        fosterParent(function(doc2) {
          return doc2.createComment(data);
        });
      } else {
        if (parent instanceof impl.HTMLTemplateElement) {
          parent = parent.content;
        }
        parent._appendChild(parent.ownerDocument.createComment(data));
      }
    }
    function insertText(s) {
      var parent = stack.top;
      if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
        fosterParent(function(doc2) {
          return doc2.createTextNode(s);
        });
      } else {
        if (parent instanceof impl.HTMLTemplateElement) {
          parent = parent.content;
        }
        var lastChild = parent.lastChild;
        if (lastChild && lastChild.nodeType === Node2.TEXT_NODE) {
          lastChild.appendData(s);
        } else {
          parent._appendChild(parent.ownerDocument.createTextNode(s));
        }
      }
    }
    function createHTMLElt(doc2, name, attrs) {
      var elt = html.createElement(doc2, name, null);
      if (attrs) {
        for (var i = 0, n = attrs.length; i < n; i++) {
          elt._setAttribute(attrs[i][0], attrs[i][1]);
        }
      }
      return elt;
    }
    var foster_parent_mode = false;
    function insertHTMLElement(name, attrs) {
      var elt = insertElement(function(doc2) {
        return createHTMLElt(doc2, name, attrs);
      });
      if (isA(elt, formassociatedSet)) {
        elt._form = form_element_pointer;
      }
      return elt;
    }
    function insertElement(eltFunc) {
      var elt;
      if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {
        elt = fosterParent(eltFunc);
      } else if (stack.top instanceof impl.HTMLTemplateElement) {
        elt = eltFunc(stack.top.content.ownerDocument);
        stack.top.content._appendChild(elt);
      } else {
        elt = eltFunc(stack.top.ownerDocument);
        stack.top._appendChild(elt);
      }
      stack.push(elt);
      return elt;
    }
    function insertForeignElement(name, attrs, ns) {
      return insertElement(function(doc2) {
        var elt = doc2._createElementNS(name, ns, null);
        if (attrs) {
          for (var i = 0, n = attrs.length; i < n; i++) {
            var attr = attrs[i];
            if (attr.length === 2)
              elt._setAttribute(attr[0], attr[1]);
            else {
              elt._setAttributeNS(attr[2], attr[0], attr[1]);
            }
          }
        }
        return elt;
      });
    }
    function lastElementOfType(type) {
      for (var i = stack.elements.length - 1; i >= 0; i--) {
        if (stack.elements[i] instanceof type) {
          return i;
        }
      }
      return -1;
    }
    function fosterParent(eltFunc) {
      var parent, before, lastTable = -1, lastTemplate = -1, elt;
      lastTable = lastElementOfType(impl.HTMLTableElement);
      lastTemplate = lastElementOfType(impl.HTMLTemplateElement);
      if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {
        parent = stack.elements[lastTemplate];
      } else if (lastTable >= 0) {
        parent = stack.elements[lastTable].parentNode;
        if (parent) {
          before = stack.elements[lastTable];
        } else {
          parent = stack.elements[lastTable - 1];
        }
      }
      if (!parent)
        parent = stack.elements[0];
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      elt = eltFunc(parent.ownerDocument);
      if (elt.nodeType === Node2.TEXT_NODE) {
        var prev;
        if (before)
          prev = before.previousSibling;
        else
          prev = parent.lastChild;
        if (prev && prev.nodeType === Node2.TEXT_NODE) {
          prev.appendData(elt.data);
          return elt;
        }
      }
      if (before)
        parent.insertBefore(elt, before);
      else
        parent._appendChild(elt);
      return elt;
    }
    function resetInsertionMode() {
      var last = false;
      for (var i = stack.elements.length - 1; i >= 0; i--) {
        var node = stack.elements[i];
        if (i === 0) {
          last = true;
          if (fragment) {
            node = fragmentContext;
          }
        }
        if (node.namespaceURI === NAMESPACE.HTML) {
          var tag = node.localName;
          switch (tag) {
            case "select":
              for (var j = i; j > 0; ) {
                var ancestor = stack.elements[--j];
                if (ancestor instanceof impl.HTMLTemplateElement) {
                  break;
                } else if (ancestor instanceof impl.HTMLTableElement) {
                  parser = in_select_in_table_mode;
                  return;
                }
              }
              parser = in_select_mode;
              return;
            case "tr":
              parser = in_row_mode;
              return;
            case "tbody":
            case "tfoot":
            case "thead":
              parser = in_table_body_mode;
              return;
            case "caption":
              parser = in_caption_mode;
              return;
            case "colgroup":
              parser = in_column_group_mode;
              return;
            case "table":
              parser = in_table_mode;
              return;
            case "template":
              parser = templateInsertionModes[templateInsertionModes.length - 1];
              return;
            case "body":
              parser = in_body_mode;
              return;
            case "frameset":
              parser = in_frameset_mode;
              return;
            case "html":
              if (head_element_pointer === null) {
                parser = before_head_mode;
              } else {
                parser = after_head_mode;
              }
              return;
            default:
              if (!last) {
                if (tag === "head") {
                  parser = in_head_mode;
                  return;
                }
                if (tag === "td" || tag === "th") {
                  parser = in_cell_mode;
                  return;
                }
              }
          }
        }
        if (last) {
          parser = in_body_mode;
          return;
        }
      }
    }
    function parseRawText(name, attrs) {
      insertHTMLElement(name, attrs);
      tokenizer = rawtext_state;
      originalInsertionMode = parser;
      parser = text_mode;
    }
    function parseRCDATA(name, attrs) {
      insertHTMLElement(name, attrs);
      tokenizer = rcdata_state;
      originalInsertionMode = parser;
      parser = text_mode;
    }
    function afeclone(doc2, i) {
      return {
        elt: createHTMLElt(doc2, afe.list[i].localName, afe.attrs[i]),
        attrs: afe.attrs[i]
      };
    }
    function afereconstruct() {
      if (afe.list.length === 0)
        return;
      var entry = afe.list[afe.list.length - 1];
      if (entry === afe.MARKER)
        return;
      if (stack.elements.lastIndexOf(entry) !== -1)
        return;
      for (var i = afe.list.length - 2; i >= 0; i--) {
        entry = afe.list[i];
        if (entry === afe.MARKER)
          break;
        if (stack.elements.lastIndexOf(entry) !== -1)
          break;
      }
      for (i = i + 1; i < afe.list.length; i++) {
        var newelt = insertElement(function(doc2) {
          return afeclone(doc2, i).elt;
        });
        afe.list[i] = newelt;
      }
    }
    var BOOKMARK = {localName: "BM"};
    function adoptionAgency(tag) {
      if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {
        stack.pop();
        return true;
      }
      var outer = 0;
      while (outer < 8) {
        outer++;
        var fmtelt = afe.findElementByTag(tag);
        if (!fmtelt) {
          return false;
        }
        var index = stack.elements.lastIndexOf(fmtelt);
        if (index === -1) {
          afe.remove(fmtelt);
          return true;
        }
        if (!stack.elementInScope(fmtelt)) {
          return true;
        }
        var furthestblock = null, furthestblockindex;
        for (var i = index + 1; i < stack.elements.length; i++) {
          if (isA(stack.elements[i], specialSet)) {
            furthestblock = stack.elements[i];
            furthestblockindex = i;
            break;
          }
        }
        if (!furthestblock) {
          stack.popElement(fmtelt);
          afe.remove(fmtelt);
          return true;
        } else {
          var ancestor = stack.elements[index - 1];
          afe.insertAfter(fmtelt, BOOKMARK);
          var node = furthestblock;
          var lastnode = furthestblock;
          var nodeindex = furthestblockindex;
          var nodeafeindex;
          var inner = 0;
          while (true) {
            inner++;
            node = stack.elements[--nodeindex];
            if (node === fmtelt)
              break;
            nodeafeindex = afe.indexOf(node);
            if (inner > 3 && nodeafeindex !== -1) {
              afe.remove(node);
              nodeafeindex = -1;
            }
            if (nodeafeindex === -1) {
              stack.removeElement(node);
              continue;
            }
            var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);
            afe.replace(node, newelt.elt, newelt.attrs);
            stack.elements[nodeindex] = newelt.elt;
            node = newelt.elt;
            if (lastnode === furthestblock) {
              afe.remove(BOOKMARK);
              afe.insertAfter(newelt.elt, BOOKMARK);
            }
            node._appendChild(lastnode);
            lastnode = node;
          }
          if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {
            fosterParent(function() {
              return lastnode;
            });
          } else if (ancestor instanceof impl.HTMLTemplateElement) {
            ancestor.content._appendChild(lastnode);
          } else {
            ancestor._appendChild(lastnode);
          }
          var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));
          while (furthestblock.hasChildNodes()) {
            newelt2.elt._appendChild(furthestblock.firstChild);
          }
          furthestblock._appendChild(newelt2.elt);
          afe.remove(fmtelt);
          afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);
          stack.removeElement(fmtelt);
          var pos = stack.elements.lastIndexOf(furthestblock);
          stack.elements.splice(pos + 1, 0, newelt2.elt);
        }
      }
      return true;
    }
    function handleScriptEnd() {
      stack.pop();
      parser = originalInsertionMode;
      return;
    }
    function stopParsing() {
      delete doc._parser;
      stack.elements.length = 0;
      if (doc.defaultView) {
        doc.defaultView.dispatchEvent(new impl.Event("load", {}));
      }
    }
    function reconsume(c, new_state) {
      tokenizer = new_state;
      nextchar--;
    }
    function data_state(c) {
      switch (c) {
        case 38:
          return_state = data_state;
          tokenizer = character_reference_state;
          break;
        case 60:
          if (emitSimpleTag())
            break;
          tokenizer = tag_open_state;
          break;
        case 0:
          textrun.push(c);
          textIncludesNUL = true;
          break;
        case -1:
          emitEOF();
          break;
        default:
          emitCharsWhile(DATATEXT) || textrun.push(c);
          break;
      }
    }
    function rcdata_state(c) {
      switch (c) {
        case 38:
          return_state = rcdata_state;
          tokenizer = character_reference_state;
          break;
        case 60:
          tokenizer = rcdata_less_than_sign_state;
          break;
        case 0:
          textrun.push(65533);
          textIncludesNUL = true;
          break;
        case -1:
          emitEOF();
          break;
        default:
          textrun.push(c);
          break;
      }
    }
    function rawtext_state(c) {
      switch (c) {
        case 60:
          tokenizer = rawtext_less_than_sign_state;
          break;
        case 0:
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          emitCharsWhile(RAWTEXT) || textrun.push(c);
          break;
      }
    }
    function script_data_state(c) {
      switch (c) {
        case 60:
          tokenizer = script_data_less_than_sign_state;
          break;
        case 0:
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          emitCharsWhile(RAWTEXT) || textrun.push(c);
          break;
      }
    }
    function plaintext_state(c) {
      switch (c) {
        case 0:
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          emitCharsWhile(PLAINTEXT) || textrun.push(c);
          break;
      }
    }
    function tag_open_state(c) {
      switch (c) {
        case 33:
          tokenizer = markup_declaration_open_state;
          break;
        case 47:
          tokenizer = end_tag_open_state;
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          beginTagName();
          reconsume(c, tag_name_state);
          break;
        case 63:
          reconsume(c, bogus_comment_state);
          break;
        default:
          textrun.push(60);
          reconsume(c, data_state);
          break;
      }
    }
    function end_tag_open_state(c) {
      switch (c) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          beginEndTagName();
          reconsume(c, tag_name_state);
          break;
        case 62:
          tokenizer = data_state;
          break;
        case -1:
          textrun.push(60);
          textrun.push(47);
          emitEOF();
          break;
        default:
          reconsume(c, bogus_comment_state);
          break;
      }
    }
    function tag_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          tokenizer = before_attribute_name_state;
          break;
        case 47:
          tokenizer = self_closing_start_tag_state;
          break;
        case 62:
          tokenizer = data_state;
          emitTag();
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          tagnamebuf += String.fromCharCode(c + 32);
          break;
        case 0:
          tagnamebuf += String.fromCharCode(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          tagnamebuf += getMatchingChars(TAGNAME);
          break;
      }
    }
    function rcdata_less_than_sign_state(c) {
      if (c === 47) {
        beginTempBuf();
        tokenizer = rcdata_end_tag_open_state;
      } else {
        textrun.push(60);
        reconsume(c, rcdata_state);
      }
    }
    function rcdata_end_tag_open_state(c) {
      switch (c) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          beginEndTagName();
          reconsume(c, rcdata_end_tag_name_state);
          break;
        default:
          textrun.push(60);
          textrun.push(47);
          reconsume(c, rcdata_state);
          break;
      }
    }
    function rcdata_end_tag_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = before_attribute_name_state;
            return;
          }
          break;
        case 47:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = self_closing_start_tag_state;
            return;
          }
          break;
        case 62:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = data_state;
            emitTag();
            return;
          }
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          tagnamebuf += String.fromCharCode(c + 32);
          tempbuf.push(c);
          return;
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          tagnamebuf += String.fromCharCode(c);
          tempbuf.push(c);
          return;
        default:
          break;
      }
      textrun.push(60);
      textrun.push(47);
      pushAll(textrun, tempbuf);
      reconsume(c, rcdata_state);
    }
    function rawtext_less_than_sign_state(c) {
      if (c === 47) {
        beginTempBuf();
        tokenizer = rawtext_end_tag_open_state;
      } else {
        textrun.push(60);
        reconsume(c, rawtext_state);
      }
    }
    function rawtext_end_tag_open_state(c) {
      switch (c) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          beginEndTagName();
          reconsume(c, rawtext_end_tag_name_state);
          break;
        default:
          textrun.push(60);
          textrun.push(47);
          reconsume(c, rawtext_state);
          break;
      }
    }
    function rawtext_end_tag_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = before_attribute_name_state;
            return;
          }
          break;
        case 47:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = self_closing_start_tag_state;
            return;
          }
          break;
        case 62:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = data_state;
            emitTag();
            return;
          }
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          tagnamebuf += String.fromCharCode(c + 32);
          tempbuf.push(c);
          return;
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          tagnamebuf += String.fromCharCode(c);
          tempbuf.push(c);
          return;
        default:
          break;
      }
      textrun.push(60);
      textrun.push(47);
      pushAll(textrun, tempbuf);
      reconsume(c, rawtext_state);
    }
    function script_data_less_than_sign_state(c) {
      switch (c) {
        case 47:
          beginTempBuf();
          tokenizer = script_data_end_tag_open_state;
          break;
        case 33:
          tokenizer = script_data_escape_start_state;
          textrun.push(60);
          textrun.push(33);
          break;
        default:
          textrun.push(60);
          reconsume(c, script_data_state);
          break;
      }
    }
    function script_data_end_tag_open_state(c) {
      switch (c) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          beginEndTagName();
          reconsume(c, script_data_end_tag_name_state);
          break;
        default:
          textrun.push(60);
          textrun.push(47);
          reconsume(c, script_data_state);
          break;
      }
    }
    function script_data_end_tag_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = before_attribute_name_state;
            return;
          }
          break;
        case 47:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = self_closing_start_tag_state;
            return;
          }
          break;
        case 62:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = data_state;
            emitTag();
            return;
          }
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          tagnamebuf += String.fromCharCode(c + 32);
          tempbuf.push(c);
          return;
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          tagnamebuf += String.fromCharCode(c);
          tempbuf.push(c);
          return;
        default:
          break;
      }
      textrun.push(60);
      textrun.push(47);
      pushAll(textrun, tempbuf);
      reconsume(c, script_data_state);
    }
    function script_data_escape_start_state(c) {
      if (c === 45) {
        tokenizer = script_data_escape_start_dash_state;
        textrun.push(45);
      } else {
        reconsume(c, script_data_state);
      }
    }
    function script_data_escape_start_dash_state(c) {
      if (c === 45) {
        tokenizer = script_data_escaped_dash_dash_state;
        textrun.push(45);
      } else {
        reconsume(c, script_data_state);
      }
    }
    function script_data_escaped_state(c) {
      switch (c) {
        case 45:
          tokenizer = script_data_escaped_dash_state;
          textrun.push(45);
          break;
        case 60:
          tokenizer = script_data_escaped_less_than_sign_state;
          break;
        case 0:
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          textrun.push(c);
          break;
      }
    }
    function script_data_escaped_dash_state(c) {
      switch (c) {
        case 45:
          tokenizer = script_data_escaped_dash_dash_state;
          textrun.push(45);
          break;
        case 60:
          tokenizer = script_data_escaped_less_than_sign_state;
          break;
        case 0:
          tokenizer = script_data_escaped_state;
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          tokenizer = script_data_escaped_state;
          textrun.push(c);
          break;
      }
    }
    function script_data_escaped_dash_dash_state(c) {
      switch (c) {
        case 45:
          textrun.push(45);
          break;
        case 60:
          tokenizer = script_data_escaped_less_than_sign_state;
          break;
        case 62:
          tokenizer = script_data_state;
          textrun.push(62);
          break;
        case 0:
          tokenizer = script_data_escaped_state;
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          tokenizer = script_data_escaped_state;
          textrun.push(c);
          break;
      }
    }
    function script_data_escaped_less_than_sign_state(c) {
      switch (c) {
        case 47:
          beginTempBuf();
          tokenizer = script_data_escaped_end_tag_open_state;
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          beginTempBuf();
          textrun.push(60);
          reconsume(c, script_data_double_escape_start_state);
          break;
        default:
          textrun.push(60);
          reconsume(c, script_data_escaped_state);
          break;
      }
    }
    function script_data_escaped_end_tag_open_state(c) {
      switch (c) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          beginEndTagName();
          reconsume(c, script_data_escaped_end_tag_name_state);
          break;
        default:
          textrun.push(60);
          textrun.push(47);
          reconsume(c, script_data_escaped_state);
          break;
      }
    }
    function script_data_escaped_end_tag_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = before_attribute_name_state;
            return;
          }
          break;
        case 47:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = self_closing_start_tag_state;
            return;
          }
          break;
        case 62:
          if (appropriateEndTag(tagnamebuf)) {
            tokenizer = data_state;
            emitTag();
            return;
          }
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          tagnamebuf += String.fromCharCode(c + 32);
          tempbuf.push(c);
          return;
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          tagnamebuf += String.fromCharCode(c);
          tempbuf.push(c);
          return;
        default:
          break;
      }
      textrun.push(60);
      textrun.push(47);
      pushAll(textrun, tempbuf);
      reconsume(c, script_data_escaped_state);
    }
    function script_data_double_escape_start_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 47:
        case 62:
          if (buf2str(tempbuf) === "script") {
            tokenizer = script_data_double_escaped_state;
          } else {
            tokenizer = script_data_escaped_state;
          }
          textrun.push(c);
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          tempbuf.push(c + 32);
          textrun.push(c);
          break;
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          tempbuf.push(c);
          textrun.push(c);
          break;
        default:
          reconsume(c, script_data_escaped_state);
          break;
      }
    }
    function script_data_double_escaped_state(c) {
      switch (c) {
        case 45:
          tokenizer = script_data_double_escaped_dash_state;
          textrun.push(45);
          break;
        case 60:
          tokenizer = script_data_double_escaped_less_than_sign_state;
          textrun.push(60);
          break;
        case 0:
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          textrun.push(c);
          break;
      }
    }
    function script_data_double_escaped_dash_state(c) {
      switch (c) {
        case 45:
          tokenizer = script_data_double_escaped_dash_dash_state;
          textrun.push(45);
          break;
        case 60:
          tokenizer = script_data_double_escaped_less_than_sign_state;
          textrun.push(60);
          break;
        case 0:
          tokenizer = script_data_double_escaped_state;
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          tokenizer = script_data_double_escaped_state;
          textrun.push(c);
          break;
      }
    }
    function script_data_double_escaped_dash_dash_state(c) {
      switch (c) {
        case 45:
          textrun.push(45);
          break;
        case 60:
          tokenizer = script_data_double_escaped_less_than_sign_state;
          textrun.push(60);
          break;
        case 62:
          tokenizer = script_data_state;
          textrun.push(62);
          break;
        case 0:
          tokenizer = script_data_double_escaped_state;
          textrun.push(65533);
          break;
        case -1:
          emitEOF();
          break;
        default:
          tokenizer = script_data_double_escaped_state;
          textrun.push(c);
          break;
      }
    }
    function script_data_double_escaped_less_than_sign_state(c) {
      if (c === 47) {
        beginTempBuf();
        tokenizer = script_data_double_escape_end_state;
        textrun.push(47);
      } else {
        reconsume(c, script_data_double_escaped_state);
      }
    }
    function script_data_double_escape_end_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 47:
        case 62:
          if (buf2str(tempbuf) === "script") {
            tokenizer = script_data_escaped_state;
          } else {
            tokenizer = script_data_double_escaped_state;
          }
          textrun.push(c);
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          tempbuf.push(c + 32);
          textrun.push(c);
          break;
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          tempbuf.push(c);
          textrun.push(c);
          break;
        default:
          reconsume(c, script_data_double_escaped_state);
          break;
      }
    }
    function before_attribute_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 47:
          tokenizer = self_closing_start_tag_state;
          break;
        case 62:
          tokenizer = data_state;
          emitTag();
          break;
        case -1:
          emitEOF();
          break;
        case 61:
          beginAttrName();
          attrnamebuf += String.fromCharCode(c);
          tokenizer = attribute_name_state;
          break;
        default:
          if (handleSimpleAttribute())
            break;
          beginAttrName();
          reconsume(c, attribute_name_state);
          break;
      }
    }
    function attribute_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 47:
        case 62:
        case -1:
          reconsume(c, after_attribute_name_state);
          break;
        case 61:
          tokenizer = before_attribute_value_state;
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          attrnamebuf += String.fromCharCode(c + 32);
          break;
        case 0:
          attrnamebuf += String.fromCharCode(65533);
          break;
        case 34:
        case 39:
        case 60:
        default:
          attrnamebuf += getMatchingChars(ATTRNAME);
          break;
      }
    }
    function after_attribute_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 47:
          addAttribute(attrnamebuf);
          tokenizer = self_closing_start_tag_state;
          break;
        case 61:
          tokenizer = before_attribute_value_state;
          break;
        case 62:
          tokenizer = data_state;
          addAttribute(attrnamebuf);
          emitTag();
          break;
        case -1:
          addAttribute(attrnamebuf);
          emitEOF();
          break;
        default:
          addAttribute(attrnamebuf);
          beginAttrName();
          reconsume(c, attribute_name_state);
          break;
      }
    }
    function before_attribute_value_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 34:
          beginAttrValue();
          tokenizer = attribute_value_double_quoted_state;
          break;
        case 39:
          beginAttrValue();
          tokenizer = attribute_value_single_quoted_state;
          break;
        case 62:
        default:
          beginAttrValue();
          reconsume(c, attribute_value_unquoted_state);
          break;
      }
    }
    function attribute_value_double_quoted_state(c) {
      switch (c) {
        case 34:
          addAttribute(attrnamebuf, attrvaluebuf);
          tokenizer = after_attribute_value_quoted_state;
          break;
        case 38:
          return_state = attribute_value_double_quoted_state;
          tokenizer = character_reference_state;
          break;
        case 0:
          attrvaluebuf += String.fromCharCode(65533);
          break;
        case -1:
          emitEOF();
          break;
        case 10:
          attrvaluebuf += String.fromCharCode(c);
          break;
        default:
          attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);
          break;
      }
    }
    function attribute_value_single_quoted_state(c) {
      switch (c) {
        case 39:
          addAttribute(attrnamebuf, attrvaluebuf);
          tokenizer = after_attribute_value_quoted_state;
          break;
        case 38:
          return_state = attribute_value_single_quoted_state;
          tokenizer = character_reference_state;
          break;
        case 0:
          attrvaluebuf += String.fromCharCode(65533);
          break;
        case -1:
          emitEOF();
          break;
        case 10:
          attrvaluebuf += String.fromCharCode(c);
          break;
        default:
          attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);
          break;
      }
    }
    function attribute_value_unquoted_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          addAttribute(attrnamebuf, attrvaluebuf);
          tokenizer = before_attribute_name_state;
          break;
        case 38:
          return_state = attribute_value_unquoted_state;
          tokenizer = character_reference_state;
          break;
        case 62:
          addAttribute(attrnamebuf, attrvaluebuf);
          tokenizer = data_state;
          emitTag();
          break;
        case 0:
          attrvaluebuf += String.fromCharCode(65533);
          break;
        case -1:
          nextchar--;
          tokenizer = data_state;
          break;
        case 34:
        case 39:
        case 60:
        case 61:
        case 96:
        default:
          attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);
          break;
      }
    }
    function after_attribute_value_quoted_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          tokenizer = before_attribute_name_state;
          break;
        case 47:
          tokenizer = self_closing_start_tag_state;
          break;
        case 62:
          tokenizer = data_state;
          emitTag();
          break;
        case -1:
          emitEOF();
          break;
        default:
          reconsume(c, before_attribute_name_state);
          break;
      }
    }
    function self_closing_start_tag_state(c) {
      switch (c) {
        case 62:
          tokenizer = data_state;
          emitSelfClosingTag(true);
          break;
        case -1:
          emitEOF();
          break;
        default:
          reconsume(c, before_attribute_name_state);
          break;
      }
    }
    function bogus_comment_state(c, lookahead, eof) {
      var len = lookahead.length;
      if (eof) {
        nextchar += len - 1;
      } else {
        nextchar += len;
      }
      var comment = lookahead.substring(0, len - 1);
      comment = comment.replace(/\u0000/g, "\uFFFD");
      comment = comment.replace(/\u000D\u000A/g, "\n");
      comment = comment.replace(/\u000D/g, "\n");
      insertToken(COMMENT, comment);
      tokenizer = data_state;
    }
    bogus_comment_state.lookahead = ">";
    function markup_declaration_open_state(c, lookahead, eof) {
      if (lookahead[0] === "-" && lookahead[1] === "-") {
        nextchar += 2;
        beginComment();
        tokenizer = comment_start_state;
        return;
      }
      if (lookahead.toUpperCase() === "DOCTYPE") {
        nextchar += 7;
        tokenizer = doctype_state;
      } else if (lookahead === "[CDATA[" && cdataAllowed()) {
        nextchar += 7;
        tokenizer = cdata_section_state;
      } else {
        tokenizer = bogus_comment_state;
      }
    }
    markup_declaration_open_state.lookahead = 7;
    function comment_start_state(c) {
      beginComment();
      switch (c) {
        case 45:
          tokenizer = comment_start_dash_state;
          break;
        case 62:
          tokenizer = data_state;
          insertToken(COMMENT, buf2str(commentbuf));
          break;
        default:
          reconsume(c, comment_state);
          break;
      }
    }
    function comment_start_dash_state(c) {
      switch (c) {
        case 45:
          tokenizer = comment_end_state;
          break;
        case 62:
          tokenizer = data_state;
          insertToken(COMMENT, buf2str(commentbuf));
          break;
        case -1:
          insertToken(COMMENT, buf2str(commentbuf));
          emitEOF();
          break;
        default:
          commentbuf.push(45);
          reconsume(c, comment_state);
          break;
      }
    }
    function comment_state(c) {
      switch (c) {
        case 60:
          commentbuf.push(c);
          tokenizer = comment_less_than_sign_state;
          break;
        case 45:
          tokenizer = comment_end_dash_state;
          break;
        case 0:
          commentbuf.push(65533);
          break;
        case -1:
          insertToken(COMMENT, buf2str(commentbuf));
          emitEOF();
          break;
        default:
          commentbuf.push(c);
          break;
      }
    }
    function comment_less_than_sign_state(c) {
      switch (c) {
        case 33:
          commentbuf.push(c);
          tokenizer = comment_less_than_sign_bang_state;
          break;
        case 60:
          commentbuf.push(c);
          break;
        default:
          reconsume(c, comment_state);
          break;
      }
    }
    function comment_less_than_sign_bang_state(c) {
      switch (c) {
        case 45:
          tokenizer = comment_less_than_sign_bang_dash_state;
          break;
        default:
          reconsume(c, comment_state);
          break;
      }
    }
    function comment_less_than_sign_bang_dash_state(c) {
      switch (c) {
        case 45:
          tokenizer = comment_less_than_sign_bang_dash_dash_state;
          break;
        default:
          reconsume(c, comment_end_dash_state);
          break;
      }
    }
    function comment_less_than_sign_bang_dash_dash_state(c) {
      switch (c) {
        case 62:
        case -1:
          reconsume(c, comment_end_state);
          break;
        default:
          reconsume(c, comment_end_state);
          break;
      }
    }
    function comment_end_dash_state(c) {
      switch (c) {
        case 45:
          tokenizer = comment_end_state;
          break;
        case -1:
          insertToken(COMMENT, buf2str(commentbuf));
          emitEOF();
          break;
        default:
          commentbuf.push(45);
          reconsume(c, comment_state);
          break;
      }
    }
    function comment_end_state(c) {
      switch (c) {
        case 62:
          tokenizer = data_state;
          insertToken(COMMENT, buf2str(commentbuf));
          break;
        case 33:
          tokenizer = comment_end_bang_state;
          break;
        case 45:
          commentbuf.push(45);
          break;
        case -1:
          insertToken(COMMENT, buf2str(commentbuf));
          emitEOF();
          break;
        default:
          commentbuf.push(45);
          commentbuf.push(45);
          reconsume(c, comment_state);
          break;
      }
    }
    function comment_end_bang_state(c) {
      switch (c) {
        case 45:
          commentbuf.push(45);
          commentbuf.push(45);
          commentbuf.push(33);
          tokenizer = comment_end_dash_state;
          break;
        case 62:
          tokenizer = data_state;
          insertToken(COMMENT, buf2str(commentbuf));
          break;
        case -1:
          insertToken(COMMENT, buf2str(commentbuf));
          emitEOF();
          break;
        default:
          commentbuf.push(45);
          commentbuf.push(45);
          commentbuf.push(33);
          reconsume(c, comment_state);
          break;
      }
    }
    function doctype_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          tokenizer = before_doctype_name_state;
          break;
        case -1:
          beginDoctype();
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          reconsume(c, before_doctype_name_state);
          break;
      }
    }
    function before_doctype_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          beginDoctype();
          doctypenamebuf.push(c + 32);
          tokenizer = doctype_name_state;
          break;
        case 0:
          beginDoctype();
          doctypenamebuf.push(65533);
          tokenizer = doctype_name_state;
          break;
        case 62:
          beginDoctype();
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          beginDoctype();
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          beginDoctype();
          doctypenamebuf.push(c);
          tokenizer = doctype_name_state;
          break;
      }
    }
    function doctype_name_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          tokenizer = after_doctype_name_state;
          break;
        case 62:
          tokenizer = data_state;
          emitDoctype();
          break;
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          doctypenamebuf.push(c + 32);
          break;
        case 0:
          doctypenamebuf.push(65533);
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          doctypenamebuf.push(c);
          break;
      }
    }
    function after_doctype_name_state(c, lookahead, eof) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          nextchar += 1;
          break;
        case 62:
          tokenizer = data_state;
          nextchar += 1;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          lookahead = lookahead.toUpperCase();
          if (lookahead === "PUBLIC") {
            nextchar += 6;
            tokenizer = after_doctype_public_keyword_state;
          } else if (lookahead === "SYSTEM") {
            nextchar += 6;
            tokenizer = after_doctype_system_keyword_state;
          } else {
            forcequirks();
            tokenizer = bogus_doctype_state;
          }
          break;
      }
    }
    after_doctype_name_state.lookahead = 6;
    function after_doctype_public_keyword_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          tokenizer = before_doctype_public_identifier_state;
          break;
        case 34:
          beginDoctypePublicId();
          tokenizer = doctype_public_identifier_double_quoted_state;
          break;
        case 39:
          beginDoctypePublicId();
          tokenizer = doctype_public_identifier_single_quoted_state;
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          forcequirks();
          tokenizer = bogus_doctype_state;
          break;
      }
    }
    function before_doctype_public_identifier_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 34:
          beginDoctypePublicId();
          tokenizer = doctype_public_identifier_double_quoted_state;
          break;
        case 39:
          beginDoctypePublicId();
          tokenizer = doctype_public_identifier_single_quoted_state;
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          forcequirks();
          tokenizer = bogus_doctype_state;
          break;
      }
    }
    function doctype_public_identifier_double_quoted_state(c) {
      switch (c) {
        case 34:
          tokenizer = after_doctype_public_identifier_state;
          break;
        case 0:
          doctypepublicbuf.push(65533);
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          doctypepublicbuf.push(c);
          break;
      }
    }
    function doctype_public_identifier_single_quoted_state(c) {
      switch (c) {
        case 39:
          tokenizer = after_doctype_public_identifier_state;
          break;
        case 0:
          doctypepublicbuf.push(65533);
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          doctypepublicbuf.push(c);
          break;
      }
    }
    function after_doctype_public_identifier_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          tokenizer = between_doctype_public_and_system_identifiers_state;
          break;
        case 62:
          tokenizer = data_state;
          emitDoctype();
          break;
        case 34:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_double_quoted_state;
          break;
        case 39:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_single_quoted_state;
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          forcequirks();
          tokenizer = bogus_doctype_state;
          break;
      }
    }
    function between_doctype_public_and_system_identifiers_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 62:
          tokenizer = data_state;
          emitDoctype();
          break;
        case 34:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_double_quoted_state;
          break;
        case 39:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_single_quoted_state;
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          forcequirks();
          tokenizer = bogus_doctype_state;
          break;
      }
    }
    function after_doctype_system_keyword_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          tokenizer = before_doctype_system_identifier_state;
          break;
        case 34:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_double_quoted_state;
          break;
        case 39:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_single_quoted_state;
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          forcequirks();
          tokenizer = bogus_doctype_state;
          break;
      }
    }
    function before_doctype_system_identifier_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 34:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_double_quoted_state;
          break;
        case 39:
          beginDoctypeSystemId();
          tokenizer = doctype_system_identifier_single_quoted_state;
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          forcequirks();
          tokenizer = bogus_doctype_state;
          break;
      }
    }
    function doctype_system_identifier_double_quoted_state(c) {
      switch (c) {
        case 34:
          tokenizer = after_doctype_system_identifier_state;
          break;
        case 0:
          doctypesystembuf.push(65533);
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          doctypesystembuf.push(c);
          break;
      }
    }
    function doctype_system_identifier_single_quoted_state(c) {
      switch (c) {
        case 39:
          tokenizer = after_doctype_system_identifier_state;
          break;
        case 0:
          doctypesystembuf.push(65533);
          break;
        case 62:
          forcequirks();
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          doctypesystembuf.push(c);
          break;
      }
    }
    function after_doctype_system_identifier_state(c) {
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
          break;
        case 62:
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          forcequirks();
          emitDoctype();
          emitEOF();
          break;
        default:
          tokenizer = bogus_doctype_state;
          break;
      }
    }
    function bogus_doctype_state(c) {
      switch (c) {
        case 62:
          tokenizer = data_state;
          emitDoctype();
          break;
        case -1:
          emitDoctype();
          emitEOF();
          break;
        default:
          break;
      }
    }
    function cdata_section_state(c) {
      switch (c) {
        case 93:
          tokenizer = cdata_section_bracket_state;
          break;
        case -1:
          emitEOF();
          break;
        case 0:
          textIncludesNUL = true;
        default:
          emitCharsWhile(CDATATEXT) || textrun.push(c);
          break;
      }
    }
    function cdata_section_bracket_state(c) {
      switch (c) {
        case 93:
          tokenizer = cdata_section_end_state;
          break;
        default:
          textrun.push(93);
          reconsume(c, cdata_section_state);
          break;
      }
    }
    function cdata_section_end_state(c) {
      switch (c) {
        case 93:
          textrun.push(93);
          break;
        case 62:
          flushText();
          tokenizer = data_state;
          break;
        default:
          textrun.push(93);
          textrun.push(93);
          reconsume(c, cdata_section_state);
          break;
      }
    }
    function character_reference_state(c) {
      beginTempBuf();
      tempbuf.push(38);
      switch (c) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 60:
        case 38:
        case -1:
          reconsume(c, character_reference_end_state);
          break;
        case 35:
          tempbuf.push(c);
          tokenizer = numeric_character_reference_state;
          break;
        default:
          reconsume(c, named_character_reference_state);
          break;
      }
    }
    function named_character_reference_state(c) {
      NAMEDCHARREF.lastIndex = nextchar;
      var matched = NAMEDCHARREF.exec(chars);
      if (!matched)
        throw new Error("should never happen");
      var name = matched[1];
      if (!name) {
        tokenizer = character_reference_end_state;
        return;
      }
      nextchar += name.length;
      pushAll(tempbuf, str2buf(name));
      switch (return_state) {
        case attribute_value_double_quoted_state:
        case attribute_value_single_quoted_state:
        case attribute_value_unquoted_state:
          if (name[name.length - 1] !== ";") {
            if (/[=A-Za-z0-9]/.test(chars[nextchar])) {
              tokenizer = character_reference_end_state;
              return;
            }
          }
          break;
        default:
          break;
      }
      beginTempBuf();
      var rv = namedCharRefs[name];
      if (typeof rv === "number") {
        tempbuf.push(rv);
      } else {
        pushAll(tempbuf, rv);
      }
      tokenizer = character_reference_end_state;
    }
    named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;
    function numeric_character_reference_state(c) {
      character_reference_code = 0;
      switch (c) {
        case 120:
        case 88:
          tempbuf.push(c);
          tokenizer = hexadecimal_character_reference_start_state;
          break;
        default:
          reconsume(c, decimal_character_reference_start_state);
          break;
      }
    }
    function hexadecimal_character_reference_start_state(c) {
      switch (c) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
          reconsume(c, hexadecimal_character_reference_state);
          break;
        default:
          reconsume(c, character_reference_end_state);
          break;
      }
    }
    function decimal_character_reference_start_state(c) {
      switch (c) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          reconsume(c, decimal_character_reference_state);
          break;
        default:
          reconsume(c, character_reference_end_state);
          break;
      }
    }
    function hexadecimal_character_reference_state(c) {
      switch (c) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
          character_reference_code *= 16;
          character_reference_code += c - 55;
          break;
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
          character_reference_code *= 16;
          character_reference_code += c - 87;
          break;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          character_reference_code *= 16;
          character_reference_code += c - 48;
          break;
        case 59:
          tokenizer = numeric_character_reference_end_state;
          break;
        default:
          reconsume(c, numeric_character_reference_end_state);
          break;
      }
    }
    function decimal_character_reference_state(c) {
      switch (c) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          character_reference_code *= 10;
          character_reference_code += c - 48;
          break;
        case 59:
          tokenizer = numeric_character_reference_end_state;
          break;
        default:
          reconsume(c, numeric_character_reference_end_state);
          break;
      }
    }
    function numeric_character_reference_end_state(c) {
      if (character_reference_code in numericCharRefReplacements) {
        character_reference_code = numericCharRefReplacements[character_reference_code];
      } else if (character_reference_code > 1114111 || character_reference_code >= 55296 && character_reference_code < 57344) {
        character_reference_code = 65533;
      }
      beginTempBuf();
      if (character_reference_code <= 65535) {
        tempbuf.push(character_reference_code);
      } else {
        character_reference_code = character_reference_code - 65536;
        tempbuf.push(55296 + (character_reference_code >> 10));
        tempbuf.push(56320 + (character_reference_code & 1023));
      }
      reconsume(c, character_reference_end_state);
    }
    function character_reference_end_state(c) {
      switch (return_state) {
        case attribute_value_double_quoted_state:
        case attribute_value_single_quoted_state:
        case attribute_value_unquoted_state:
          attrvaluebuf += buf2str(tempbuf);
          break;
        default:
          pushAll(textrun, tempbuf);
          break;
      }
      reconsume(c, return_state);
    }
    function initial_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          value = value.replace(LEADINGWS, "");
          if (value.length === 0)
            return;
          break;
        case 4:
          doc._appendChild(doc.createComment(value));
          return;
        case 5:
          var name = value;
          var publicid = arg3;
          var systemid = arg4;
          doc.appendChild(new DocumentType(doc, name, publicid, systemid));
          if (force_quirks || name.toLowerCase() !== "html" || quirkyPublicIds.test(publicid) || systemid && systemid.toLowerCase() === quirkySystemId || systemid === void 0 && conditionallyQuirkyPublicIds.test(publicid))
            doc._quirks = true;
          else if (limitedQuirkyPublicIds.test(publicid) || systemid !== void 0 && conditionallyQuirkyPublicIds.test(publicid))
            doc._limitedQuirks = true;
          parser = before_html_mode;
          return;
      }
      doc._quirks = true;
      parser = before_html_mode;
      parser(t, value, arg3, arg4);
    }
    function before_html_mode(t, value, arg3, arg4) {
      var elt;
      switch (t) {
        case 1:
          value = value.replace(LEADINGWS, "");
          if (value.length === 0)
            return;
          break;
        case 5:
          return;
        case 4:
          doc._appendChild(doc.createComment(value));
          return;
        case 2:
          if (value === "html") {
            elt = createHTMLElt(doc, value, arg3);
            stack.push(elt);
            doc.appendChild(elt);
            parser = before_head_mode;
            return;
          }
          break;
        case 3:
          switch (value) {
            case "html":
            case "head":
            case "body":
            case "br":
              break;
            default:
              return;
          }
      }
      elt = createHTMLElt(doc, "html", null);
      stack.push(elt);
      doc.appendChild(elt);
      parser = before_head_mode;
      parser(t, value, arg3, arg4);
    }
    function before_head_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          value = value.replace(LEADINGWS, "");
          if (value.length === 0)
            return;
          break;
        case 5:
          return;
        case 4:
          insertComment(value);
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "head":
              var elt = insertHTMLElement(value, arg3);
              head_element_pointer = elt;
              parser = in_head_mode;
              return;
          }
          break;
        case 3:
          switch (value) {
            case "html":
            case "head":
            case "body":
            case "br":
              break;
            default:
              return;
          }
      }
      before_head_mode(TAG, "head", null);
      parser(t, value, arg3, arg4);
    }
    function in_head_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          var ws = value.match(LEADINGWS);
          if (ws) {
            insertText(ws[0]);
            value = value.substring(ws[0].length);
          }
          if (value.length === 0)
            return;
          break;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "meta":
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
              insertHTMLElement(value, arg3);
              stack.pop();
              return;
            case "title":
              parseRCDATA(value, arg3);
              return;
            case "noscript":
              if (!scripting_enabled) {
                insertHTMLElement(value, arg3);
                parser = in_head_noscript_mode;
                return;
              }
            case "noframes":
            case "style":
              parseRawText(value, arg3);
              return;
            case "script":
              insertElement(function(doc2) {
                var elt = createHTMLElt(doc2, value, arg3);
                elt._parser_inserted = true;
                elt._force_async = false;
                if (fragment)
                  elt._already_started = true;
                flushText();
                return elt;
              });
              tokenizer = script_data_state;
              originalInsertionMode = parser;
              parser = text_mode;
              return;
            case "template":
              insertHTMLElement(value, arg3);
              afe.insertMarker();
              frameset_ok = false;
              parser = in_template_mode;
              templateInsertionModes.push(parser);
              return;
            case "head":
              return;
          }
          break;
        case 3:
          switch (value) {
            case "head":
              stack.pop();
              parser = after_head_mode;
              return;
            case "body":
            case "html":
            case "br":
              break;
            case "template":
              if (!stack.contains("template")) {
                return;
              }
              stack.generateImpliedEndTags(null, "thorough");
              stack.popTag("template");
              afe.clearToMarker();
              templateInsertionModes.pop();
              resetInsertionMode();
              return;
            default:
              return;
          }
          break;
      }
      in_head_mode(ENDTAG, "head", null);
      parser(t, value, arg3, arg4);
    }
    function in_head_noscript_mode(t, value, arg3, arg4) {
      switch (t) {
        case 5:
          return;
        case 4:
          in_head_mode(t, value);
          return;
        case 1:
          var ws = value.match(LEADINGWS);
          if (ws) {
            in_head_mode(t, ws[0]);
            value = value.substring(ws[0].length);
          }
          if (value.length === 0)
            return;
          break;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "style":
              in_head_mode(t, value, arg3);
              return;
            case "head":
            case "noscript":
              return;
          }
          break;
        case 3:
          switch (value) {
            case "noscript":
              stack.pop();
              parser = in_head_mode;
              return;
            case "br":
              break;
            default:
              return;
          }
          break;
      }
      in_head_noscript_mode(ENDTAG, "noscript", null);
      parser(t, value, arg3, arg4);
    }
    function after_head_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          var ws = value.match(LEADINGWS);
          if (ws) {
            insertText(ws[0]);
            value = value.substring(ws[0].length);
          }
          if (value.length === 0)
            return;
          break;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "body":
              insertHTMLElement(value, arg3);
              frameset_ok = false;
              parser = in_body_mode;
              return;
            case "frameset":
              insertHTMLElement(value, arg3);
              parser = in_frameset_mode;
              return;
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "script":
            case "style":
            case "template":
            case "title":
              stack.push(head_element_pointer);
              in_head_mode(TAG, value, arg3);
              stack.removeElement(head_element_pointer);
              return;
            case "head":
              return;
          }
          break;
        case 3:
          switch (value) {
            case "template":
              return in_head_mode(t, value, arg3, arg4);
            case "body":
            case "html":
            case "br":
              break;
            default:
              return;
          }
          break;
      }
      after_head_mode(TAG, "body", null);
      frameset_ok = true;
      parser(t, value, arg3, arg4);
    }
    function in_body_mode(t, value, arg3, arg4) {
      var body, i, node, elt;
      switch (t) {
        case 1:
          if (textIncludesNUL) {
            value = value.replace(NULCHARS, "");
            if (value.length === 0)
              return;
          }
          if (frameset_ok && NONWS.test(value))
            frameset_ok = false;
          afereconstruct();
          insertText(value);
          return;
        case 5:
          return;
        case 4:
          insertComment(value);
          return;
        case -1:
          if (templateInsertionModes.length) {
            return in_template_mode(t);
          }
          stopParsing();
          return;
        case 2:
          switch (value) {
            case "html":
              if (stack.contains("template")) {
                return;
              }
              transferAttributes(arg3, stack.elements[0]);
              return;
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "script":
            case "style":
            case "template":
            case "title":
              in_head_mode(TAG, value, arg3);
              return;
            case "body":
              body = stack.elements[1];
              if (!body || !(body instanceof impl.HTMLBodyElement) || stack.contains("template"))
                return;
              frameset_ok = false;
              transferAttributes(arg3, body);
              return;
            case "frameset":
              if (!frameset_ok)
                return;
              body = stack.elements[1];
              if (!body || !(body instanceof impl.HTMLBodyElement))
                return;
              if (body.parentNode)
                body.parentNode.removeChild(body);
              while (!(stack.top instanceof impl.HTMLHtmlElement))
                stack.pop();
              insertHTMLElement(value, arg3);
              parser = in_frameset_mode;
              return;
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              insertHTMLElement(value, arg3);
              return;
            case "menu":
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              if (isA(stack.top, "menuitem")) {
                stack.pop();
              }
              insertHTMLElement(value, arg3);
              return;
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              if (stack.top instanceof impl.HTMLHeadingElement)
                stack.pop();
              insertHTMLElement(value, arg3);
              return;
            case "pre":
            case "listing":
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              insertHTMLElement(value, arg3);
              ignore_linefeed = true;
              frameset_ok = false;
              return;
            case "form":
              if (form_element_pointer && !stack.contains("template"))
                return;
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              elt = insertHTMLElement(value, arg3);
              if (!stack.contains("template"))
                form_element_pointer = elt;
              return;
            case "li":
              frameset_ok = false;
              for (i = stack.elements.length - 1; i >= 0; i--) {
                node = stack.elements[i];
                if (node instanceof impl.HTMLLIElement) {
                  in_body_mode(ENDTAG, "li");
                  break;
                }
                if (isA(node, specialSet) && !isA(node, addressdivpSet))
                  break;
              }
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              insertHTMLElement(value, arg3);
              return;
            case "dd":
            case "dt":
              frameset_ok = false;
              for (i = stack.elements.length - 1; i >= 0; i--) {
                node = stack.elements[i];
                if (isA(node, dddtSet)) {
                  in_body_mode(ENDTAG, node.localName);
                  break;
                }
                if (isA(node, specialSet) && !isA(node, addressdivpSet))
                  break;
              }
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              insertHTMLElement(value, arg3);
              return;
            case "plaintext":
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              insertHTMLElement(value, arg3);
              tokenizer = plaintext_state;
              return;
            case "button":
              if (stack.inScope("button")) {
                in_body_mode(ENDTAG, "button");
                parser(t, value, arg3, arg4);
              } else {
                afereconstruct();
                insertHTMLElement(value, arg3);
                frameset_ok = false;
              }
              return;
            case "a":
              var activeElement = afe.findElementByTag("a");
              if (activeElement) {
                in_body_mode(ENDTAG, value);
                afe.remove(activeElement);
                stack.removeElement(activeElement);
              }
            case "b":
            case "big":
            case "code":
            case "em":
            case "font":
            case "i":
            case "s":
            case "small":
            case "strike":
            case "strong":
            case "tt":
            case "u":
              afereconstruct();
              afe.push(insertHTMLElement(value, arg3), arg3);
              return;
            case "nobr":
              afereconstruct();
              if (stack.inScope(value)) {
                in_body_mode(ENDTAG, value);
                afereconstruct();
              }
              afe.push(insertHTMLElement(value, arg3), arg3);
              return;
            case "applet":
            case "marquee":
            case "object":
              afereconstruct();
              insertHTMLElement(value, arg3);
              afe.insertMarker();
              frameset_ok = false;
              return;
            case "table":
              if (!doc._quirks && stack.inButtonScope("p")) {
                in_body_mode(ENDTAG, "p");
              }
              insertHTMLElement(value, arg3);
              frameset_ok = false;
              parser = in_table_mode;
              return;
            case "area":
            case "br":
            case "embed":
            case "img":
            case "keygen":
            case "wbr":
              afereconstruct();
              insertHTMLElement(value, arg3);
              stack.pop();
              frameset_ok = false;
              return;
            case "input":
              afereconstruct();
              elt = insertHTMLElement(value, arg3);
              stack.pop();
              var type = elt.getAttribute("type");
              if (!type || type.toLowerCase() !== "hidden")
                frameset_ok = false;
              return;
            case "param":
            case "source":
            case "track":
              insertHTMLElement(value, arg3);
              stack.pop();
              return;
            case "hr":
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              if (isA(stack.top, "menuitem")) {
                stack.pop();
              }
              insertHTMLElement(value, arg3);
              stack.pop();
              frameset_ok = false;
              return;
            case "image":
              in_body_mode(TAG, "img", arg3, arg4);
              return;
            case "textarea":
              insertHTMLElement(value, arg3);
              ignore_linefeed = true;
              frameset_ok = false;
              tokenizer = rcdata_state;
              originalInsertionMode = parser;
              parser = text_mode;
              return;
            case "xmp":
              if (stack.inButtonScope("p"))
                in_body_mode(ENDTAG, "p");
              afereconstruct();
              frameset_ok = false;
              parseRawText(value, arg3);
              return;
            case "iframe":
              frameset_ok = false;
              parseRawText(value, arg3);
              return;
            case "noembed":
              parseRawText(value, arg3);
              return;
            case "noscript":
              if (scripting_enabled) {
                parseRawText(value, arg3);
                return;
              }
              break;
            case "select":
              afereconstruct();
              insertHTMLElement(value, arg3);
              frameset_ok = false;
              if (parser === in_table_mode || parser === in_caption_mode || parser === in_table_body_mode || parser === in_row_mode || parser === in_cell_mode)
                parser = in_select_in_table_mode;
              else
                parser = in_select_mode;
              return;
            case "optgroup":
            case "option":
              if (stack.top instanceof impl.HTMLOptionElement) {
                in_body_mode(ENDTAG, "option");
              }
              afereconstruct();
              insertHTMLElement(value, arg3);
              return;
            case "menuitem":
              if (isA(stack.top, "menuitem")) {
                stack.pop();
              }
              afereconstruct();
              insertHTMLElement(value, arg3);
              return;
            case "rb":
            case "rtc":
              if (stack.inScope("ruby")) {
                stack.generateImpliedEndTags();
              }
              insertHTMLElement(value, arg3);
              return;
            case "rp":
            case "rt":
              if (stack.inScope("ruby")) {
                stack.generateImpliedEndTags("rtc");
              }
              insertHTMLElement(value, arg3);
              return;
            case "math":
              afereconstruct();
              adjustMathMLAttributes(arg3);
              adjustForeignAttributes(arg3);
              insertForeignElement(value, arg3, NAMESPACE.MATHML);
              if (arg4)
                stack.pop();
              return;
            case "svg":
              afereconstruct();
              adjustSVGAttributes(arg3);
              adjustForeignAttributes(arg3);
              insertForeignElement(value, arg3, NAMESPACE.SVG);
              if (arg4)
                stack.pop();
              return;
            case "caption":
            case "col":
            case "colgroup":
            case "frame":
            case "head":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return;
          }
          afereconstruct();
          insertHTMLElement(value, arg3);
          return;
        case 3:
          switch (value) {
            case "template":
              in_head_mode(ENDTAG, value, arg3);
              return;
            case "body":
              if (!stack.inScope("body"))
                return;
              parser = after_body_mode;
              return;
            case "html":
              if (!stack.inScope("body"))
                return;
              parser = after_body_mode;
              parser(t, value, arg3);
              return;
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "button":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "listing":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "pre":
            case "section":
            case "summary":
            case "ul":
              if (!stack.inScope(value))
                return;
              stack.generateImpliedEndTags();
              stack.popTag(value);
              return;
            case "form":
              if (!stack.contains("template")) {
                var openform = form_element_pointer;
                form_element_pointer = null;
                if (!openform || !stack.elementInScope(openform))
                  return;
                stack.generateImpliedEndTags();
                stack.removeElement(openform);
              } else {
                if (!stack.inScope("form"))
                  return;
                stack.generateImpliedEndTags();
                stack.popTag("form");
              }
              return;
            case "p":
              if (!stack.inButtonScope(value)) {
                in_body_mode(TAG, value, null);
                parser(t, value, arg3, arg4);
              } else {
                stack.generateImpliedEndTags(value);
                stack.popTag(value);
              }
              return;
            case "li":
              if (!stack.inListItemScope(value))
                return;
              stack.generateImpliedEndTags(value);
              stack.popTag(value);
              return;
            case "dd":
            case "dt":
              if (!stack.inScope(value))
                return;
              stack.generateImpliedEndTags(value);
              stack.popTag(value);
              return;
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              if (!stack.elementTypeInScope(impl.HTMLHeadingElement))
                return;
              stack.generateImpliedEndTags();
              stack.popElementType(impl.HTMLHeadingElement);
              return;
            case "sarcasm":
              break;
            case "a":
            case "b":
            case "big":
            case "code":
            case "em":
            case "font":
            case "i":
            case "nobr":
            case "s":
            case "small":
            case "strike":
            case "strong":
            case "tt":
            case "u":
              var result = adoptionAgency(value);
              if (result)
                return;
              break;
            case "applet":
            case "marquee":
            case "object":
              if (!stack.inScope(value))
                return;
              stack.generateImpliedEndTags();
              stack.popTag(value);
              afe.clearToMarker();
              return;
            case "br":
              in_body_mode(TAG, value, null);
              return;
          }
          for (i = stack.elements.length - 1; i >= 0; i--) {
            node = stack.elements[i];
            if (isA(node, value)) {
              stack.generateImpliedEndTags(value);
              stack.popElement(node);
              break;
            } else if (isA(node, specialSet)) {
              return;
            }
          }
          return;
      }
    }
    function text_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          insertText(value);
          return;
        case -1:
          if (stack.top instanceof impl.HTMLScriptElement)
            stack.top._already_started = true;
          stack.pop();
          parser = originalInsertionMode;
          parser(t);
          return;
        case 3:
          if (value === "script") {
            handleScriptEnd();
          } else {
            stack.pop();
            parser = originalInsertionMode;
          }
          return;
        default:
          return;
      }
    }
    function in_table_mode(t, value, arg3, arg4) {
      function getTypeAttr(attrs) {
        for (var i = 0, n = attrs.length; i < n; i++) {
          if (attrs[i][0] === "type")
            return attrs[i][1].toLowerCase();
        }
        return null;
      }
      switch (t) {
        case 1:
          if (text_integration_mode) {
            in_body_mode(t, value, arg3, arg4);
            return;
          } else if (isA(stack.top, tablesectionrowSet)) {
            pending_table_text = [];
            originalInsertionMode = parser;
            parser = in_table_text_mode;
            parser(t, value, arg3, arg4);
            return;
          }
          break;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case 2:
          switch (value) {
            case "caption":
              stack.clearToContext(tableContextSet);
              afe.insertMarker();
              insertHTMLElement(value, arg3);
              parser = in_caption_mode;
              return;
            case "colgroup":
              stack.clearToContext(tableContextSet);
              insertHTMLElement(value, arg3);
              parser = in_column_group_mode;
              return;
            case "col":
              in_table_mode(TAG, "colgroup", null);
              parser(t, value, arg3, arg4);
              return;
            case "tbody":
            case "tfoot":
            case "thead":
              stack.clearToContext(tableContextSet);
              insertHTMLElement(value, arg3);
              parser = in_table_body_mode;
              return;
            case "td":
            case "th":
            case "tr":
              in_table_mode(TAG, "tbody", null);
              parser(t, value, arg3, arg4);
              return;
            case "table":
              if (!stack.inTableScope(value)) {
                return;
              }
              in_table_mode(ENDTAG, value);
              parser(t, value, arg3, arg4);
              return;
            case "style":
            case "script":
            case "template":
              in_head_mode(t, value, arg3, arg4);
              return;
            case "input":
              var type = getTypeAttr(arg3);
              if (type !== "hidden")
                break;
              insertHTMLElement(value, arg3);
              stack.pop();
              return;
            case "form":
              if (form_element_pointer || stack.contains("template"))
                return;
              form_element_pointer = insertHTMLElement(value, arg3);
              stack.popElement(form_element_pointer);
              return;
          }
          break;
        case 3:
          switch (value) {
            case "table":
              if (!stack.inTableScope(value))
                return;
              stack.popTag(value);
              resetInsertionMode();
              return;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return;
            case "template":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
        case -1:
          in_body_mode(t, value, arg3, arg4);
          return;
      }
      foster_parent_mode = true;
      in_body_mode(t, value, arg3, arg4);
      foster_parent_mode = false;
    }
    function in_table_text_mode(t, value, arg3, arg4) {
      if (t === TEXT) {
        if (textIncludesNUL) {
          value = value.replace(NULCHARS, "");
          if (value.length === 0)
            return;
        }
        pending_table_text.push(value);
      } else {
        var s = pending_table_text.join("");
        pending_table_text.length = 0;
        if (NONWS.test(s)) {
          foster_parent_mode = true;
          in_body_mode(TEXT, s);
          foster_parent_mode = false;
        } else {
          insertText(s);
        }
        parser = originalInsertionMode;
        parser(t, value, arg3, arg4);
      }
    }
    function in_caption_mode(t, value, arg3, arg4) {
      function end_caption() {
        if (!stack.inTableScope("caption"))
          return false;
        stack.generateImpliedEndTags();
        stack.popTag("caption");
        afe.clearToMarker();
        parser = in_table_mode;
        return true;
      }
      switch (t) {
        case 2:
          switch (value) {
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              if (end_caption())
                parser(t, value, arg3, arg4);
              return;
          }
          break;
        case 3:
          switch (value) {
            case "caption":
              end_caption();
              return;
            case "table":
              if (end_caption())
                parser(t, value, arg3, arg4);
              return;
            case "body":
            case "col":
            case "colgroup":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return;
          }
          break;
      }
      in_body_mode(t, value, arg3, arg4);
    }
    function in_column_group_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          var ws = value.match(LEADINGWS);
          if (ws) {
            insertText(ws[0]);
            value = value.substring(ws[0].length);
          }
          if (value.length === 0)
            return;
          break;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "col":
              insertHTMLElement(value, arg3);
              stack.pop();
              return;
            case "template":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
        case 3:
          switch (value) {
            case "colgroup":
              if (!isA(stack.top, "colgroup")) {
                return;
              }
              stack.pop();
              parser = in_table_mode;
              return;
            case "col":
              return;
            case "template":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
        case -1:
          in_body_mode(t, value, arg3, arg4);
          return;
      }
      if (!isA(stack.top, "colgroup")) {
        return;
      }
      in_column_group_mode(ENDTAG, "colgroup");
      parser(t, value, arg3, arg4);
    }
    function in_table_body_mode(t, value, arg3, arg4) {
      function endsect() {
        if (!stack.inTableScope("tbody") && !stack.inTableScope("thead") && !stack.inTableScope("tfoot"))
          return;
        stack.clearToContext(tableBodyContextSet);
        in_table_body_mode(ENDTAG, stack.top.localName, null);
        parser(t, value, arg3, arg4);
      }
      switch (t) {
        case 2:
          switch (value) {
            case "tr":
              stack.clearToContext(tableBodyContextSet);
              insertHTMLElement(value, arg3);
              parser = in_row_mode;
              return;
            case "th":
            case "td":
              in_table_body_mode(TAG, "tr", null);
              parser(t, value, arg3, arg4);
              return;
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "tfoot":
            case "thead":
              endsect();
              return;
          }
          break;
        case 3:
          switch (value) {
            case "table":
              endsect();
              return;
            case "tbody":
            case "tfoot":
            case "thead":
              if (stack.inTableScope(value)) {
                stack.clearToContext(tableBodyContextSet);
                stack.pop();
                parser = in_table_mode;
              }
              return;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
            case "td":
            case "th":
            case "tr":
              return;
          }
          break;
      }
      in_table_mode(t, value, arg3, arg4);
    }
    function in_row_mode(t, value, arg3, arg4) {
      function endrow() {
        if (!stack.inTableScope("tr"))
          return false;
        stack.clearToContext(tableRowContextSet);
        stack.pop();
        parser = in_table_body_mode;
        return true;
      }
      switch (t) {
        case 2:
          switch (value) {
            case "th":
            case "td":
              stack.clearToContext(tableRowContextSet);
              insertHTMLElement(value, arg3);
              parser = in_cell_mode;
              afe.insertMarker();
              return;
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "tfoot":
            case "thead":
            case "tr":
              if (endrow())
                parser(t, value, arg3, arg4);
              return;
          }
          break;
        case 3:
          switch (value) {
            case "tr":
              endrow();
              return;
            case "table":
              if (endrow())
                parser(t, value, arg3, arg4);
              return;
            case "tbody":
            case "tfoot":
            case "thead":
              if (stack.inTableScope(value)) {
                if (endrow())
                  parser(t, value, arg3, arg4);
              }
              return;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
            case "td":
            case "th":
              return;
          }
          break;
      }
      in_table_mode(t, value, arg3, arg4);
    }
    function in_cell_mode(t, value, arg3, arg4) {
      switch (t) {
        case 2:
          switch (value) {
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              if (stack.inTableScope("td")) {
                in_cell_mode(ENDTAG, "td");
                parser(t, value, arg3, arg4);
              } else if (stack.inTableScope("th")) {
                in_cell_mode(ENDTAG, "th");
                parser(t, value, arg3, arg4);
              }
              return;
          }
          break;
        case 3:
          switch (value) {
            case "td":
            case "th":
              if (!stack.inTableScope(value))
                return;
              stack.generateImpliedEndTags();
              stack.popTag(value);
              afe.clearToMarker();
              parser = in_row_mode;
              return;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
              return;
            case "table":
            case "tbody":
            case "tfoot":
            case "thead":
            case "tr":
              if (!stack.inTableScope(value))
                return;
              in_cell_mode(ENDTAG, stack.inTableScope("td") ? "td" : "th");
              parser(t, value, arg3, arg4);
              return;
          }
          break;
      }
      in_body_mode(t, value, arg3, arg4);
    }
    function in_select_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          if (textIncludesNUL) {
            value = value.replace(NULCHARS, "");
            if (value.length === 0)
              return;
          }
          insertText(value);
          return;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case -1:
          in_body_mode(t, value, arg3, arg4);
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "option":
              if (stack.top instanceof impl.HTMLOptionElement)
                in_select_mode(ENDTAG, value);
              insertHTMLElement(value, arg3);
              return;
            case "optgroup":
              if (stack.top instanceof impl.HTMLOptionElement)
                in_select_mode(ENDTAG, "option");
              if (stack.top instanceof impl.HTMLOptGroupElement)
                in_select_mode(ENDTAG, value);
              insertHTMLElement(value, arg3);
              return;
            case "select":
              in_select_mode(ENDTAG, value);
              return;
            case "input":
            case "keygen":
            case "textarea":
              if (!stack.inSelectScope("select"))
                return;
              in_select_mode(ENDTAG, "select");
              parser(t, value, arg3, arg4);
              return;
            case "script":
            case "template":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
        case 3:
          switch (value) {
            case "optgroup":
              if (stack.top instanceof impl.HTMLOptionElement && stack.elements[stack.elements.length - 2] instanceof impl.HTMLOptGroupElement) {
                in_select_mode(ENDTAG, "option");
              }
              if (stack.top instanceof impl.HTMLOptGroupElement)
                stack.pop();
              return;
            case "option":
              if (stack.top instanceof impl.HTMLOptionElement)
                stack.pop();
              return;
            case "select":
              if (!stack.inSelectScope(value))
                return;
              stack.popTag(value);
              resetInsertionMode();
              return;
            case "template":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
      }
    }
    function in_select_in_table_mode(t, value, arg3, arg4) {
      switch (value) {
        case "caption":
        case "table":
        case "tbody":
        case "tfoot":
        case "thead":
        case "tr":
        case "td":
        case "th":
          switch (t) {
            case 2:
              in_select_in_table_mode(ENDTAG, "select");
              parser(t, value, arg3, arg4);
              return;
            case 3:
              if (stack.inTableScope(value)) {
                in_select_in_table_mode(ENDTAG, "select");
                parser(t, value, arg3, arg4);
              }
              return;
          }
      }
      in_select_mode(t, value, arg3, arg4);
    }
    function in_template_mode(t, value, arg3, arg4) {
      function switchModeAndReprocess(mode) {
        parser = mode;
        templateInsertionModes[templateInsertionModes.length - 1] = parser;
        parser(t, value, arg3, arg4);
      }
      switch (t) {
        case 1:
        case 4:
        case 5:
          in_body_mode(t, value, arg3, arg4);
          return;
        case -1:
          if (!stack.contains("template")) {
            stopParsing();
          } else {
            stack.popTag("template");
            afe.clearToMarker();
            templateInsertionModes.pop();
            resetInsertionMode();
            parser(t, value, arg3, arg4);
          }
          return;
        case 2:
          switch (value) {
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "script":
            case "style":
            case "template":
            case "title":
              in_head_mode(t, value, arg3, arg4);
              return;
            case "caption":
            case "colgroup":
            case "tbody":
            case "tfoot":
            case "thead":
              switchModeAndReprocess(in_table_mode);
              return;
            case "col":
              switchModeAndReprocess(in_column_group_mode);
              return;
            case "tr":
              switchModeAndReprocess(in_table_body_mode);
              return;
            case "td":
            case "th":
              switchModeAndReprocess(in_row_mode);
              return;
          }
          switchModeAndReprocess(in_body_mode);
          return;
        case 3:
          switch (value) {
            case "template":
              in_head_mode(t, value, arg3, arg4);
              return;
            default:
              return;
          }
      }
    }
    function after_body_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          if (NONWS.test(value))
            break;
          in_body_mode(t, value);
          return;
        case 4:
          stack.elements[0]._appendChild(doc.createComment(value));
          return;
        case 5:
          return;
        case -1:
          stopParsing();
          return;
        case 2:
          if (value === "html") {
            in_body_mode(t, value, arg3, arg4);
            return;
          }
          break;
        case 3:
          if (value === "html") {
            if (fragment)
              return;
            parser = after_after_body_mode;
            return;
          }
          break;
      }
      parser = in_body_mode;
      parser(t, value, arg3, arg4);
    }
    function in_frameset_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          value = value.replace(ALLNONWS, "");
          if (value.length > 0)
            insertText(value);
          return;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case -1:
          stopParsing();
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "frameset":
              insertHTMLElement(value, arg3);
              return;
            case "frame":
              insertHTMLElement(value, arg3);
              stack.pop();
              return;
            case "noframes":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
        case 3:
          if (value === "frameset") {
            if (fragment && stack.top instanceof impl.HTMLHtmlElement)
              return;
            stack.pop();
            if (!fragment && !(stack.top instanceof impl.HTMLFrameSetElement))
              parser = after_frameset_mode;
            return;
          }
          break;
      }
    }
    function after_frameset_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          value = value.replace(ALLNONWS, "");
          if (value.length > 0)
            insertText(value);
          return;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case -1:
          stopParsing();
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "noframes":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
        case 3:
          if (value === "html") {
            parser = after_after_frameset_mode;
            return;
          }
          break;
      }
    }
    function after_after_body_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          if (NONWS.test(value))
            break;
          in_body_mode(t, value, arg3, arg4);
          return;
        case 4:
          doc._appendChild(doc.createComment(value));
          return;
        case 5:
          in_body_mode(t, value, arg3, arg4);
          return;
        case -1:
          stopParsing();
          return;
        case 2:
          if (value === "html") {
            in_body_mode(t, value, arg3, arg4);
            return;
          }
          break;
      }
      parser = in_body_mode;
      parser(t, value, arg3, arg4);
    }
    function after_after_frameset_mode(t, value, arg3, arg4) {
      switch (t) {
        case 1:
          value = value.replace(ALLNONWS, "");
          if (value.length > 0)
            in_body_mode(t, value, arg3, arg4);
          return;
        case 4:
          doc._appendChild(doc.createComment(value));
          return;
        case 5:
          in_body_mode(t, value, arg3, arg4);
          return;
        case -1:
          stopParsing();
          return;
        case 2:
          switch (value) {
            case "html":
              in_body_mode(t, value, arg3, arg4);
              return;
            case "noframes":
              in_head_mode(t, value, arg3, arg4);
              return;
          }
          break;
      }
    }
    function insertForeignToken(t, value, arg3, arg4) {
      function isHTMLFont(attrs) {
        for (var i2 = 0, n = attrs.length; i2 < n; i2++) {
          switch (attrs[i2][0]) {
            case "color":
            case "face":
            case "size":
              return true;
          }
        }
        return false;
      }
      var current;
      switch (t) {
        case 1:
          if (frameset_ok && NONWSNONNUL.test(value))
            frameset_ok = false;
          if (textIncludesNUL) {
            value = value.replace(NULCHARS, "\uFFFD");
          }
          insertText(value);
          return;
        case 4:
          insertComment(value);
          return;
        case 5:
          return;
        case 2:
          switch (value) {
            case "font":
              if (!isHTMLFont(arg3))
                break;
            case "b":
            case "big":
            case "blockquote":
            case "body":
            case "br":
            case "center":
            case "code":
            case "dd":
            case "div":
            case "dl":
            case "dt":
            case "em":
            case "embed":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
            case "head":
            case "hr":
            case "i":
            case "img":
            case "li":
            case "listing":
            case "menu":
            case "meta":
            case "nobr":
            case "ol":
            case "p":
            case "pre":
            case "ruby":
            case "s":
            case "small":
            case "span":
            case "strong":
            case "strike":
            case "sub":
            case "sup":
            case "table":
            case "tt":
            case "u":
            case "ul":
            case "var":
              if (fragment) {
                break;
              }
              do {
                stack.pop();
                current = stack.top;
              } while (current.namespaceURI !== NAMESPACE.HTML && !isMathmlTextIntegrationPoint(current) && !isHTMLIntegrationPoint(current));
              insertToken(t, value, arg3, arg4);
              return;
          }
          current = stack.elements.length === 1 && fragment ? fragmentContext : stack.top;
          if (current.namespaceURI === NAMESPACE.MATHML) {
            adjustMathMLAttributes(arg3);
          } else if (current.namespaceURI === NAMESPACE.SVG) {
            value = adjustSVGTagName(value);
            adjustSVGAttributes(arg3);
          }
          adjustForeignAttributes(arg3);
          insertForeignElement(value, arg3, current.namespaceURI);
          if (arg4) {
            if (value === "script" && current.namespaceURI === NAMESPACE.SVG) {
            }
            stack.pop();
          }
          return;
        case 3:
          current = stack.top;
          if (value === "script" && current.namespaceURI === NAMESPACE.SVG && current.localName === "script") {
            stack.pop();
          } else {
            var i = stack.elements.length - 1;
            var node = stack.elements[i];
            for (; ; ) {
              if (node.localName.toLowerCase() === value) {
                stack.popElement(node);
                break;
              }
              node = stack.elements[--i];
              if (node.namespaceURI !== NAMESPACE.HTML)
                continue;
              parser(t, value, arg3, arg4);
              break;
            }
          }
          return;
      }
    }
    htmlparser.testTokenizer = function(input, initialState, lastStartTag, charbychar) {
      var tokens = [];
      switch (initialState) {
        case "PCDATA state":
          tokenizer = data_state;
          break;
        case "RCDATA state":
          tokenizer = rcdata_state;
          break;
        case "RAWTEXT state":
          tokenizer = rawtext_state;
          break;
        case "PLAINTEXT state":
          tokenizer = plaintext_state;
          break;
      }
      if (lastStartTag) {
        lasttagname = lastStartTag;
      }
      insertToken = function(t, value, arg3, arg4) {
        flushText();
        switch (t) {
          case 1:
            if (tokens.length > 0 && tokens[tokens.length - 1][0] === "Character") {
              tokens[tokens.length - 1][1] += value;
            } else
              tokens.push(["Character", value]);
            break;
          case 4:
            tokens.push(["Comment", value]);
            break;
          case 5:
            tokens.push([
              "DOCTYPE",
              value,
              arg3 === void 0 ? null : arg3,
              arg4 === void 0 ? null : arg4,
              !force_quirks
            ]);
            break;
          case 2:
            var attrs = Object.create(null);
            for (var i2 = 0; i2 < arg3.length; i2++) {
              var a = arg3[i2];
              if (a.length === 1) {
                attrs[a[0]] = "";
              } else {
                attrs[a[0]] = a[1];
              }
            }
            var token = ["StartTag", value, attrs];
            if (arg4)
              token.push(true);
            tokens.push(token);
            break;
          case 3:
            tokens.push(["EndTag", value]);
            break;
          case -1:
            break;
        }
      };
      if (!charbychar) {
        this.parse(input, true);
      } else {
        for (var i = 0; i < input.length; i++) {
          this.parse(input[i]);
        }
        this.parse("", true);
      }
      return tokens;
    };
    return htmlparser;
  }
});

// node_modules/domino/lib/svg.js
var require_svg = __commonJS((exports2) => {
  "use strict";
  var Element = require_Element();
  var defineElement = require_defineElement();
  var utils = require_utils4();
  var CSSStyleDeclaration = require_CSSStyleDeclaration();
  var svgElements = exports2.elements = {};
  var svgNameToImpl = Object.create(null);
  exports2.createElement = function(doc, localName, prefix) {
    var impl = svgNameToImpl[localName] || SVGElement;
    return new impl(doc, localName, prefix);
  };
  function define2(spec) {
    return defineElement(spec, SVGElement, svgElements, svgNameToImpl);
  }
  var SVGElement = define2({
    superclass: Element,
    ctor: function SVGElement2(doc, localName, prefix) {
      Element.call(this, doc, localName, utils.NAMESPACE.SVG, prefix);
    },
    props: {
      style: {get: function() {
        if (!this._style)
          this._style = new CSSStyleDeclaration(this);
        return this._style;
      }}
    }
  });
  define2({
    ctor: function SVGSVGElement(doc, localName, prefix) {
      SVGElement.call(this, doc, localName, prefix);
    },
    tag: "svg",
    props: {
      createSVGRect: {value: function() {
        return exports2.createElement(this.ownerDocument, "rect", null);
      }}
    }
  });
  define2({
    tags: [
      "a",
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "script",
      "set",
      "stop",
      "style",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tref",
      "tspan",
      "use",
      "view",
      "vkern"
    ]
  });
});

// node_modules/domino/lib/impl.js
var require_impl = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  exports2 = module2.exports = {
    CSSStyleDeclaration: require_CSSStyleDeclaration(),
    CharacterData: require_CharacterData(),
    Comment: require_Comment(),
    DOMException: require_DOMException(),
    DOMImplementation: require_DOMImplementation(),
    DOMTokenList: require_DOMTokenList(),
    Document: require_Document(),
    DocumentFragment: require_DocumentFragment(),
    DocumentType: require_DocumentType(),
    Element: require_Element(),
    HTMLParser: require_HTMLParser(),
    NamedNodeMap: require_NamedNodeMap(),
    Node: require_Node(),
    NodeList: require_NodeList(),
    NodeFilter: require_NodeFilter(),
    ProcessingInstruction: require_ProcessingInstruction(),
    Text: require_Text(),
    Window: require_Window()
  };
  utils.merge(exports2, require_events());
  utils.merge(exports2, require_htmlelts().elements);
  utils.merge(exports2, require_svg().elements);
});

// node_modules/domino/lib/Window.js
var require_Window = __commonJS((exports2, module2) => {
  "use strict";
  var DOMImplementation = require_DOMImplementation();
  var EventTarget = require_EventTarget();
  var Location = require_Location();
  var sloppy = require_sloppy();
  var utils = require_utils4();
  module2.exports = Window;
  function Window(document) {
    this.document = document || new DOMImplementation(null).createHTMLDocument("");
    this.document._scripting_enabled = true;
    this.document.defaultView = this;
    this.location = new Location(this, this.document._address || "about:blank");
  }
  Window.prototype = Object.create(EventTarget.prototype, {
    _run: {value: sloppy.Window_run},
    console: {value: console},
    history: {value: {
      back: utils.nyi,
      forward: utils.nyi,
      go: utils.nyi
    }},
    navigator: {value: require_NavigatorID()},
    window: {get: function() {
      return this;
    }},
    self: {get: function() {
      return this;
    }},
    frames: {get: function() {
      return this;
    }},
    parent: {get: function() {
      return this;
    }},
    top: {get: function() {
      return this;
    }},
    length: {value: 0},
    frameElement: {value: null},
    opener: {value: null},
    onload: {
      get: function() {
        return this._getEventHandler("load");
      },
      set: function(v) {
        this._setEventHandler("load", v);
      }
    },
    getComputedStyle: {value: function getComputedStyle(elt) {
      return elt.style;
    }}
  });
  utils.expose(require_WindowTimers(), Window);
  utils.expose(require_impl(), Window);
});

// node_modules/domino/lib/htmlelts.js
var require_htmlelts = __commonJS((exports2) => {
  "use strict";
  var Node2 = require_Node();
  var Element = require_Element();
  var CSSStyleDeclaration = require_CSSStyleDeclaration();
  var utils = require_utils4();
  var URLUtils = require_URLUtils();
  var defineElement = require_defineElement();
  var htmlElements = exports2.elements = {};
  var htmlNameToImpl = Object.create(null);
  exports2.createElement = function(doc, localName, prefix) {
    var impl = htmlNameToImpl[localName] || HTMLUnknownElement;
    return new impl(doc, localName, prefix);
  };
  function define2(spec) {
    return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);
  }
  function URL(attr) {
    return {
      get: function() {
        var v = this._getattr(attr);
        if (v === null) {
          return "";
        }
        var url = this.doc._resolve(v);
        return url === null ? v : url;
      },
      set: function(value) {
        this._setattr(attr, value);
      }
    };
  }
  function CORS(attr) {
    return {
      get: function() {
        var v = this._getattr(attr);
        if (v === null) {
          return null;
        }
        if (v.toLowerCase() === "use-credentials") {
          return "use-credentials";
        }
        return "anonymous";
      },
      set: function(value) {
        if (value === null || value === void 0) {
          this.removeAttribute(attr);
        } else {
          this._setattr(attr, value);
        }
      }
    };
  }
  var REFERRER = {
    type: ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"],
    missing: ""
  };
  var focusableElements = {
    A: true,
    LINK: true,
    BUTTON: true,
    INPUT: true,
    SELECT: true,
    TEXTAREA: true,
    COMMAND: true
  };
  var HTMLFormElement = function(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    this._form = null;
  };
  var HTMLElement = exports2.HTMLElement = define2({
    superclass: Element,
    ctor: function HTMLElement2(doc, localName, prefix) {
      Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);
    },
    props: {
      innerHTML: {
        get: function() {
          return this.serialize();
        },
        set: function(v) {
          var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, this);
          parser.parse(v === null ? "" : String(v), true);
          var target = this instanceof htmlNameToImpl.template ? this.content : this;
          while (target.hasChildNodes())
            target.removeChild(target.firstChild);
          target.appendChild(parser._asDocumentFragment());
        }
      },
      style: {get: function() {
        if (!this._style)
          this._style = new CSSStyleDeclaration(this);
        return this._style;
      }, set: function(v) {
        if (v === null || v === void 0) {
          v = "";
        }
        this._setattr("style", String(v));
      }},
      blur: {value: function() {
      }},
      focus: {value: function() {
      }},
      forceSpellCheck: {value: function() {
      }},
      click: {value: function() {
        if (this._click_in_progress)
          return;
        this._click_in_progress = true;
        try {
          if (this._pre_click_activation_steps)
            this._pre_click_activation_steps();
          var event = this.ownerDocument.createEvent("MouseEvent");
          event.initMouseEvent("click", true, true, this.ownerDocument.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
          var success = this.dispatchEvent(event);
          if (success) {
            if (this._post_click_activation_steps)
              this._post_click_activation_steps(event);
          } else {
            if (this._cancelled_activation_steps)
              this._cancelled_activation_steps();
          }
        } finally {
          this._click_in_progress = false;
        }
      }},
      submit: {value: utils.nyi}
    },
    attributes: {
      title: String,
      lang: String,
      dir: {type: ["ltr", "rtl", "auto"], missing: ""},
      accessKey: String,
      hidden: Boolean,
      tabIndex: {type: "long", default: function() {
        if (this.tagName in focusableElements || this.contentEditable)
          return 0;
        else
          return -1;
      }}
    },
    events: [
      "abort",
      "canplay",
      "canplaythrough",
      "change",
      "click",
      "contextmenu",
      "cuechange",
      "dblclick",
      "drag",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "dragstart",
      "drop",
      "durationchange",
      "emptied",
      "ended",
      "input",
      "invalid",
      "keydown",
      "keypress",
      "keyup",
      "loadeddata",
      "loadedmetadata",
      "loadstart",
      "mousedown",
      "mousemove",
      "mouseout",
      "mouseover",
      "mouseup",
      "mousewheel",
      "pause",
      "play",
      "playing",
      "progress",
      "ratechange",
      "readystatechange",
      "reset",
      "seeked",
      "seeking",
      "select",
      "show",
      "stalled",
      "submit",
      "suspend",
      "timeupdate",
      "volumechange",
      "waiting",
      "blur",
      "error",
      "focus",
      "load",
      "scroll"
    ]
  });
  var HTMLUnknownElement = define2({
    ctor: function HTMLUnknownElement2(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    }
  });
  var formAssociatedProps = {
    form: {get: function() {
      return this._form;
    }}
  };
  define2({
    tag: "a",
    ctor: function HTMLAnchorElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      _post_click_activation_steps: {value: function(e) {
        if (this.href) {
          this.ownerDocument.defaultView.location = this.href;
        }
      }}
    },
    attributes: {
      href: URL,
      ping: String,
      download: String,
      target: String,
      rel: String,
      media: String,
      hreflang: String,
      type: String,
      referrerPolicy: REFERRER,
      coords: String,
      charset: String,
      name: String,
      rev: String,
      shape: String
    }
  });
  URLUtils._inherit(htmlNameToImpl.a.prototype);
  define2({
    tag: "area",
    ctor: function HTMLAreaElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      alt: String,
      target: String,
      download: String,
      rel: String,
      media: String,
      href: URL,
      hreflang: String,
      type: String,
      shape: String,
      coords: String,
      ping: String,
      referrerPolicy: REFERRER,
      noHref: Boolean
    }
  });
  URLUtils._inherit(htmlNameToImpl.area.prototype);
  define2({
    tag: "br",
    ctor: function HTMLBRElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      clear: String
    }
  });
  define2({
    tag: "base",
    ctor: function HTMLBaseElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      target: String
    }
  });
  define2({
    tag: "body",
    ctor: function HTMLBodyElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    events: [
      "afterprint",
      "beforeprint",
      "beforeunload",
      "blur",
      "error",
      "focus",
      "hashchange",
      "load",
      "message",
      "offline",
      "online",
      "pagehide",
      "pageshow",
      "popstate",
      "resize",
      "scroll",
      "storage",
      "unload"
    ],
    attributes: {
      text: {type: String, treatNullAsEmptyString: true},
      link: {type: String, treatNullAsEmptyString: true},
      vLink: {type: String, treatNullAsEmptyString: true},
      aLink: {type: String, treatNullAsEmptyString: true},
      bgColor: {type: String, treatNullAsEmptyString: true},
      background: String
    }
  });
  define2({
    tag: "button",
    ctor: function HTMLButtonElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps,
    attributes: {
      name: String,
      value: String,
      disabled: Boolean,
      autofocus: Boolean,
      type: {type: ["submit", "reset", "button", "menu"], missing: "submit"},
      formTarget: String,
      formNoValidate: Boolean,
      formMethod: {type: ["get", "post", "dialog"], invalid: "get", missing: ""},
      formEnctype: {type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: ""}
    }
  });
  define2({
    tag: "dl",
    ctor: function HTMLDListElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      compact: Boolean
    }
  });
  define2({
    tag: "data",
    ctor: function HTMLDataElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      value: String
    }
  });
  define2({
    tag: "datalist",
    ctor: function HTMLDataListElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tag: "details",
    ctor: function HTMLDetailsElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      open: Boolean
    }
  });
  define2({
    tag: "div",
    ctor: function HTMLDivElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      align: String
    }
  });
  define2({
    tag: "embed",
    ctor: function HTMLEmbedElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      src: URL,
      type: String,
      width: String,
      height: String,
      align: String,
      name: String
    }
  });
  define2({
    tag: "fieldset",
    ctor: function HTMLFieldSetElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps,
    attributes: {
      disabled: Boolean,
      name: String
    }
  });
  define2({
    tag: "form",
    ctor: function HTMLFormElement2(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      action: String,
      autocomplete: {type: ["on", "off"], missing: "on"},
      name: String,
      acceptCharset: {name: "accept-charset"},
      target: String,
      noValidate: Boolean,
      method: {type: ["get", "post", "dialog"], invalid: "get", missing: "get"},
      enctype: {type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded"},
      encoding: {name: "enctype", type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded"}
    }
  });
  define2({
    tag: "hr",
    ctor: function HTMLHRElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      align: String,
      color: String,
      noShade: Boolean,
      size: String,
      width: String
    }
  });
  define2({
    tag: "head",
    ctor: function HTMLHeadElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tags: ["h1", "h2", "h3", "h4", "h5", "h6"],
    ctor: function HTMLHeadingElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      align: String
    }
  });
  define2({
    tag: "html",
    ctor: function HTMLHtmlElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      version: String
    }
  });
  define2({
    tag: "iframe",
    ctor: function HTMLIFrameElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
      var Window = require_Window();
      this._contentWindow = new Window();
    },
    props: {
      contentWindow: {get: function() {
        return this._contentWindow;
      }},
      contentDocument: {get: function() {
        return this.contentWindow.document;
      }}
    },
    attributes: {
      src: URL,
      srcdoc: String,
      name: String,
      width: String,
      height: String,
      seamless: Boolean,
      allowFullscreen: Boolean,
      allowUserMedia: Boolean,
      allowPaymentRequest: Boolean,
      referrerPolicy: REFERRER,
      align: String,
      scrolling: String,
      frameBorder: String,
      longDesc: URL,
      marginHeight: {type: String, treatNullAsEmptyString: true},
      marginWidth: {type: String, treatNullAsEmptyString: true}
    }
  });
  define2({
    tag: "img",
    ctor: function HTMLImageElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      alt: String,
      src: URL,
      srcset: String,
      crossOrigin: CORS,
      useMap: String,
      isMap: Boolean,
      height: {type: "unsigned long", default: 0},
      width: {type: "unsigned long", default: 0},
      referrerPolicy: REFERRER,
      name: String,
      lowsrc: URL,
      align: String,
      hspace: {type: "unsigned long", default: 0},
      vspace: {type: "unsigned long", default: 0},
      longDesc: URL,
      border: {type: String, treatNullAsEmptyString: true}
    }
  });
  define2({
    tag: "input",
    ctor: function HTMLInputElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: {
      form: formAssociatedProps.form,
      _post_click_activation_steps: {value: function(e) {
        if (this.type === "checkbox") {
          this.checked = !this.checked;
        } else if (this.type === "radio") {
          var group = this.form.getElementsByName(this.name);
          for (var i = group.length - 1; i >= 0; i--) {
            var el = group[i];
            el.checked = el === this;
          }
        }
      }}
    },
    attributes: {
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      accept: String,
      alt: String,
      max: String,
      min: String,
      pattern: String,
      placeholder: String,
      step: String,
      dirName: String,
      defaultValue: {name: "value"},
      multiple: Boolean,
      required: Boolean,
      readOnly: Boolean,
      checked: Boolean,
      value: String,
      src: URL,
      defaultChecked: {name: "checked", type: Boolean},
      size: {type: "unsigned long", default: 20, min: 1, setmin: 1},
      width: {type: "unsigned long", min: 0, setmin: 0, default: 0},
      height: {type: "unsigned long", min: 0, setmin: 0, default: 0},
      minLength: {type: "unsigned long", min: 0, setmin: 0, default: -1},
      maxLength: {type: "unsigned long", min: 0, setmin: 0, default: -1},
      autocomplete: String,
      type: {
        type: [
          "text",
          "hidden",
          "search",
          "tel",
          "url",
          "email",
          "password",
          "datetime",
          "date",
          "month",
          "week",
          "time",
          "datetime-local",
          "number",
          "range",
          "color",
          "checkbox",
          "radio",
          "file",
          "submit",
          "image",
          "reset",
          "button"
        ],
        missing: "text"
      },
      formTarget: String,
      formNoValidate: Boolean,
      formMethod: {type: ["get", "post"], invalid: "get", missing: ""},
      formEnctype: {type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: ""},
      inputMode: {type: ["verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url"], missing: ""},
      align: String,
      useMap: String
    }
  });
  define2({
    tag: "keygen",
    ctor: function HTMLKeygenElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps,
    attributes: {
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      challenge: String,
      keytype: {type: ["rsa"], missing: ""}
    }
  });
  define2({
    tag: "li",
    ctor: function HTMLLIElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      value: {type: "long", default: 0},
      type: String
    }
  });
  define2({
    tag: "label",
    ctor: function HTMLLabelElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps,
    attributes: {
      htmlFor: {name: "for", type: String}
    }
  });
  define2({
    tag: "legend",
    ctor: function HTMLLegendElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      align: String
    }
  });
  define2({
    tag: "link",
    ctor: function HTMLLinkElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      href: URL,
      rel: String,
      media: String,
      hreflang: String,
      type: String,
      crossOrigin: CORS,
      nonce: String,
      integrity: String,
      referrerPolicy: REFERRER,
      charset: String,
      rev: String,
      target: String
    }
  });
  define2({
    tag: "map",
    ctor: function HTMLMapElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      name: String
    }
  });
  define2({
    tag: "menu",
    ctor: function HTMLMenuElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      type: {type: ["context", "popup", "toolbar"], missing: "toolbar"},
      label: String,
      compact: Boolean
    }
  });
  define2({
    tag: "meta",
    ctor: function HTMLMetaElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      name: String,
      content: String,
      httpEquiv: {name: "http-equiv", type: String},
      scheme: String
    }
  });
  define2({
    tag: "meter",
    ctor: function HTMLMeterElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps
  });
  define2({
    tags: ["ins", "del"],
    ctor: function HTMLModElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      cite: URL,
      dateTime: String
    }
  });
  define2({
    tag: "ol",
    ctor: function HTMLOListElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      _numitems: {get: function() {
        var items = 0;
        this.childNodes.forEach(function(n) {
          if (n.nodeType === Node2.ELEMENT_NODE && n.tagName === "LI")
            items++;
        });
        return items;
      }}
    },
    attributes: {
      type: String,
      reversed: Boolean,
      start: {
        type: "long",
        default: function() {
          if (this.reversed)
            return this._numitems;
          else
            return 1;
        }
      },
      compact: Boolean
    }
  });
  define2({
    tag: "object",
    ctor: function HTMLObjectElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps,
    attributes: {
      data: URL,
      type: String,
      name: String,
      useMap: String,
      typeMustMatch: Boolean,
      width: String,
      height: String,
      align: String,
      archive: String,
      code: String,
      declare: Boolean,
      hspace: {type: "unsigned long", default: 0},
      standby: String,
      vspace: {type: "unsigned long", default: 0},
      codeBase: URL,
      codeType: String,
      border: {type: String, treatNullAsEmptyString: true}
    }
  });
  define2({
    tag: "optgroup",
    ctor: function HTMLOptGroupElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      disabled: Boolean,
      label: String
    }
  });
  define2({
    tag: "option",
    ctor: function HTMLOptionElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      form: {get: function() {
        var p = this.parentNode;
        while (p && p.nodeType === Node2.ELEMENT_NODE) {
          if (p.localName === "select")
            return p.form;
          p = p.parentNode;
        }
      }},
      value: {
        get: function() {
          return this._getattr("value") || this.text;
        },
        set: function(v) {
          this._setattr("value", v);
        }
      },
      text: {
        get: function() {
          return this.textContent.replace(/[ \t\n\f\r]+/g, " ").trim();
        },
        set: function(v) {
          this.textContent = v;
        }
      }
    },
    attributes: {
      disabled: Boolean,
      defaultSelected: {name: "selected", type: Boolean},
      label: String
    }
  });
  define2({
    tag: "output",
    ctor: function HTMLOutputElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps,
    attributes: {
      name: String
    }
  });
  define2({
    tag: "p",
    ctor: function HTMLParagraphElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      align: String
    }
  });
  define2({
    tag: "param",
    ctor: function HTMLParamElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      name: String,
      value: String,
      type: String,
      valueType: String
    }
  });
  define2({
    tags: ["pre", "listing", "xmp"],
    ctor: function HTMLPreElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      width: {type: "long", default: 0}
    }
  });
  define2({
    tag: "progress",
    ctor: function HTMLProgressElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: formAssociatedProps,
    attributes: {
      max: {type: Number, float: true, default: 1, min: 0}
    }
  });
  define2({
    tags: ["q", "blockquote"],
    ctor: function HTMLQuoteElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      cite: URL
    }
  });
  define2({
    tag: "script",
    ctor: function HTMLScriptElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      text: {
        get: function() {
          var s = "";
          for (var i = 0, n = this.childNodes.length; i < n; i++) {
            var child = this.childNodes[i];
            if (child.nodeType === Node2.TEXT_NODE)
              s += child._data;
          }
          return s;
        },
        set: function(value) {
          this.removeChildren();
          if (value !== null && value !== "") {
            this.appendChild(this.ownerDocument.createTextNode(value));
          }
        }
      }
    },
    attributes: {
      src: URL,
      type: String,
      charset: String,
      defer: Boolean,
      async: Boolean,
      crossOrigin: CORS,
      nonce: String,
      integrity: String
    }
  });
  define2({
    tag: "select",
    ctor: function HTMLSelectElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: {
      form: formAssociatedProps.form,
      options: {get: function() {
        return this.getElementsByTagName("option");
      }}
    },
    attributes: {
      autocomplete: String,
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      multiple: Boolean,
      required: Boolean,
      size: {type: "unsigned long", default: 0}
    }
  });
  define2({
    tag: "source",
    ctor: function HTMLSourceElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      src: URL,
      type: String,
      media: String
    }
  });
  define2({
    tag: "span",
    ctor: function HTMLSpanElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tag: "style",
    ctor: function HTMLStyleElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      media: String,
      type: String,
      scoped: Boolean
    }
  });
  define2({
    tag: "caption",
    ctor: function HTMLTableCaptionElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      align: String
    }
  });
  define2({
    ctor: function HTMLTableCellElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      colSpan: {type: "unsigned long", default: 1},
      rowSpan: {type: "unsigned long", default: 1},
      scope: {type: ["row", "col", "rowgroup", "colgroup"], missing: ""},
      abbr: String,
      align: String,
      axis: String,
      height: String,
      width: String,
      ch: {name: "char", type: String},
      chOff: {name: "charoff", type: String},
      noWrap: Boolean,
      vAlign: String,
      bgColor: {type: String, treatNullAsEmptyString: true}
    }
  });
  define2({
    tags: ["col", "colgroup"],
    ctor: function HTMLTableColElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      span: {type: "limited unsigned long with fallback", default: 1, min: 1},
      align: String,
      ch: {name: "char", type: String},
      chOff: {name: "charoff", type: String},
      vAlign: String,
      width: String
    }
  });
  define2({
    tag: "table",
    ctor: function HTMLTableElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      rows: {get: function() {
        return this.getElementsByTagName("tr");
      }}
    },
    attributes: {
      align: String,
      border: String,
      frame: String,
      rules: String,
      summary: String,
      width: String,
      bgColor: {type: String, treatNullAsEmptyString: true},
      cellPadding: {type: String, treatNullAsEmptyString: true},
      cellSpacing: {type: String, treatNullAsEmptyString: true}
    }
  });
  define2({
    tag: "template",
    ctor: function HTMLTemplateElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
      this._contentFragment = doc._templateDoc.createDocumentFragment();
    },
    props: {
      content: {get: function() {
        return this._contentFragment;
      }},
      serialize: {value: function() {
        return this.content.serialize();
      }}
    }
  });
  define2({
    tag: "tr",
    ctor: function HTMLTableRowElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      cells: {get: function() {
        return this.querySelectorAll("td,th");
      }}
    },
    attributes: {
      align: String,
      ch: {name: "char", type: String},
      chOff: {name: "charoff", type: String},
      vAlign: String,
      bgColor: {type: String, treatNullAsEmptyString: true}
    }
  });
  define2({
    tags: ["thead", "tfoot", "tbody"],
    ctor: function HTMLTableSectionElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      rows: {get: function() {
        return this.getElementsByTagName("tr");
      }}
    },
    attributes: {
      align: String,
      ch: {name: "char", type: String},
      chOff: {name: "charoff", type: String},
      vAlign: String
    }
  });
  define2({
    tag: "textarea",
    ctor: function HTMLTextAreaElement(doc, localName, prefix) {
      HTMLFormElement.call(this, doc, localName, prefix);
    },
    props: {
      form: formAssociatedProps.form,
      type: {get: function() {
        return "textarea";
      }},
      defaultValue: {
        get: function() {
          return this.textContent;
        },
        set: function(v) {
          this.textContent = v;
        }
      },
      value: {
        get: function() {
          return this.defaultValue;
        },
        set: function(v) {
          this.defaultValue = v;
        }
      },
      textLength: {get: function() {
        return this.value.length;
      }}
    },
    attributes: {
      autocomplete: String,
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      placeholder: String,
      wrap: String,
      dirName: String,
      required: Boolean,
      readOnly: Boolean,
      rows: {type: "limited unsigned long with fallback", default: 2},
      cols: {type: "limited unsigned long with fallback", default: 20},
      maxLength: {type: "unsigned long", min: 0, setmin: 0, default: -1},
      minLength: {type: "unsigned long", min: 0, setmin: 0, default: -1},
      inputMode: {type: ["verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url"], missing: ""}
    }
  });
  define2({
    tag: "time",
    ctor: function HTMLTimeElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      dateTime: String,
      pubDate: Boolean
    }
  });
  define2({
    tag: "title",
    ctor: function HTMLTitleElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      text: {get: function() {
        return this.textContent;
      }}
    }
  });
  define2({
    tag: "ul",
    ctor: function HTMLUListElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      type: String,
      compact: Boolean
    }
  });
  define2({
    ctor: function HTMLMediaElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      src: URL,
      crossOrigin: CORS,
      preload: {type: ["metadata", "none", "auto", {value: "", alias: "auto"}], missing: "auto"},
      loop: Boolean,
      autoplay: Boolean,
      mediaGroup: String,
      controls: Boolean,
      defaultMuted: {name: "muted", type: Boolean}
    }
  });
  define2({
    tag: "audio",
    superclass: htmlElements.HTMLMediaElement,
    ctor: function HTMLAudioElement(doc, localName, prefix) {
      htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tag: "video",
    superclass: htmlElements.HTMLMediaElement,
    ctor: function HTMLVideoElement(doc, localName, prefix) {
      htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
    },
    attributes: {
      poster: URL,
      width: {type: "unsigned long", min: 0, default: 0},
      height: {type: "unsigned long", min: 0, default: 0}
    }
  });
  define2({
    tag: "td",
    superclass: htmlElements.HTMLTableCellElement,
    ctor: function HTMLTableDataCellElement(doc, localName, prefix) {
      htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tag: "th",
    superclass: htmlElements.HTMLTableCellElement,
    ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {
      htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tag: "frameset",
    ctor: function HTMLFrameSetElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tag: "frame",
    ctor: function HTMLFrameElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    }
  });
  define2({
    tag: "canvas",
    ctor: function HTMLCanvasElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      getContext: {value: utils.nyi},
      probablySupportsContext: {value: utils.nyi},
      setContext: {value: utils.nyi},
      transferControlToProxy: {value: utils.nyi},
      toDataURL: {value: utils.nyi},
      toBlob: {value: utils.nyi}
    },
    attributes: {
      width: {type: "unsigned long", default: 300},
      height: {type: "unsigned long", default: 150}
    }
  });
  define2({
    tag: "dialog",
    ctor: function HTMLDialogElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      show: {value: utils.nyi},
      showModal: {value: utils.nyi},
      close: {value: utils.nyi}
    },
    attributes: {
      open: Boolean,
      returnValue: String
    }
  });
  define2({
    tag: "menuitem",
    ctor: function HTMLMenuItemElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    props: {
      _label: {
        get: function() {
          var val = this._getattr("label");
          if (val !== null && val !== "") {
            return val;
          }
          val = this.textContent;
          return val.replace(/[ \t\n\f\r]+/g, " ").trim();
        }
      },
      label: {
        get: function() {
          var val = this._getattr("label");
          if (val !== null) {
            return val;
          }
          return this._label;
        },
        set: function(v) {
          this._setattr("label", v);
        }
      }
    },
    attributes: {
      type: {type: ["command", "checkbox", "radio"], missing: "command"},
      icon: URL,
      disabled: Boolean,
      checked: Boolean,
      radiogroup: String,
      default: Boolean
    }
  });
  define2({
    tag: "source",
    ctor: function HTMLSourceElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      srcset: String,
      sizes: String,
      media: String,
      src: URL,
      type: String
    }
  });
  define2({
    tag: "track",
    ctor: function HTMLTrackElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      src: URL,
      srclang: String,
      label: String,
      default: Boolean,
      kind: {type: ["subtitles", "captions", "descriptions", "chapters", "metadata"], missing: "subtitles", invalid: "metadata"}
    },
    props: {
      NONE: {get: function() {
        return 0;
      }},
      LOADING: {get: function() {
        return 1;
      }},
      LOADED: {get: function() {
        return 2;
      }},
      ERROR: {get: function() {
        return 3;
      }},
      readyState: {get: utils.nyi},
      track: {get: utils.nyi}
    }
  });
  define2({
    tag: "font",
    ctor: function HTMLFontElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      color: {type: String, treatNullAsEmptyString: true},
      face: {type: String},
      size: {type: String}
    }
  });
  define2({
    tag: "dir",
    ctor: function HTMLDirectoryElement(doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
    },
    attributes: {
      compact: Boolean
    }
  });
  define2({
    tags: [
      "abbr",
      "address",
      "article",
      "aside",
      "b",
      "bdi",
      "bdo",
      "cite",
      "code",
      "dd",
      "dfn",
      "dt",
      "em",
      "figcaption",
      "figure",
      "footer",
      "header",
      "hgroup",
      "i",
      "kbd",
      "main",
      "mark",
      "nav",
      "noscript",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "section",
      "small",
      "strong",
      "sub",
      "summary",
      "sup",
      "u",
      "var",
      "wbr",
      "acronym",
      "basefont",
      "big",
      "center",
      "nobr",
      "noembed",
      "noframes",
      "plaintext",
      "strike",
      "tt"
    ]
  });
});

// node_modules/domino/lib/MutationConstants.js
var require_MutationConstants = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    VALUE: 1,
    ATTR: 2,
    REMOVE_ATTR: 3,
    REMOVE: 4,
    MOVE: 5,
    INSERT: 6
  };
});

// node_modules/domino/lib/Document.js
var require_Document = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Document;
  var Node2 = require_Node();
  var NodeList = require_NodeList();
  var ContainerNode = require_ContainerNode();
  var Element = require_Element();
  var Text = require_Text();
  var Comment = require_Comment();
  var Event = require_Event();
  var DocumentFragment = require_DocumentFragment();
  var ProcessingInstruction = require_ProcessingInstruction();
  var DOMImplementation = require_DOMImplementation();
  var TreeWalker = require_TreeWalker();
  var NodeIterator = require_NodeIterator();
  var NodeFilter = require_NodeFilter();
  var URL = require_URL();
  var select = require_select();
  var events = require_events();
  var xml = require_xmlnames();
  var html = require_htmlelts();
  var svg = require_svg();
  var utils = require_utils4();
  var MUTATE = require_MutationConstants();
  var NAMESPACE = utils.NAMESPACE;
  var isApiWritable = require_config().isApiWritable;
  function Document(isHTML, address) {
    ContainerNode.call(this);
    this.nodeType = Node2.DOCUMENT_NODE;
    this.isHTML = isHTML;
    this._address = address || "about:blank";
    this.readyState = "loading";
    this.implementation = new DOMImplementation(this);
    this.ownerDocument = null;
    this._contentType = isHTML ? "text/html" : "application/xml";
    this.doctype = null;
    this.documentElement = null;
    this._templateDocCache = null;
    this._nodeIterators = null;
    this._nid = 1;
    this._nextnid = 2;
    this._nodes = [null, this];
    this.byId = Object.create(null);
    this.modclock = 0;
  }
  var supportedEvents = {
    event: "Event",
    customevent: "CustomEvent",
    uievent: "UIEvent",
    mouseevent: "MouseEvent"
  };
  var replacementEvent = {
    events: "event",
    htmlevents: "event",
    mouseevents: "mouseevent",
    mutationevents: "mutationevent",
    uievents: "uievent"
  };
  var mirrorAttr = function(f, name, defaultValue) {
    return {
      get: function() {
        var o = f.call(this);
        if (o) {
          return o[name];
        }
        return defaultValue;
      },
      set: function(value) {
        var o = f.call(this);
        if (o) {
          o[name] = value;
        }
      }
    };
  };
  function validateAndExtract(namespace, qualifiedName) {
    var prefix, localName, pos;
    if (namespace === "") {
      namespace = null;
    }
    if (!xml.isValidQName(qualifiedName)) {
      utils.InvalidCharacterError();
    }
    prefix = null;
    localName = qualifiedName;
    pos = qualifiedName.indexOf(":");
    if (pos >= 0) {
      prefix = qualifiedName.substring(0, pos);
      localName = qualifiedName.substring(pos + 1);
    }
    if (prefix !== null && namespace === null) {
      utils.NamespaceError();
    }
    if (prefix === "xml" && namespace !== NAMESPACE.XML) {
      utils.NamespaceError();
    }
    if ((prefix === "xmlns" || qualifiedName === "xmlns") && namespace !== NAMESPACE.XMLNS) {
      utils.NamespaceError();
    }
    if (namespace === NAMESPACE.XMLNS && !(prefix === "xmlns" || qualifiedName === "xmlns")) {
      utils.NamespaceError();
    }
    return {namespace, prefix, localName};
  }
  Document.prototype = Object.create(ContainerNode.prototype, {
    _setMutationHandler: {value: function(handler) {
      this.mutationHandler = handler;
    }},
    _dispatchRendererEvent: {value: function(targetNid, type, details) {
      var target = this._nodes[targetNid];
      if (!target)
        return;
      target._dispatchEvent(new Event(type, details), true);
    }},
    nodeName: {value: "#document"},
    nodeValue: {
      get: function() {
        return null;
      },
      set: function() {
      }
    },
    documentURI: {get: function() {
      return this._address;
    }, set: utils.nyi},
    compatMode: {get: function() {
      return this._quirks ? "BackCompat" : "CSS1Compat";
    }},
    createTextNode: {value: function(data) {
      return new Text(this, String(data));
    }},
    createComment: {value: function(data) {
      return new Comment(this, data);
    }},
    createDocumentFragment: {value: function() {
      return new DocumentFragment(this);
    }},
    createProcessingInstruction: {value: function(target, data) {
      if (!xml.isValidName(target) || data.indexOf("?>") !== -1)
        utils.InvalidCharacterError();
      return new ProcessingInstruction(this, target, data);
    }},
    createAttribute: {value: function(localName) {
      localName = String(localName);
      if (!xml.isValidName(localName))
        utils.InvalidCharacterError();
      if (this.isHTML) {
        localName = utils.toASCIILowerCase(localName);
      }
      return new Element._Attr(null, localName, null, null, "");
    }},
    createAttributeNS: {value: function(namespace, qualifiedName) {
      namespace = namespace === null || namespace === void 0 || namespace === "" ? null : String(namespace);
      qualifiedName = String(qualifiedName);
      var ve = validateAndExtract(namespace, qualifiedName);
      return new Element._Attr(null, ve.localName, ve.prefix, ve.namespace, "");
    }},
    createElement: {value: function(localName) {
      localName = String(localName);
      if (!xml.isValidName(localName))
        utils.InvalidCharacterError();
      if (this.isHTML) {
        if (/[A-Z]/.test(localName))
          localName = utils.toASCIILowerCase(localName);
        return html.createElement(this, localName, null);
      } else if (this.contentType === "application/xhtml+xml") {
        return html.createElement(this, localName, null);
      } else {
        return new Element(this, localName, null, null);
      }
    }, writable: isApiWritable},
    createElementNS: {value: function(namespace, qualifiedName) {
      namespace = namespace === null || namespace === void 0 || namespace === "" ? null : String(namespace);
      qualifiedName = String(qualifiedName);
      var ve = validateAndExtract(namespace, qualifiedName);
      return this._createElementNS(ve.localName, ve.namespace, ve.prefix);
    }, writable: isApiWritable},
    _createElementNS: {value: function(localName, namespace, prefix) {
      if (namespace === NAMESPACE.HTML) {
        return html.createElement(this, localName, prefix);
      } else if (namespace === NAMESPACE.SVG) {
        return svg.createElement(this, localName, prefix);
      }
      return new Element(this, localName, namespace, prefix);
    }},
    createEvent: {value: function createEvent(interfaceName) {
      interfaceName = interfaceName.toLowerCase();
      var name = replacementEvent[interfaceName] || interfaceName;
      var constructor = events[supportedEvents[name]];
      if (constructor) {
        var e = new constructor();
        e._initialized = false;
        return e;
      } else {
        utils.NotSupportedError();
      }
    }},
    createTreeWalker: {value: function(root3, whatToShow, filter) {
      if (!root3) {
        throw new TypeError("root argument is required");
      }
      if (!(root3 instanceof Node2)) {
        throw new TypeError("root not a node");
      }
      whatToShow = whatToShow === void 0 ? NodeFilter.SHOW_ALL : +whatToShow;
      filter = filter === void 0 ? null : filter;
      return new TreeWalker(root3, whatToShow, filter);
    }},
    createNodeIterator: {value: function(root3, whatToShow, filter) {
      if (!root3) {
        throw new TypeError("root argument is required");
      }
      if (!(root3 instanceof Node2)) {
        throw new TypeError("root not a node");
      }
      whatToShow = whatToShow === void 0 ? NodeFilter.SHOW_ALL : +whatToShow;
      filter = filter === void 0 ? null : filter;
      return new NodeIterator(root3, whatToShow, filter);
    }},
    _attachNodeIterator: {value: function(ni) {
      if (!this._nodeIterators) {
        this._nodeIterators = [];
      }
      this._nodeIterators.push(ni);
    }},
    _detachNodeIterator: {value: function(ni) {
      var idx = this._nodeIterators.indexOf(ni);
      this._nodeIterators.splice(idx, 1);
    }},
    _preremoveNodeIterators: {value: function(toBeRemoved) {
      if (this._nodeIterators) {
        this._nodeIterators.forEach(function(ni) {
          ni._preremove(toBeRemoved);
        });
      }
    }},
    _updateDocTypeElement: {value: function _updateDocTypeElement() {
      this.doctype = this.documentElement = null;
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        if (kid.nodeType === Node2.DOCUMENT_TYPE_NODE)
          this.doctype = kid;
        else if (kid.nodeType === Node2.ELEMENT_NODE)
          this.documentElement = kid;
      }
    }},
    insertBefore: {value: function insertBefore(child, refChild) {
      Node2.prototype.insertBefore.call(this, child, refChild);
      this._updateDocTypeElement();
      return child;
    }},
    replaceChild: {value: function replaceChild(node, child) {
      Node2.prototype.replaceChild.call(this, node, child);
      this._updateDocTypeElement();
      return child;
    }},
    removeChild: {value: function removeChild(child) {
      Node2.prototype.removeChild.call(this, child);
      this._updateDocTypeElement();
      return child;
    }},
    getElementById: {value: function(id) {
      var n = this.byId[id];
      if (!n)
        return null;
      if (n instanceof MultiId) {
        return n.getFirst();
      }
      return n;
    }},
    _hasMultipleElementsWithId: {value: function(id) {
      return this.byId[id] instanceof MultiId;
    }},
    getElementsByName: {value: Element.prototype.getElementsByName},
    getElementsByTagName: {value: Element.prototype.getElementsByTagName},
    getElementsByTagNameNS: {value: Element.prototype.getElementsByTagNameNS},
    getElementsByClassName: {value: Element.prototype.getElementsByClassName},
    adoptNode: {value: function adoptNode(node) {
      if (node.nodeType === Node2.DOCUMENT_NODE)
        utils.NotSupportedError();
      if (node.nodeType === Node2.ATTRIBUTE_NODE) {
        return node;
      }
      if (node.parentNode)
        node.parentNode.removeChild(node);
      if (node.ownerDocument !== this)
        recursivelySetOwner(node, this);
      return node;
    }},
    importNode: {value: function importNode(node, deep) {
      return this.adoptNode(node.cloneNode(deep));
    }, writable: isApiWritable},
    origin: {get: function origin() {
      return null;
    }},
    characterSet: {get: function characterSet() {
      return "UTF-8";
    }},
    contentType: {get: function contentType() {
      return this._contentType;
    }},
    URL: {get: function URL2() {
      return this._address;
    }},
    domain: {get: utils.nyi, set: utils.nyi},
    referrer: {get: utils.nyi},
    cookie: {get: utils.nyi, set: utils.nyi},
    lastModified: {get: utils.nyi},
    location: {
      get: function() {
        return this.defaultView ? this.defaultView.location : null;
      },
      set: utils.nyi
    },
    _titleElement: {
      get: function() {
        return this.getElementsByTagName("title").item(0) || null;
      }
    },
    title: {
      get: function() {
        var elt = this._titleElement;
        var value = elt ? elt.textContent : "";
        return value.replace(/[ \t\n\r\f]+/g, " ").replace(/(^ )|( $)/g, "");
      },
      set: function(value) {
        var elt = this._titleElement;
        var head = this.head;
        if (!elt && !head) {
          return;
        }
        if (!elt) {
          elt = this.createElement("title");
          head.appendChild(elt);
        }
        elt.textContent = value;
      }
    },
    dir: mirrorAttr(function() {
      var htmlElement = this.documentElement;
      if (htmlElement && htmlElement.tagName === "HTML") {
        return htmlElement;
      }
    }, "dir", ""),
    fgColor: mirrorAttr(function() {
      return this.body;
    }, "text", ""),
    linkColor: mirrorAttr(function() {
      return this.body;
    }, "link", ""),
    vlinkColor: mirrorAttr(function() {
      return this.body;
    }, "vLink", ""),
    alinkColor: mirrorAttr(function() {
      return this.body;
    }, "aLink", ""),
    bgColor: mirrorAttr(function() {
      return this.body;
    }, "bgColor", ""),
    charset: {get: function() {
      return this.characterSet;
    }},
    inputEncoding: {get: function() {
      return this.characterSet;
    }},
    scrollingElement: {
      get: function() {
        return this._quirks ? this.body : this.documentElement;
      }
    },
    body: {
      get: function() {
        return namedHTMLChild(this.documentElement, "body");
      },
      set: utils.nyi
    },
    head: {get: function() {
      return namedHTMLChild(this.documentElement, "head");
    }},
    images: {get: utils.nyi},
    embeds: {get: utils.nyi},
    plugins: {get: utils.nyi},
    links: {get: utils.nyi},
    forms: {get: utils.nyi},
    scripts: {get: utils.nyi},
    applets: {get: function() {
      return [];
    }},
    activeElement: {get: function() {
      return null;
    }},
    innerHTML: {
      get: function() {
        return this.serialize();
      },
      set: utils.nyi
    },
    outerHTML: {
      get: function() {
        return this.serialize();
      },
      set: utils.nyi
    },
    write: {value: function(args) {
      if (!this.isHTML)
        utils.InvalidStateError();
      if (!this._parser)
        return;
      if (!this._parser) {
      }
      var s = arguments.join("");
      this._parser.parse(s);
    }},
    writeln: {value: function writeln(args) {
      this.write(Array.prototype.join.call(arguments, "") + "\n");
    }},
    open: {value: function() {
      this.documentElement = null;
    }},
    close: {value: function() {
      this.readyState = "interactive";
      this._dispatchEvent(new Event("readystatechange"), true);
      this._dispatchEvent(new Event("DOMContentLoaded"), true);
      this.readyState = "complete";
      this._dispatchEvent(new Event("readystatechange"), true);
      if (this.defaultView) {
        this.defaultView._dispatchEvent(new Event("load"), true);
      }
    }},
    clone: {value: function clone() {
      var d = new Document(this.isHTML, this._address);
      d._quirks = this._quirks;
      d._contentType = this._contentType;
      return d;
    }},
    cloneNode: {value: function cloneNode(deep) {
      var clone = Node2.prototype.cloneNode.call(this, false);
      if (deep) {
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          clone._appendChild(clone.importNode(kid, true));
        }
      }
      clone._updateDocTypeElement();
      return clone;
    }},
    isEqual: {value: function isEqual(n) {
      return true;
    }},
    mutateValue: {value: function(node) {
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.VALUE,
          target: node,
          data: node.data
        });
      }
    }},
    mutateAttr: {value: function(attr, oldval) {
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.ATTR,
          target: attr.ownerElement,
          attr
        });
      }
    }},
    mutateRemoveAttr: {value: function(attr) {
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.REMOVE_ATTR,
          target: attr.ownerElement,
          attr
        });
      }
    }},
    mutateRemove: {value: function(node) {
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.REMOVE,
          target: node.parentNode,
          node
        });
      }
      recursivelyUproot(node);
    }},
    mutateInsert: {value: function(node) {
      recursivelyRoot(node);
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.INSERT,
          target: node.parentNode,
          node
        });
      }
    }},
    mutateMove: {value: function(node) {
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.MOVE,
          target: node
        });
      }
    }},
    addId: {value: function addId(id, n) {
      var val = this.byId[id];
      if (!val) {
        this.byId[id] = n;
      } else {
        if (!(val instanceof MultiId)) {
          val = new MultiId(val);
          this.byId[id] = val;
        }
        val.add(n);
      }
    }},
    delId: {value: function delId(id, n) {
      var val = this.byId[id];
      utils.assert(val);
      if (val instanceof MultiId) {
        val.del(n);
        if (val.length === 1) {
          this.byId[id] = val.downgrade();
        }
      } else {
        this.byId[id] = void 0;
      }
    }},
    _resolve: {value: function(href) {
      return new URL(this._documentBaseURL).resolve(href);
    }},
    _documentBaseURL: {get: function() {
      var url = this._address;
      if (url === "about:blank")
        url = "/";
      var base = this.querySelector("base[href]");
      if (base) {
        return new URL(url).resolve(base.getAttribute("href"));
      }
      return url;
    }},
    _templateDoc: {get: function() {
      if (!this._templateDocCache) {
        var newDoc = new Document(this.isHTML, this._address);
        this._templateDocCache = newDoc._templateDocCache = newDoc;
      }
      return this._templateDocCache;
    }},
    querySelector: {value: function(selector) {
      return select(selector, this)[0];
    }},
    querySelectorAll: {value: function(selector) {
      var nodes = select(selector, this);
      return nodes.item ? nodes : new NodeList(nodes);
    }}
  });
  var eventHandlerTypes = [
    "abort",
    "canplay",
    "canplaythrough",
    "change",
    "click",
    "contextmenu",
    "cuechange",
    "dblclick",
    "drag",
    "dragend",
    "dragenter",
    "dragleave",
    "dragover",
    "dragstart",
    "drop",
    "durationchange",
    "emptied",
    "ended",
    "input",
    "invalid",
    "keydown",
    "keypress",
    "keyup",
    "loadeddata",
    "loadedmetadata",
    "loadstart",
    "mousedown",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
    "mousewheel",
    "pause",
    "play",
    "playing",
    "progress",
    "ratechange",
    "readystatechange",
    "reset",
    "seeked",
    "seeking",
    "select",
    "show",
    "stalled",
    "submit",
    "suspend",
    "timeupdate",
    "volumechange",
    "waiting",
    "blur",
    "error",
    "focus",
    "load",
    "scroll"
  ];
  eventHandlerTypes.forEach(function(type) {
    Object.defineProperty(Document.prototype, "on" + type, {
      get: function() {
        return this._getEventHandler(type);
      },
      set: function(v) {
        this._setEventHandler(type, v);
      }
    });
  });
  function namedHTMLChild(parent, name) {
    if (parent && parent.isHTML) {
      for (var kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
        if (kid.nodeType === Node2.ELEMENT_NODE && kid.localName === name && kid.namespaceURI === NAMESPACE.HTML) {
          return kid;
        }
      }
    }
    return null;
  }
  function root2(n) {
    n._nid = n.ownerDocument._nextnid++;
    n.ownerDocument._nodes[n._nid] = n;
    if (n.nodeType === Node2.ELEMENT_NODE) {
      var id = n.getAttribute("id");
      if (id)
        n.ownerDocument.addId(id, n);
      if (n._roothook)
        n._roothook();
    }
  }
  function uproot(n) {
    if (n.nodeType === Node2.ELEMENT_NODE) {
      var id = n.getAttribute("id");
      if (id)
        n.ownerDocument.delId(id, n);
    }
    n.ownerDocument._nodes[n._nid] = void 0;
    n._nid = void 0;
  }
  function recursivelyRoot(node) {
    root2(node);
    if (node.nodeType === Node2.ELEMENT_NODE) {
      for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)
        recursivelyRoot(kid);
    }
  }
  function recursivelyUproot(node) {
    uproot(node);
    for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)
      recursivelyUproot(kid);
  }
  function recursivelySetOwner(node, owner) {
    node.ownerDocument = owner;
    node._lastModTime = void 0;
    if (Object.prototype.hasOwnProperty.call(node, "_tagName")) {
      node._tagName = void 0;
    }
    for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)
      recursivelySetOwner(kid, owner);
  }
  function MultiId(node) {
    this.nodes = Object.create(null);
    this.nodes[node._nid] = node;
    this.length = 1;
    this.firstNode = void 0;
  }
  MultiId.prototype.add = function(node) {
    if (!this.nodes[node._nid]) {
      this.nodes[node._nid] = node;
      this.length++;
      this.firstNode = void 0;
    }
  };
  MultiId.prototype.del = function(node) {
    if (this.nodes[node._nid]) {
      delete this.nodes[node._nid];
      this.length--;
      this.firstNode = void 0;
    }
  };
  MultiId.prototype.getFirst = function() {
    if (!this.firstNode) {
      var nid;
      for (nid in this.nodes) {
        if (this.firstNode === void 0 || this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node2.DOCUMENT_POSITION_PRECEDING) {
          this.firstNode = this.nodes[nid];
        }
      }
    }
    return this.firstNode;
  };
  MultiId.prototype.downgrade = function() {
    if (this.length === 1) {
      var nid;
      for (nid in this.nodes) {
        return this.nodes[nid];
      }
    }
    return this;
  };
});

// node_modules/domino/lib/DOMImplementation.js
var require_DOMImplementation = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = DOMImplementation;
  var Document = require_Document();
  var DocumentType = require_DocumentType();
  var HTMLParser2 = require_HTMLParser();
  var utils = require_utils4();
  var xml = require_xmlnames();
  function DOMImplementation(contextObject) {
    this.contextObject = contextObject;
  }
  var supportedFeatures = {
    xml: {"": true, "1.0": true, "2.0": true},
    core: {"": true, "2.0": true},
    html: {"": true, "1.0": true, "2.0": true},
    xhtml: {"": true, "1.0": true, "2.0": true}
  };
  DOMImplementation.prototype = {
    hasFeature: function hasFeature(feature, version) {
      var f = supportedFeatures[(feature || "").toLowerCase()];
      return f && f[version || ""] || false;
    },
    createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
      if (!xml.isValidQName(qualifiedName))
        utils.InvalidCharacterError();
      return new DocumentType(this.contextObject, qualifiedName, publicId, systemId);
    },
    createDocument: function createDocument(namespace, qualifiedName, doctype) {
      var d = new Document(false, null);
      var e;
      if (qualifiedName)
        e = d.createElementNS(namespace, qualifiedName);
      else
        e = null;
      if (doctype) {
        d.appendChild(doctype);
      }
      if (e)
        d.appendChild(e);
      if (namespace === utils.NAMESPACE.HTML) {
        d._contentType = "application/xhtml+xml";
      } else if (namespace === utils.NAMESPACE.SVG) {
        d._contentType = "image/svg+xml";
      } else {
        d._contentType = "application/xml";
      }
      return d;
    },
    createHTMLDocument: function createHTMLDocument(titleText) {
      var d = new Document(true, null);
      d.appendChild(new DocumentType(d, "html"));
      var html = d.createElement("html");
      d.appendChild(html);
      var head = d.createElement("head");
      html.appendChild(head);
      if (titleText !== void 0) {
        var title = d.createElement("title");
        head.appendChild(title);
        title.appendChild(d.createTextNode(titleText));
      }
      html.appendChild(d.createElement("body"));
      d.modclock = 1;
      return d;
    },
    mozSetOutputMutationHandler: function(doc, handler) {
      doc.mutationHandler = handler;
    },
    mozGetInputMutationHandler: function(doc) {
      utils.nyi();
    },
    mozHTMLParser: HTMLParser2
  };
});

// node_modules/domino/lib/index.js
var require_lib6 = __commonJS((exports2) => {
  "use strict";
  var DOMImplementation = require_DOMImplementation();
  var HTMLParser2 = require_HTMLParser();
  var Window = require_Window();
  exports2.createDOMImplementation = function() {
    return new DOMImplementation(null);
  };
  exports2.createDocument = function(html, force) {
    if (html || force) {
      var parser = new HTMLParser2();
      parser.parse(html || "", true);
      return parser.document();
    }
    return new DOMImplementation(null).createHTMLDocument("");
  };
  exports2.createIncrementalHTMLParser = function() {
    var parser = new HTMLParser2();
    return {
      write: function(s) {
        if (s.length > 0) {
          parser.parse(s, false, function() {
            return true;
          });
        }
      },
      end: function(s) {
        parser.parse(s || "", true, function() {
          return true;
        });
      },
      process: function(shouldPauseFunc) {
        return parser.parse("", false, shouldPauseFunc);
      },
      document: function() {
        return parser.document();
      }
    };
  };
  exports2.createWindow = function(html, address) {
    var document = exports2.createDocument(html);
    if (address !== void 0) {
      document._address = address;
    }
    return new Window(document);
  };
  exports2.impl = require_impl();
});

// src/index.ts
__export(exports, {
  activate: () => activate
});
var import_coc3 = __toModule(require("coc.nvim"));
var solargraph2 = __toModule(require_out2());

// src/language-client.ts
var import_coc = __toModule(require("coc.nvim"));
var import_net = __toModule(require("net"));
var solargraph = __toModule(require_out2());
function makeLanguageClient(configuration) {
  let prepareStatus = import_coc.window.createStatusBarItem(10, {progress: true});
  prepareStatus.show();
  let middleware = {
    provideCompletionItem: (document, position, context, token, next2) => {
      return Promise.resolve(next2(document, position, context, token)).then((res) => {
        let doc = import_coc.workspace.getDocument(document.uri);
        if (!doc)
          return [];
        let items = res.hasOwnProperty("isIncomplete") ? res.items : res;
        let result = {
          isIncomplete: false,
          items
        };
        if (items.length && items.every((o) => o.label.startsWith(":"))) {
          result.startcol = doc.fixStartcol(position, [":"]);
        }
        return result;
      });
    }
  };
  let clientOptions = {
    documentSelector: [{scheme: "file", language: "ruby"}, {scheme: "file", pattern: "**/Gemfile"}],
    synchronize: {
      configurationSection: "solargraph",
      fileEvents: import_coc.workspace.createFileSystemWatcher("{**/*.rb,**/*.gemspec,**/Gemfile}")
    },
    middleware,
    initializationOptions: {
      enablePages: true,
      viewsPath: configuration.viewsPath
    }
  };
  let selectClient = () => {
    let transport = import_coc.workspace.getConfiguration("solargraph").transport;
    if (transport == "stdio") {
      return () => {
        return new Promise((resolve) => {
          let child = solargraph.commands.solargraphCommand(["stdio"], configuration);
          child.on("error", (err) => {
            console.error("Solargraph error:", err.message);
          });
          child.stderr.on("data", (data) => {
            console.log(data.toString());
          });
          child.on("exit", (code, signal) => {
            console.error("Solargraph exited with code", code, signal);
          });
          resolve(child);
        });
      };
    } else if (transport == "socket") {
      return () => {
        return new Promise((resolve, reject) => {
          let socketProvider = new solargraph.SocketProvider(configuration);
          socketProvider.start().then(() => {
            let socket = import_net.default.createConnection(socketProvider.port);
            resolve({
              reader: socket,
              writer: socket
            });
          }).catch((err) => {
            reject(err);
          });
        });
      };
    } else {
      return () => {
        return new Promise((resolve) => {
          let socket = import_net.default.createConnection({host: import_coc.workspace.getConfiguration("solargraph").externalServer.host, port: import_coc.workspace.getConfiguration("solargraph").externalServer.port});
          resolve({
            reader: socket,
            writer: socket
          });
        });
      };
    }
  };
  let serverOptions = selectClient();
  let client = new import_coc.LanguageClient("solargraph", "Ruby Language Server", serverOptions, clientOptions);
  let interval = setInterval(() => {
    prepareStatus.text = `Starting the Solargraph language server`;
  }, 100);
  client.onReady().then(() => {
    clearInterval(interval);
    prepareStatus.dispose();
    import_coc.window.showMessage("Solargraph is ready.", "more");
  }).catch(() => {
    clearInterval(interval);
    prepareStatus.dispose();
    import_coc.window.showMessage("Solargraph failed to initialize.", "error");
  });
  return client;
}

// src/SolargraphDocumentProvider.ts
var import_coc2 = __toModule(require("coc.nvim"));

// node_modules/turndown/lib/turndown.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key))
        destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = content.replace(/^\n+|\n+$/g, "");
    content = content.replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options) {
    content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
    var prefix = options.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options) {
    return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options) {
    return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference = "[" + id + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content.trim())
      return "";
    var delimiter = "`";
    var leadingSpace = "";
    var trailingSpace = "";
    var matches = content.match(/`+/gm);
    if (matches) {
      if (/^`/.test(content))
        leadingSpace = " ";
      if (/`$/.test(content))
        trailingSpace = " ";
      while (matches.indexOf(delimiter) !== -1)
        delimiter = delimiter + "`";
    }
    return delimiter + leadingSpace + content + trailingSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules)
    this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank)
      return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options))
      return rule;
    if (rule = findRule(this._keep, node, this.options))
      return rule;
    if (rule = findRule(this._remove, node, this.options))
      return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++)
      fn(this.array[i], i);
  }
};
function findRule(rules2, node, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element))
    return;
  var prevText = null;
  var prevVoid = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !prevVoid && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        prevVoid = false;
      } else if (isVoid2(node)) {
        prevText = null;
        prevVoid = true;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    var domino = require_lib6();
    Parser.prototype.parseFromString = function(string) {
      return domino.createDocument(string);
    };
  }
  return Parser;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString('<x-turndown id="turndown-root">' + input + "</x-turndown>", "text/html");
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function Node(node) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName.toLowerCase() === "code" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node) {
  var leading = "";
  var trailing = "";
  if (!node.isBlock) {
    var hasLeading = /^\s/.test(node.textContent);
    var hasTrailing = /\s$/.test(node.textContent);
    var blankWithSpaces = node.isBlank && hasLeading && hasTrailing;
    if (hasLeading && !isFlankedByWhitespace("left", node)) {
      leading = " ";
    }
    if (!blankWithSpaces && hasTrailing && !isFlankedByWhitespace("right", node)) {
      trailing = " ";
    }
  }
  return {leading, trailing};
}
function isFlankedByWhitespace(side, node) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var leadingNewLinesRegExp = /^\n*/;
var trailingNewLinesRegExp = /\n*$/;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options);
  var defaults = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(input + " is not a string, or an element/document/fragment node.");
    }
    if (input === "")
      return "";
    var output = process2.call(this, new RootNode(input));
    return postProcess.call(this, output);
  },
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++)
        this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape) {
      return accumulator.replace(escape[0], escape[1]);
    }, string);
  }
};
function process2(parentNode) {
  var self2 = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self2.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self2, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self2 = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self2.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process2.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing)
    content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function separatingNewlines(output, replacement) {
  var newlines = [
    output.match(trailingNewLinesRegExp)[0],
    replacement.match(leadingNewLinesRegExp)[0]
  ].sort();
  var maxNewlines = newlines[newlines.length - 1];
  return maxNewlines.length < 2 ? maxNewlines : "\n\n";
}
function join(string1, string2) {
  var separator = separatingNewlines(string1, string2);
  string1 = string1.replace(trailingNewLinesRegExp, "");
  string2 = string2.replace(leadingNewLinesRegExp, "");
  return string1 + separator + string2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_es_default = TurndownService;

// src/SolargraphDocumentProvider.ts
var turndownService = new turndown_es_default();
var SolargraphDocumentProvider = class {
  constructor(languageClient) {
    this.languageClient = languageClient;
    this.docs = {};
  }
  updateAll() {
    Object.keys(this.docs).forEach((uri) => {
      this.update(uri);
    });
  }
  remove(uri) {
    delete this.docs[uri];
  }
  provideTextDocumentContent(uri, token) {
    let key = uri.toString();
    let doc = this.docs[uri.toString()];
    if (doc)
      return doc;
    return new Promise((resolve) => {
      let method = "$/solargraph" + uri.path;
      let query = this.parseQuery(uri.query.replace(/=/g, "%3D").replace(/\%$/, "%25").replace(/query\%3D/, "query="));
      this.languageClient.sendRequest(method, {query: query.query}, token).then((result) => {
        import_coc2.workspace.nvim.command("setfiletype markdown", true);
        if (result && result.content) {
          const content = turndownService.turndown(result.content);
          this.docs[key] = content;
          resolve(content);
        } else {
          this.docs[key] = "";
          resolve("");
        }
      }, (e) => {
        resolve(`Load error ${e}`);
      });
    });
  }
  parseQuery(query) {
    let result = {};
    let parts = query.split("&");
    parts.forEach((part) => {
      let frag = part.split("=");
      result[decodeURIComponent(frag[0])] = decodeURIComponent(frag[1]);
    });
    return result;
  }
  update(uri) {
    let method = "$/solargraph" + import_coc2.Uri.parse(uri).path;
    let query = this.parseQuery(import_coc2.Uri.parse(uri).query);
    this.languageClient.sendRequest(method, {query: query.query}).then((result) => {
      this.docs[uri.toString()] = result.content;
    });
  }
};
var SolargraphDocumentProvider_default = SolargraphDocumentProvider;

// src/index.ts
async function activate(context) {
  let {subscriptions} = context;
  const config = import_coc3.workspace.getConfiguration().get("solargraph", {});
  const enable = config.enable;
  if (enable === false)
    return;
  let applyConfiguration = (_config) => {
    _config.commandPath = config.commandPath ? import_coc3.workspace.expand(config.commandPath) : "solargraph";
    _config.useBundler = config.useBundler || false;
    _config.bundlerPath = config.bundlerPath ? import_coc3.workspace.expand(config.bundlerPath) : "bundle";
    _config.viewsPath = context.asAbsolutePath("views");
    _config.withSnippets = config.withSnippets || false;
    _config.workspace = import_coc3.workspace.rootPath || null;
  };
  let solargraphConfiguration = new solargraph2.Configuration();
  applyConfiguration(solargraphConfiguration);
  let languageClient;
  let disposableClient;
  const startLanguageServer = () => {
    languageClient = makeLanguageClient(solargraphConfiguration);
    languageClient.onReady().then(() => {
      subscriptions.push(import_coc3.workspace.registerTextDocumentContentProvider("solargraph", new SolargraphDocumentProvider_default(languageClient)));
      if (import_coc3.workspace.getConfiguration("solargraph").checkGemVersion) {
        languageClient.sendNotification("$/solargraph/checkGemVersion", {verbose: false});
      }
    }).catch((err) => {
      console.log("Error starting Solargraph socket provider", err);
      if (!config.promptDownload)
        return;
      if (err.toString().includes("ENOENT") || err.toString().includes("command not found")) {
        import_coc3.window.showPrompt("Solargraph gem not found. Run `gem install solargraph` or update your Gemfile., Install Now?").then((approved) => {
          if (approved) {
            solargraph2.installGem(solargraphConfiguration).then(() => {
              import_coc3.window.showMessage("Successfully installed the Solargraph gem.");
              if (disposableClient)
                disposableClient.dispose();
              startLanguageServer();
            }).catch(() => {
              import_coc3.window.showMessage("Failed to install the Solargraph gem.", "error");
            });
          }
        });
      } else {
        import_coc3.window.showMessage("Failed to start Solargraph: " + err, "error");
      }
    });
    languageClient.start();
    disposableClient = import_coc3.services.registLanguageClient(languageClient);
    context.subscriptions.push(disposableClient);
  };
  let disposableSearch = import_coc3.commands.registerCommand("solargraph.search", async () => {
    let {nvim} = import_coc3.workspace;
    let search = await nvim.call("input", ["Search:", ""]);
    nvim.command("normal! :<C-u>", true);
    if (!search)
      return;
    let uri = "solargraph:///search?query=" + encodeURIComponent(search);
    await import_coc3.workspace.openResource(uri);
  });
  context.subscriptions.push(disposableSearch);
  let disposableEnv = import_coc3.commands.registerCommand("solargraph.environment", () => {
    return import_coc3.workspace.openResource("solargraph:///environment");
  });
  context.subscriptions.push(disposableEnv);
  let disposableCheckGemVersion = import_coc3.commands.registerCommand("solargraph.checkGemVersion", () => {
    if (languageClient) {
      languageClient.sendNotification("$/solargraph/checkGemVersion", {verbose: true});
    }
  });
  context.subscriptions.push(disposableCheckGemVersion);
  let disposableBuildGemDocs = import_coc3.commands.registerCommand("solargraph.buildGemDocs", () => {
    let prepareStatus = import_coc3.window.createStatusBarItem(10, {progress: true});
    prepareStatus.text = "Building new gem documentation...";
    languageClient.sendRequest("$/solargraph/documentGems", {rebuild: false}).then((response) => {
      prepareStatus.dispose();
      if (response["status"] == "ok") {
        import_coc3.window.showMessage("Gem documentation complete.", "more");
      } else {
        import_coc3.window.showMessage("An error occurred building gem documentation.", "error");
        console.log(response);
      }
    });
  });
  context.subscriptions.push(disposableBuildGemDocs);
  let disposableRebuildAllGemDocs = import_coc3.commands.registerCommand("solargraph.rebuildAllGemDocs", () => {
    let prepareStatus = import_coc3.window.createStatusBarItem(10, {progress: true});
    prepareStatus.text = "Rebuilding all gem documentation...";
    languageClient.sendRequest("$/solargraph/documentGems", {rebuild: true}).then((response) => {
      prepareStatus.dispose();
      if (response["status"] == "ok") {
        import_coc3.window.showMessage("Gem documentation complete.", "more");
      } else {
        import_coc3.window.showMessage("An error occurred rebuilding gem documentation.", "error");
        console.log(response);
      }
    });
  });
  context.subscriptions.push(disposableRebuildAllGemDocs);
  let disposableSolargraphConfig = import_coc3.commands.registerCommand("solargraph.config", () => {
    let child = solargraph2.commands.solargraphCommand(["config"], solargraphConfiguration);
    child.on("exit", (code) => {
      if (code == 0) {
        import_coc3.window.showMessage("Created default .solargraph.yml file.");
      } else {
        import_coc3.window.showMessage("Error creating .solargraph.yml file.", "error");
      }
    });
  });
  context.subscriptions.push(disposableSolargraphConfig);
  let disposableSolargraphDownloadCore = import_coc3.commands.registerCommand("solargraph.downloadCore", () => {
    if (languageClient) {
      languageClient.sendNotification("$/solargraph/downloadCore");
    } else {
      import_coc3.window.showMessage("Solargraph is still starting. Please try again in a moment.");
    }
  });
  context.subscriptions.push(disposableSolargraphDownloadCore);
  startLanguageServer();
}
//# sourceMappingURL=index.js.map
